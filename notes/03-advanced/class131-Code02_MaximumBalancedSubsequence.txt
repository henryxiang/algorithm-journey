// 平衡子序列的最大和
// 给定一个长度为n的数组nums，下面定义平衡子序列
// 如果下标i和下标j被选进了子序列，i在j的左边
// 那么必须有nums[j] - nums[i] >= j - i
// 如果一个子序列中任意的两个下标都满足上面的要求，那子序列就是平衡的
// 返回nums所有平衡子序列里，最大的累加和是多少
// 1 <= n <= 10^5
// -10^9 <= nums[i] <= +10^9
// 测试链接 : https://leetcode.cn/problems/maximum-balanced-subsequence-sum/
			// k的含义为当前的指标是第几号指标
			// dp[1号..k号指标]中的最大值是多少
				// 如果之前的最好情况是负数，那么不要之前的数了
				// 当前数字自己单独形成平衡子序列
				// 去更新dp[k号指标]，看能不能变得更大
				// 如果之前的最好情况不是负数，那么和当前数字一起形成更大的累加和
				// 去更新dp[k号指标]，看能不能变得更大
		// 返回dp[1号..m号指标]中的最大值
	// 当前的指标值是v，返回这是第几号指标
	// dp[i号指标]，当前算出的值是v
	// dp[1..i]，最大值多少返回
