// 找到所有好字符串
// 给你两个长度为n的字符串s1和s2，以及一个字符串evil
// 好字符串的定义为 : 长度为n，字典序大于等于s1，字典序小于等于s2，且不包含evil字符串
// 返回好字符串的数量
// 由于答案很大返回对1000000007取余的结果
// 测试链接 : https://leetcode.cn/problems/find-all-good-strings/
		// <=s2的好字符串数量
		// 减去<=s1的好字符串数量
	// 时间复杂度O(n * m * 2 * 26)
	// s、e、n、m都是固定参数
	// 0...i-1已经做了决策，已经匹配了e[0...j-1]这个部分
	// 当前来到s[i]时，最先该考察的匹配位置是e[j]
	// 之前的决策如果已经比s小了，free == 1
	// 之前的决策如果和s[0..i-1]一样，free == 0
	// 返回后续的所有决策中，不含有e字符串且<=s的决策有多少个，同时长度需要为n
	// 核心 : 利用e字符串的next数组加速匹配
			// 一旦配出了e的整体
			// 说明之前的决策已经违规
			// 后续有效决策数量0
		// 能跑如下代码
		// 之前的决策不含有整个e字符串
			// 说明所有决策已经做完了
			// 并且不含有e字符串
			// 同时决策的每一步都保证了不会比s大
			// 返回1种有效决策(之前做的所有决定)
			// 之前的决策和s的状况一样
			// 当前尝试比cur小的字符
			// 当前尝试等于cur的字符
			// 之前的决策已经确定小于s了
			// 当前a~z随便尝试
	// 当前字符是pick，一开始匹配e[j]
	// 根据next数组加速匹配，返回匹配出来的位置
	// 如果匹配不出来返回-1
	// 单次调用的时间复杂度O(1)
