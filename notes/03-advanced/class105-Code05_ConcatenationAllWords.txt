// 串联所有单词的子串
// 给定一个字符串s和一个字符串数组words
// words中所有字符串长度相同
// s中的串联子串是指一个包含 words中所有字符串以任意顺序排列连接起来的子串
// 例如words = { "ab","cd","ef" }
// 那么"abcdef"、"abefcd"、"cdabef"、"cdefab"、"efabcd"、"efcdab"都是串联子串。 
// "acdbef"不是串联子串，因为他不是任何words排列的连接
// 返回所有串联子串在s中的开始索引
// 你可以以任意顺序返回答案
// 测试链接 : https://leetcode.cn/problems/substring-with-concatenation-of-all-words/
	// 如果s的长度为n，words里所有单词的总长度为m
	// 时间复杂度O(n + m)，最优解的时间复杂度与单词个数、单词长度是无关的
	// 所有题解都没有做到这个复杂度的
	// 虽然这个做法打败比例没有到100%，但那是因为测试数据量不够大
	// 所以最优解的时间复杂度优势没有体现出来
	// 这个方法绝对是最优解，只有用字符串哈希，时间复杂度才能到最优
		// words的词频表
		// 窗口的词频表
			// init是当前组的首个开头
			// 建立起窗口
			// 接下来窗口进一个、出一个
	// 范围是s[l,r)，左闭右开
	// 计算一个字符串的哈希值
