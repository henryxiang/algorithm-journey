// 序列操作
// 给定一个长度为n的数组arr，内部只有01两种值，下标从0开始
// 对于这个序列有五种变换操作和询问操作
// 操作 0 l r : 把l~r范围上所有数字全改成0
// 操作 1 l r : 把l~r范围上所有数字全改成1
// 操作 2 l r : 把l~r范围上所有数字全取反
// 操作 3 l r : 询问l~r范围上有多少个1
// 操作 4 l r : 询问l~r范围上连续1的最长子串长度
// 测试链接 : https://www.luogu.com.cn/problem/P2572
// 请同学们务必参考如下代码中关于输入、输出的处理
// 这是输入输出处理效率很高的写法
// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
	// 原始数组
	// 累加和用来统计1的数量
	// 连续0的最长子串长度
	// 连续0的最长前缀长度
	// 连续0的最长后缀长度
	// 连续1的最长子串长度
	// 连续1的最长前缀长度
	// 连续1的最长后缀长度
	// 懒更新信息，范围上所有数字被重置成了什么
	// 懒更新信息，范围上有没有重置任务
	// 懒更新信息，范围上有没有翻转任务
	// 线段树范围l~r上，被jobl~jobr影响的区域里，返回1的数量
	// 返回一个长度为3的数组ans，代表结果，具体含义如下：
	// ans[0] : 线段树范围l~r上，被jobl~jobr影响的区域里，连续1的最长子串长度
	// ans[1] : 线段树范围l~r上，被jobl~jobr影响的区域里，连续1的最长前缀长度
	// ans[2] : 线段树范围l~r上，被jobl~jobr影响的区域里，连续1的最长后缀长度
			// 任务实际影响了左侧范围的几个点 -> mid - Math.max(jobl, l) + 1
			// 任务实际影响了右侧范围的几个点 -> Math.min(r, jobr) - mid
			jobl = (int) in.nval + 1; // 注意题目给的下标从0开始，线段树下标从1开始
			jobr = (int) in.nval + 1; // 注意题目给的下标从0开始，线段树下标从1开始
