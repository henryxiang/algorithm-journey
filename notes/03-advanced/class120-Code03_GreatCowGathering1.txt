// 牛群聚集(递归版)
// 一共有n个节点，编号1~n，每个点有牛的数量
// 一共有n-1条边把所有点联通起来形成一棵树，每条边有权值
// 想把所有的牛汇聚在一点，希望走过的总距离最小
// 返回总距离最小是多少
// 利用重心的性质：
// 树上的边权如果都>=0，不管边权怎么分布，所有节点都走向重心的总距离和最小
// 测试链接 : https://www.luogu.com.cn/problem/P2986
// 提交以下的code，提交时请把类名改成"Main"
// C++这么写能通过，java会因为递归层数太多而爆栈
// java能通过的写法参考本节课Code03_GreatCowGathering2文件
	// cow[i] : i号农场牛的数量
	// 牛的总数
	// size[i] : 从1号节点开始dfs的过程中，以i为头的子树，牛的总量
	// path[i] : 从重心节点开始dfs的过程中，从重心到达i节点，距离是多少
		// 如下代码是遍历完成后再做统计工作
		// 这个写法和之前的逻辑是一样的，为什么要拆开写？
		// 为了后续改迭代版方便
