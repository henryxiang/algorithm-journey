// 还原数组的方法数(不优化枚举)
// 原本有一个长度为n的数组arr，下标从1开始，数组中都是<=200的正数
// 并且任意i位置的数字都满足 : arr[i] <= max(arr[i-1], arr[i+1])
// 特别的，arr[1] <= arr[2]，arr[n] <= arr[n-1]
// 但是输入的arr中有些数字丢失了，丢失的数字用0表示
// 返回还原成不违规的arr有多少种方法，答案很大需要对998244353取余
// 3 <= n <= 10^4
// 测试链接 : https://www.nowcoder.com/practice/49c5284278974cbda474ec13d8bd86a9
// 提交以下的code，提交时请把类名改成"Main"，无法通过所有测试用例
// 需要优化枚举才能通过所有测试用例，具体看本节课Code03_WaysOfRevert2文件的实现
	// 递归 + 记忆化搜索，不优化枚举
	// 时间复杂度O(n * m平方)
	// 1...i范围上去决定数字，i+1位置的数字已经变成了v
	// 如果s == 0, 表示i+1位置变成的数字v > i+2位置变成的数字
	// 如果s == 1, 表示i+1位置变成的数字v <= i+2位置变成的数字
	// 返回还原的方法数
	// 严格位置依赖的动态规划，不优化枚举
	// 时间复杂度O(n * m平方)
	// 空间压缩版本，不优化枚举
	// 时间复杂度O(n * m平方)
