// 边权相等的最小修改次数
// 一棵树有n个节点，编号0 ~ n-1，每条边(u,v,w)表示从u到v有一条权重为w的边
// 一共有m条查询，每条查询(a,b)表示，a到b的最短路径中把所有边变成一种值需要修改几条边
// 返回每条查询的查询结果
// 1 <= n <= 10^4
// 1 <= m <= 2 * 10^4
// 0 <= u、v、a、b < n
// 1 <= w <= 26
// 测试链接 : https://leetcode.cn/problems/minimum-edge-weight-equilibrium-queries-in-a-tree/
	// 链式前向星建图
	// weightCnt[i][w] : 从头节点到i的路径中，权值为w的边有几条
	// 以下所有的结构都是为了tarjan算法做准备
		// 从头节点到每个节点的边权值词频统计
		// 得到每个查询的最低公共祖先
			int allCnt = 0; // 从a到b的路，所有权值的边一共多少条
			int maxCnt = 0; // 从a到b的路，权值重复最多的次数
			for (int w = 1, wcnt; w <= MAXW; w++) { // 所有权值枚举一遍
	// 当前来到u节点，父亲节点f，从f到u权重为w
	// 统计从头节点到u节点，每种权值的边有多少条
	// 信息存放在weightCnt[u][1..26]里
	// tarjan算法批量查询两点的最低公共祖先
