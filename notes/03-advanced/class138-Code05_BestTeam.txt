// 最佳团体
// 给定一棵树，节点编号0~n，0号节点是整棵树的头
// 编号1~n的节点，每个节点都有招募花费和战斗值，0号节点这两个值都是0
// 给定每条边(a,b)，表示节点a的父节点是b，有些节点的父节点是0节点
// 当招募了某个节点，那么该节点及其上方的所有祖先节点都需要招募
// 除了0号节点之外，一共可以招募k个人，希望让
// 战斗值之和 / 招募花费之和，这个比值尽量大，答案只需保留三位小数，更大的精度舍弃
// 1 <= k <= n <= 2500
// 0 <= 招募花费、战斗值 <= 10^4
// 测试链接 : https://www.luogu.com.cn/problem/P4322
// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
	// 链式前向星
	// 招募花费，下标为节点原始编号
	// 战斗值，下标为节点原始编号
	// dfn[a] = b，表示原始a号节点的dfn编号为b
	// dfn序计数
	// (战斗值 - x * 招募花费)的结余，下标为节点dfn编号
	// 子树大小，下标为节点dfn编号
	// 树型dp
	// 记录节点u的dfn编号 + 返回u这棵子树的节点数
	// 如下实现和讲解079，题目5，选课问题的最优解，几乎完全一样
	// 根据x的值，计算节点的结余值，在树上选k+1个点
	// 一定要形成有效结构，返回最大的结余和
	// 核心逻辑完全来自讲解079，题目5，选课问题，重点介绍的最优解
		// value[节点i的dfn编号] = 节点i的战斗值 - x * 节点i的招募花费
		// 越界位置认为都是无效解
		// 讲解079题目5的最优解逻辑
		// 原始的0号节点，dfn编号是1，其他节点的dfn编号从2开始
		// 0号节点的战斗值和招募花费都是0，其他节点一共招募k个
