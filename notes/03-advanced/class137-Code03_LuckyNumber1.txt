// 幸运数字(递归版)
// 一共有n个点，编号1~n，由n-1条边连成一棵树，每个点上有数字
// 一共有q条查询，每次返回a到b的路径上，可以随意选择数字，能得到的最大异或和
// 1 <= n <= 2 * 10^4
// 1 <= q <= 2 * 10^5
// 0 <= 点上的数字 <= 2^60
// 测试链接 : https://www.luogu.com.cn/problem/P3292
// 提交以下的code，提交时请把类名改成"Main"
// C++这么写能通过，java会因为递归层数太多而爆栈
// java能通过的写法参考本节课Code03_LuckyNumber2文件
	// 节点个数上限
	// 树上倍增的次方上限
	// 节点值最大的位数
	// 每个节点值的数组
	// 链式前向星
	// 树上倍增需要的深度表
	// 树上倍增需要的倍增表
	// 树上倍增根据实际节点个数确定的次方
	// bases[i][j]表示：
	// 头节点到i节点路径上的数字，建立异或空间线性基，其中j位的线性基是哪个数字
	// levels[i][j]表示：
	// 头节点到i节点路径上的数字，建立异或空间线性基，其中j位的线性基来自哪一层
	// 插入和替换线性基，本题最重要的函数
	// Kattio类IO效率很好，但还是不如StreamTokenizer
	// 只有StreamTokenizer无法正确处理时，才考虑使用这个类
	// 参考链接 : https://oi-wiki.org/lang/java-pro/
