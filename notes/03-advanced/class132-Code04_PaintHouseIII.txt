// 粉刷房子III
// 房子有n个，从左到右排列，编号1..n，颜色有c种，编号1..c
// 给定数组house，house[i]表示房子的颜色，如果house[i]为0说明房子没有涂色
// 你必须给每个没有涂色的房子涂上颜色，如果有颜色的房子不能改变颜色
// 给定二维数组cost，cost[i][v]表示如果i号房涂成v号颜色，需要花费多少钱
// 相邻的、拥有同一种颜色的房子为1个街区
// 比如如果所有房子的颜色为: {1, 1, 2, 3, 2, 2}，那么一共4个街区
// 最终所有的房子涂完颜色，一定要形成t个街区，返回最少的花费
// 1 <= t <= n <= 100
// 1 <= c <= 20
// 0 <= house[i] <= c
// 1 <= cost[i][v] <= 10^4
// 测试链接 : https://leetcode.cn/problems/paint-house-iii/
	// 原始测试页面的数据描述非常绕，一律转化成课上描述的形式
	// 房子编号从1开始，颜色编号从1开始，颜色0代表没有涂色
	// build方法就是转化逻辑
	// 递归 + 记忆化搜索，不优化枚举
	// 时间复杂度O(n * t * c平方)
	// 1...i范围的房子去确定颜色，i+1号房子的颜色已经涂成了v
	// 1...i+1范围的房子必须凑齐j个街区，返回最少的花费
	// 如果做不到返回NA
	// 严格位置依赖的动态规划，不优化枚举
	// 时间复杂度O(n * t * c平方)
	// 空间压缩版本，不优化枚举
	// 时间复杂度O(n * t * c平方)
		// 因为此时只有memo、dp两份空间
		// 所以让memo[0][v] = dp[0][v] = NA
		// 这样一来，在滚动更新时，不管i是多少，只要j==0，那么结果都是NA
		// i == 0时，结果填入memo表
		// 滚动更新
	// 最优解
	// 优化枚举 + 空间压缩
	// 时间复杂度O(n * t * c)
		// pre[s] : dp[i-1][j][1...s] + cost[i][1...s]中的最小值
		// suf[s] : dp[i-1][j][s...c] + cost[i][s...c]中的最小值
				// 预处理结构优化前缀枚举
				// 预处理结构优化后缀枚举
				// 填写dp表
