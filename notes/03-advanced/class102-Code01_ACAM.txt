// AC自动机模版(优化版)
// 给你若干目标字符串，还有一篇文章
// 返回每个目标字符串在文章中出现了几次
// 测试链接 : https://www.luogu.com.cn/problem/P5357
// 请同学们务必参考如下代码中关于输入、输出的处理
// 这是输入输出处理效率很高的写法
// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
	// 目标字符串的数量
	// 所有目标字符串的总字符数量
	// 记录每个目标串的结尾节点编号
	// AC自动机
	// 具体题目相关，本题为收集词频
	// 所以每个节点记录词频
	// 可以用作队列或者栈，一个容器而已
	// 链式前向星，为了建立fail指针的反图
	// 遍历fail反图，递归方法会爆栈，所以用非递归替代
	// AC自动机加入目标字符串
		// 每个目标字符串的结尾节点编号
	// 加入所有目标字符串之后
	// 设置fail指针 以及 设置直接直通表
	// 做了AC自动机固定的优化
		// box当做队列来使用
		// AC自动机建树
		// 读入大文章
			// 增加匹配次数
			// 根据fail指针建反图
			// 其实是一颗树
		// 遍历fail指针建的树
		// 汇总每个节点的词频
	// 逻辑是对的
	// 但是递归开太多层了会爆栈
	// C++这道题不会爆栈
	// java会
	// 改成非递归才能通过
	// 因为是用栈来模拟递归
	// 只消耗内存空间(box和visited)
	// 不消耗系统栈的空间
	// 所以很安全
		// box当做栈来使用
