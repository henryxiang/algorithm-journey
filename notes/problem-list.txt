算法讲解001【入门】学习算法的语言问题以及如何开通gpt4
// 测试链接 : https://leetcode.cn/problems/sort-an-array/
// 此时不要求掌握，因为这些排序后续的课都会讲到的
// 这里只是想说明代码语言的转换并不困难
// 整个系列虽然都是java讲的，但使用不同语言的同学听懂思路之后，想理解代码真的不是问题
// 语言问题并不是学习算法的障碍，有了人工智能工具之后，就更不是障碍了
算法讲解002【入门】从社会实验到入门提醒
// 一开始有100个人，每个人都有100元
// 在每一轮都做如下的事情 : 
// 每个人都必须拿出1元钱给除自己以外的其他人，给谁完全随机
// 如果某个人在这一轮的钱数为0，那么他可以不给，但是可以接收
// 发生很多很多轮之后，这100人的社会财富分布很均匀吗？
算法讲解003【入门】二进制和位运算
// 本文件的实现是用int来举例的
// 对于long类型完全同理
// 不过要注意，如果是long类型的数字num，有64位
// num & (1 << 48)，这种写法不对
// 因为1是一个int类型，只有32位，所以(1 << 48)早就溢出了，所以无意义
// 应该写成 : num & (1L << 48)
算法讲解004【入门】选择、冒泡、插入排序
算法讲解005【入门】对数器-验证的重要手段
算法讲解006【入门】二分搜索
class006/Code01_FindNumber.java:// 有序数组中是否存在一个数字
class006/Code02_FindLeft.java:// 有序数组中找>=num的最左位置
class006/Code03_FindRight.java:// 有序数组中找<=num的最右位置
class006/Code04_FindPeakElement.java:// 峰值元素是指其值严格大于左右相邻值的元素
class006/Code04_FindPeakElement.java:// 给你一个整数数组 nums，已知任何两个相邻的值都不相等
class006/Code04_FindPeakElement.java:// 找到峰值元素并返回其索引
class006/Code04_FindPeakElement.java:// 数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。
class006/Code04_FindPeakElement.java:// 你可以假设 nums[-1] = nums[n] = 无穷小
class006/Code04_FindPeakElement.java:// 你必须实现时间复杂度为 O(log n) 的算法来解决此问题。
算法讲解007【入门】时间复杂度和空间复杂度
算法讲解008【入门】算法和数据结构简介
算法讲解009【入门】单双链表及其反转-堆栈诠释
// 按值传递、按引用传递
// 从堆栈角度解释链表节点
// 以堆栈视角来看链表反转
算法讲解010【入门】链表入门题目-合并两个有序链表
// 将两个升序链表合并为一个新的 升序 链表并返回
// 新链表是通过拼接给定的两个链表的所有节点组成的
// 测试链接 : https://leetcode.cn/problems/merge-two-sorted-lists/
算法讲解011【入门】链表入门题目-两个链表相加
// 给你两个 非空 的链表，表示两个非负的整数
// 它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字
// 请你将两个数相加，并以相同形式返回一个表示和的链表。
// 你可以假设除了数字 0 之外，这两个数都不会以 0 开头
// 测试链接：https://leetcode.cn/problems/add-two-numbers/
算法讲解012【入门】链表入门题目-划分链表
// 给你一个链表的头节点 head 和一个特定值 x
// 请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。
// 你应当 保留 两个分区中每个节点的初始相对位置
// 测试链接 : https://leetcode.cn/problems/partition-list/
算法讲解013【入门】队列和栈 链表、数组实现
算法讲解014【入门】队列和栈入门题目-栈和队列相互实现
// 用栈实现队列
// 用队列实现栈
算法讲解015【入门】栈的入门题目-最小栈
// 最小栈
// 测试链接 : https://leetcode.cn/problems/min-stack/
算法讲解016【入门】双端队列-双链表和固定数组实现
// 设计循环双端队列
// 测试链接 : https://leetcode.cn/problems/design-circular-deque/
算法讲解017【入门】二叉树及其三种序的递归实现
// 递归序的解释
// 用递归实现二叉树的三序遍历
算法讲解018【入门】二叉树遍历的非递归实现和复杂度分析
// 不用递归，用迭代的方式实现二叉树的三序遍历
算法讲解019【必备】算法笔试中处理输入和输出
class019/Code01_FillFunction.java:// 展示填函数风格的测试方式
class019/Code01_FillFunction.java:// 子矩阵的最大累加和问题，不要求会解题思路，后面的课会讲
class019/Code01_FillFunction.java:// 测试链接 : https://www.nowcoder.com/practice/840eee05dccd4ffd8f9433ce8085946b
class019/Code02_SpecifyAmount.java:// 展示acm风格的测试方式
class019/Code02_SpecifyAmount.java:// 子矩阵的最大累加和问题，不要求会解题思路，后面的课会讲
class019/Code02_SpecifyAmount.java:// 每一组测试都给定数据规模
class019/Code02_SpecifyAmount.java:// 需要任何空间都动态生成，在大厂笔试或者比赛中，这种方式并不推荐
class019/Code02_SpecifyAmount.java:// 测试链接 : https://www.nowcoder.com/practice/cb82a97dcd0d48a7b1f4ee917e2c0409?
class019/Code02_SpecifyAmount.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class019/Code02_SpecifyAmount.java:// 这是输入输出处理效率很高的写法
class019/Code02_SpecifyAmount.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class019/Code03_StaticSpace.java:// 展示acm风格的测试方式
class019/Code03_StaticSpace.java:// 子矩阵的最大累加和问题，不要求会解题思路，后面的课会讲
class019/Code03_StaticSpace.java:// 每一组测试都给定数据规模
class019/Code03_StaticSpace.java:// 任何空间都提前生成好，一律都是静态空间，然后自己去复用，推荐这种方式
class019/Code03_StaticSpace.java:// 测试链接 : https://www.nowcoder.com/practice/cb82a97dcd0d48a7b1f4ee917e2c0409?
class019/Code03_StaticSpace.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class019/Code03_StaticSpace.java:// 这是输入输出处理效率很高的写法
class019/Code03_StaticSpace.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class019/Code04_ReadByLine.java:// 展示acm风格的测试方式
class019/Code04_ReadByLine.java:// 测试链接 : https://www.nowcoder.com/exam/test/70070648/detail?pid=27976983
class019/Code04_ReadByLine.java:// 其中，7.A+B(7)，就是一个没有给定数据规模，只能按行读数据的例子
class019/Code04_ReadByLine.java:// 此时需要自己切分出数据来计算
class019/Code04_ReadByLine.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class019/Code04_ReadByLine.java:// 这是输入输出处理效率很高的写法
class019/Code04_ReadByLine.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class019/Code05_Kattio.java:// 本文件课上没有讲，介绍一下Kattio类的使用
class019/Code05_Kattio.java:// 某些题目的输入，使用StreamTokenizer就是无法正确读入
class019/Code05_Kattio.java:// 那么可以使用本文件提供的Kattio类
class019/Code05_Kattio.java:// 比如，就是需要依次读取一个一个的字符串进行处理
class019/Code05_Kattio.java:// 再比如，StreamTokenizer读取：不溢出、但是很大的long类型数字时，可能会读入错误
class019/Code05_Kattio.java:// 再比如，StreamTokenizer读取：科学计数法表达的double类型数字时，可能会读入错误
class019/Code05_Kattio.java:// 如果使用Kattio进行读取，就没有这些问题
class019/Code05_Kattio.java:// 可以直接运行本文件的main函数，根据提示输入给定的数字，能清晰的看到这一点
class019/Code05_Kattio.java:// 那么可不可以放弃StreamTokenizer，以后都用Kattio呢？
class019/Code05_Kattio.java:// 不行！因为StreamTokenizer的效率还是比Kattio好！
class019/Code05_Kattio.java:// 只有在StreamTokenizer无法正确读取的情况下，才考虑使用Kattio类
class019/Code05_Kattio.java:// 其他语言中一定有对等的概念，不是java的同学，请自行搞定
算法讲解020【必备】递归和master公式
// 用这个例子讲解递归如何执行
算法讲解021【必备】归并排序
class021/Code01_MergeSort.java:// 归并排序，acm练习风格
class021/Code01_MergeSort.java:// 测试链接 : https://www.luogu.com.cn/problem/P1177
class021/Code01_MergeSort.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class021/Code01_MergeSort.java:// 这是输入输出处理效率很高的写法
class021/Code01_MergeSort.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class021/Code02_MergeSort.java:// 归并排序，填函数练习风格
class021/Code02_MergeSort.java:// 测试链接 : https://leetcode.cn/problems/sort-an-array/
算法讲解022【必备】归并分治
class022/Code01_SmallSum.java:// 小和问题
class022/Code01_SmallSum.java:// 测试链接 : https://www.nowcoder.com/practice/edfe05a1d45c4ea89101d936cac32469
class022/Code01_SmallSum.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class022/Code01_SmallSum.java:// 这是输入输出处理效率很高的写法
class022/Code01_SmallSum.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class022/Code02_ReversePairs.java:// 翻转对数量
class022/Code02_ReversePairs.java:// 测试链接 : https://leetcode.cn/problems/reverse-pairs/
算法讲解023【必备】随机快速排序
class023/Code01_QuickSort.java:// 随机快速排序，acm练习风格
class023/Code01_QuickSort.java:// 测试链接 : https://www.luogu.com.cn/problem/P1177
class023/Code01_QuickSort.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class023/Code01_QuickSort.java:// 这是输入输出处理效率很高的写法
class023/Code01_QuickSort.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class023/Code02_QuickSort.java:// 随机快速排序，填函数练习风格
class023/Code02_QuickSort.java:// 测试链接 : https://leetcode.cn/problems/sort-an-array/
算法讲解024【必备】随机选择算法
// 无序数组中第K大的元素
// 测试链接 : https://leetcode.cn/problems/kth-largest-element-in-an-array/
算法讲解025【必备】堆结构和堆排序
class025/Code01_HeapSort.java:// 堆结构和堆排序，acm练习风格
class025/Code01_HeapSort.java:// 测试链接 : https://www.luogu.com.cn/problem/P1177
class025/Code01_HeapSort.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class025/Code01_HeapSort.java:// 这是输入输出处理效率很高的写法
class025/Code01_HeapSort.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class025/Code02_HeapSort.java:// 堆结构和堆排序，填函数练习风格
class025/Code02_HeapSort.java:// 测试链接 : https://leetcode.cn/problems/sort-an-array/
算法讲解026【必备】哈希表、有序表和比较器的用法
算法讲解027【必备】堆结构常见题
class027/Code01_MergeKSortedLists.java:// 合并K个有序链表
class027/Code01_MergeKSortedLists.java:// 测试链接：https://www.nowcoder.com/practice/65cfde9e5b9b4cf2b6bafa5f3ef33fa6
class027/Code02_MaxCover.java:// 最多线段重合问题
class027/Code02_MaxCover.java:// 测试链接 : https://www.nowcoder.com/practice/1ae8d0b6bb4e4bcdbf64ec491f63fc37
class027/Code02_MaxCover.java:// 测试链接 : https://leetcode.cn/problems/meeting-rooms-ii/
class027/Code02_MaxCover.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class027/Code02_MaxCover.java:// 这是输入输出处理效率很高的写法
class027/Code02_MaxCover.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class027/Code03_MinimumOperationsToHalveArraySum.java:// 将数组和减半的最少操作次数
class027/Code03_MinimumOperationsToHalveArraySum.java:// 测试链接 : https://leetcode.cn/problems/minimum-operations-to-halve-array-sum/
算法讲解028【必备】基数排序
class028/Code01_RadixSort.java:// 基数排序，acm练习风格
class028/Code01_RadixSort.java:// 测试链接 : https://www.luogu.com.cn/problem/P1177
class028/Code01_RadixSort.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class028/Code01_RadixSort.java:// 这是输入输出处理效率很高的写法
class028/Code01_RadixSort.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class028/Code02_RadixSort.java:// 基数排序
class028/Code02_RadixSort.java:// 测试链接 : https://leetcode.cn/problems/sort-an-array/
算法讲解029【必备】重要排序算法的总结
算法讲解030【必备】异或运算的骚操作
class030/Code01_SwapExclusiveOr.java:// 用异或运算交换两数的值
class030/Code02_GetMaxWithoutJudge.java:// 不用任何判断语句和比较操作，返回两个数的最大值
class030/Code02_GetMaxWithoutJudge.java:// 测试链接 : https://www.nowcoder.com/practice/d2707eaf98124f1e8f1d9c18ad487f76
class030/Code03_MissingNumber.java:// 找到缺失的数字
class030/Code03_MissingNumber.java:// 测试链接 : https://leetcode.cn/problems/missing-number/
class030/Code04_SingleNumber.java:// 数组中1种数出现了奇数次，其他的数都出现了偶数次
class030/Code04_SingleNumber.java:// 返回出现了奇数次的数
class030/Code04_SingleNumber.java:// 测试链接 : https://leetcode.cn/problems/single-number/
class030/Code05_DoubleNumber.java:// 数组中有2种数出现了奇数次，其他的数都出现了偶数次
class030/Code05_DoubleNumber.java:// 返回这2种出现了奇数次的数
class030/Code05_DoubleNumber.java:// 测试链接 : https://leetcode.cn/problems/single-number-iii/
class030/Code06_OneKindNumberLessMtimes.java:// 数组中只有1种数出现次数少于m次，其他数都出现了m次
class030/Code06_OneKindNumberLessMtimes.java:// 返回出现次数小于m次的那种数
class030/Code06_OneKindNumberLessMtimes.java:// 测试链接 : https://leetcode.cn/problems/single-number-ii/
class030/Code06_OneKindNumberLessMtimes.java:// 注意 : 测试题目只是通用方法的一个特例，课上讲了更通用的情况
算法讲解031【必备】位运算的骚操作
class031/Code01_PowerOfTwo.java:// Brian Kernighan算法
class031/Code01_PowerOfTwo.java:// 提取出二进制里最右侧的1
class031/Code01_PowerOfTwo.java:// 判断一个整数是不是2的幂
class031/Code01_PowerOfTwo.java:// 测试链接 : https://leetcode.cn/problems/power-of-two/
class031/Code02_PowerOfThree.java:// 判断一个整数是不是3的幂
class031/Code02_PowerOfThree.java:// 测试链接 : https://leetcode.cn/problems/power-of-three/
class031/Code03_Near2power.java:// 已知n是非负数
class031/Code03_Near2power.java:// 返回大于等于n的最小的2某次方
class031/Code03_Near2power.java:// 如果int范围内不存在这样的数，返回整数最小值
class031/Code04_LeftToRightAnd.java:// 给你两个整数 left 和 right ，表示区间 [left, right]
class031/Code04_LeftToRightAnd.java:// 返回此区间内所有数字 & 的结果
class031/Code04_LeftToRightAnd.java:// 包含 left 、right 端点
class031/Code04_LeftToRightAnd.java:// 测试链接 : https://leetcode.cn/problems/bitwise-and-of-numbers-range/
class031/Code05_ReverseBits.java:// 逆序二进制的状态
class031/Code05_ReverseBits.java:// 测试链接 : https://leetcode.cn/problems/reverse-bits/
class031/Code06_CountOnesBinarySystem.java:// 返回n的二进制中有几个1
class031/Code06_CountOnesBinarySystem.java:// 两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。
class031/Code06_CountOnesBinarySystem.java:// 给你两个整数 x 和 y，计算并返回它们之间的汉明距离
class031/Code06_CountOnesBinarySystem.java:// 测试链接 : https://leetcode.cn/problems/hamming-distance/
算法讲解032【必备】位图
class032/Code01_Bitset.java:// 位图的实现
class032/Code01_Bitset.java:// Bitset(int size)
class032/Code01_Bitset.java:// void add(int num)
class032/Code01_Bitset.java:// void remove(int num)
class032/Code01_Bitset.java:// void reverse(int num)
class032/Code01_Bitset.java:// boolean contains(int num)
class032/Code02_DesignBitsetTest.java:// 位图的实现
class032/Code02_DesignBitsetTest.java:// Bitset是一种能以紧凑形式存储位的数据结构
class032/Code02_DesignBitsetTest.java:// Bitset(int n) : 初始化n个位，所有位都是0
class032/Code02_DesignBitsetTest.java:// void fix(int i) : 将下标i的位上的值更新为1
class032/Code02_DesignBitsetTest.java:// void unfix(int i) : 将下标i的位上的值更新为0
class032/Code02_DesignBitsetTest.java:// void flip() : 翻转所有位的值
class032/Code02_DesignBitsetTest.java:// boolean all() : 是否所有位都是1
class032/Code02_DesignBitsetTest.java:// boolean one() : 是否至少有一位是1
class032/Code02_DesignBitsetTest.java:// int count() : 返回所有位中1的数量
class032/Code02_DesignBitsetTest.java:// String toString() : 返回所有位的状态
算法讲解033【必备】位运算实现加减乘除
// 不用任何算术运算，只用位运算实现加减乘除
// 代码实现中你找不到任何一个算术运算符
// 测试链接 : https://leetcode.cn/problems/divide-two-integers/
算法讲解034【必备】链表高频题目和必备技巧
class034/Code01_IntersectionOfTwoLinkedLists.java:// 返回两个无环链表相交的第一个节点
class034/Code01_IntersectionOfTwoLinkedLists.java:// 测试链接 : https://leetcode.cn/problems/intersection-of-two-linked-lists/
class034/Code02_ReverseNodesInkGroup.java:// 每k个节点一组翻转链表
class034/Code02_ReverseNodesInkGroup.java:// 测试链接：https://leetcode.cn/problems/reverse-nodes-in-k-group/
class034/Code03_CopyListWithRandomPointer.java:// 复制带随机指针的链表
class034/Code03_CopyListWithRandomPointer.java:// 测试链接 : https://leetcode.cn/problems/copy-list-with-random-pointer/
class034/Code04_PalindromeLinkedList.java:// 判断链表是否是回文结构
class034/Code04_PalindromeLinkedList.java:// 测试链接 : https://leetcode.cn/problems/palindrome-linked-list/
class034/Code05_LinkedListCycleII.java:// 返回链表的第一个入环节点
class034/Code05_LinkedListCycleII.java:// 测试链接 : https://leetcode.cn/problems/linked-list-cycle-ii/
class034/Code06_SortList.java:// 排序链表
class034/Code06_SortList.java:// 要求时间复杂度O(n*logn)，额外空间复杂度O(1)，还要求稳定性
class034/Code06_SortList.java:// 数组排序做不到，链表排序可以
class034/Code06_SortList.java:// 测试链接 : https://leetcode.cn/problems/sort-list/
算法讲解035【必备】数据结构设计高频题
class035/Code01_SetAllHashMap.java:// setAll功能的哈希表
class035/Code01_SetAllHashMap.java:// 测试链接 : https://www.nowcoder.com/practice/7c4559f138e74ceb9ba57d76fd169967
class035/Code01_SetAllHashMap.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class035/Code01_SetAllHashMap.java:// 这是输入输出处理效率很高的写法
class035/Code01_SetAllHashMap.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class035/Code02_LRU.java:// 实现LRU结构
class035/Code03_InsertDeleteRandom.java:// 插入、删除和获取随机元素O(1)时间的结构
class035/Code04_InsertDeleteRandomDuplicatesAllowed.java:// 插入、删除和获取随机元素O(1)时间且允许有重复数字的结构
class035/Code05_MedianFinder.java:// 快速获得数据流的中位数的结构
class035/Code06_MaximumFrequencyStack.java:// 最大频率栈
class035/Code07_AllO1.java:// 全O(1)的数据结构
算法讲解036【必备】二叉树高频题目-上-不含树型dp
class036/Code01_LevelOrderTraversal.java:// 二叉树的层序遍历
class036/Code01_LevelOrderTraversal.java:// 测试链接 : https://leetcode.cn/problems/binary-tree-level-order-traversal/
class036/Code02_ZigzagLevelOrderTraversal.java:// 二叉树的锯齿形层序遍历
class036/Code02_ZigzagLevelOrderTraversal.java:// 测试链接 : https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/
class036/Code03_WidthOfBinaryTree.java:// 二叉树的最大特殊宽度
class036/Code03_WidthOfBinaryTree.java:// 测试链接 : https://leetcode.cn/problems/maximum-width-of-binary-tree/
class036/Code04_DepthOfBinaryTree.java:// 求二叉树的最大、最小深度
class036/Code05_PreorderSerializeAndDeserialize.java:// 二叉树先序序列化和反序列化
class036/Code05_PreorderSerializeAndDeserialize.java:// 测试链接 : https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/
class036/Code06_LevelorderSerializeAndDeserialize.java:// 二叉树按层序列化和反序列化
class036/Code06_LevelorderSerializeAndDeserialize.java:// 测试链接 : https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/
class036/Code07_PreorderInorderBuildBinaryTree.java:// 利用先序与中序遍历序列构造二叉树
class036/Code07_PreorderInorderBuildBinaryTree.java:// 测试链接 : https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
class036/Code08_CompletenessOfBinaryTree.java:// 验证完全二叉树
class036/Code08_CompletenessOfBinaryTree.java:// 测试链接 : https://leetcode.cn/problems/check-completeness-of-a-binary-tree/
class036/Code09_CountCompleteTreeNodes.java:// 求完全二叉树的节点个数
class036/Code09_CountCompleteTreeNodes.java:// 测试链接 : https://leetcode.cn/problems/count-complete-tree-nodes/
算法讲解037【必备】二叉树高频题目-下-不含树型dp
class037/Code01_LowestCommonAncestor.java:// 普通二叉树上寻找两个节点的最近公共祖先
class037/Code01_LowestCommonAncestor.java:// 测试链接 : https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/
class037/Code02_LowestCommonAncestorBinarySearch.java:// 搜索二叉树上寻找两个节点的最近公共祖先
class037/Code02_LowestCommonAncestorBinarySearch.java:// 测试链接 : https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/
class037/Code03_PathSumII.java:// 收集累加和等于aim的所有路径
class037/Code03_PathSumII.java:// 测试链接 : https://leetcode.cn/problems/path-sum-ii/
class037/Code04_BalancedBinaryTree.java:// 验证平衡二叉树
class037/Code04_BalancedBinaryTree.java:// 测试链接 : https://leetcode.cn/problems/balanced-binary-tree/
class037/Code05_ValidateBinarySearchTree.java:// 验证搜索二叉树
class037/Code05_ValidateBinarySearchTree.java:// 测试链接 : https://leetcode.cn/problems/validate-binary-search-tree/
class037/Code06_TrimBinarySearchTree.java:// 修剪搜索二叉树
class037/Code06_TrimBinarySearchTree.java:// 测试链接 : https://leetcode.cn/problems/trim-a-binary-search-tree/
class037/Code07_HouseRobberIII.java:// 二叉树打家劫舍问题
class037/Code07_HouseRobberIII.java:// 测试链接 : https://leetcode.cn/problems/house-robber-iii/
算法讲解038【必备】常见经典递归过程解析
class038/Code01_Subsequences.java:// 字符串的全部子序列
class038/Code01_Subsequences.java:// 子序列本身是可以有重复的，只是这个题目要求去重
class038/Code01_Subsequences.java:// 测试链接 : https://www.nowcoder.com/practice/92e6247998294f2c933906fdedbc6e6a
class038/Code02_Combinations.java:// 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的组合
class038/Code02_Combinations.java:// 答案 不能 包含重复的组合。返回的答案中，组合可以按 任意顺序 排列
class038/Code02_Combinations.java:// 注意其实要求返回的不是子集，因为子集一定是不包含相同元素的，要返回的其实是不重复的组合
class038/Code02_Combinations.java:// 比如输入：nums = [1,2,2]
class038/Code02_Combinations.java:// 输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
class038/Code02_Combinations.java:// 测试链接 : https://leetcode.cn/problems/subsets-ii/
class038/Code03_Permutations.java:// 没有重复项数字的全排列
class038/Code03_Permutations.java:// 测试链接 : https://leetcode.cn/problems/permutations/
class038/Code04_PermutationWithoutRepetition.java:// 有重复项数组的去重全排列
class038/Code04_PermutationWithoutRepetition.java:// 测试链接 : https://leetcode.cn/problems/permutations-ii/
class038/Code05_ReverseStackWithRecursive.java:// 用递归函数逆序栈
class038/Code06_SortStackWithRecursive.java:// 用递归函数排序栈
class038/Code06_SortStackWithRecursive.java:// 栈只提供push、pop、isEmpty三个方法
class038/Code06_SortStackWithRecursive.java:// 请完成无序栈的排序，要求排完序之后，从栈顶到栈底从小到大
class038/Code06_SortStackWithRecursive.java:// 只能使用栈提供的push、pop、isEmpty三个方法、以及递归函数
class038/Code06_SortStackWithRecursive.java:// 除此之外不能使用任何的容器，数组也不行
class038/Code06_SortStackWithRecursive.java:// 就是排序过程中只能用：
class038/Code06_SortStackWithRecursive.java:// 1) 栈提供的push、pop、isEmpty三个方法
class038/Code06_SortStackWithRecursive.java:// 2) 递归函数，并且返回值最多为单个整数
class038/Code07_TowerOfHanoi.java:// 打印n层汉诺塔问题的最优移动轨迹
算法讲解039【必备】嵌套类问题的递归解题套路
class039/Code01_BasicCalculatorIII.java:// 含有嵌套的表达式求值
class039/Code01_BasicCalculatorIII.java:// 测试链接 : https://leetcode.cn/problems/basic-calculator-iii/
class039/Code02_DecodeString.java:// 含有嵌套的字符串解码
class039/Code02_DecodeString.java:// 测试链接 : https://leetcode.cn/problems/decode-string/
class039/Code03_NumberOfAtoms.java:// 含有嵌套的分子式求原子数量
class039/Code03_NumberOfAtoms.java:// 测试链接 : https://leetcode.cn/problems/number-of-atoms/
算法讲解040【必备】N皇后问题-重点是位运算的版本
// N皇后问题
// 测试链接 : https://leetcode.cn/problems/n-queens-ii/
算法讲解041【必备】最大公约数、同余原理
class041/Code01_GcdAndLcm.java:// 求最大公约数、最小公倍数
class041/Code02_NthMagicalNumber.java:// 一个正整数如果能被 a 或 b 整除，那么它是神奇的。
class041/Code02_NthMagicalNumber.java:// 给定三个整数 n , a , b ，返回第 n 个神奇的数字。
class041/Code02_NthMagicalNumber.java:// 因为答案可能很大，所以返回答案 对 10^9 + 7 取模 后的值。
class041/Code02_NthMagicalNumber.java:// 测试链接 : https://leetcode.cn/problems/nth-magical-number/
class041/Code03_SameMod.java:// 加法、减法、乘法的同余原理
class041/Code03_SameMod.java:// 不包括除法，因为除法必须求逆元，后续课讲述
算法讲解042【必备】对数器打表找规律的技巧
class042/Code01_AppleMinBags.java:// 有装下8个苹果的袋子、装下6个苹果的袋子，一定要保证买苹果时所有使用的袋子都装满
class042/Code01_AppleMinBags.java:// 对于无法装满所有袋子的方案不予考虑，给定n个苹果，返回至少要多少个袋子
class042/Code01_AppleMinBags.java:// 如果不存在每个袋子都装满的方案返回-1
class042/Code02_EatGrass.java:// 草一共有n的重量，两只牛轮流吃草，A牛先吃，B牛后吃
class042/Code02_EatGrass.java:// 每只牛在自己的回合，吃草的重量必须是4的幂，1、4、16、64....
class042/Code02_EatGrass.java:// 谁在自己的回合正好把草吃完谁赢，根据输入的n，返回谁赢
class042/Code03_IsSumOfConsecutiveNumbers.java:// 判断一个数字是否是若干数量(数量>1)的连续正整数的和
class042/Code04_RedPalindromeGoodStrings.java:// 可以用r、e、d三种字符拼接字符串，如果拼出来的字符串中
class042/Code04_RedPalindromeGoodStrings.java:// 有且仅有1个长度>=2的回文子串，那么这个字符串定义为"好串"
class042/Code04_RedPalindromeGoodStrings.java:// 返回长度为n的所有可能的字符串中，好串有多少个
class042/Code04_RedPalindromeGoodStrings.java:// 结果对1000000007取模， 1 <= n <= 10^9
class042/Code04_RedPalindromeGoodStrings.java:// 示例：
class042/Code04_RedPalindromeGoodStrings.java:// n = 1, 输出0
class042/Code04_RedPalindromeGoodStrings.java:// n = 2, 输出3
class042/Code04_RedPalindromeGoodStrings.java:// n = 3, 输出18
算法讲解043【必备】根据数据量猜解法的技巧-天字第一号重要技巧
class043/Code01_KillMonsterEverySkillUseOnce.java:// 现在有一个打怪类型的游戏，这个游戏是这样的，你有n个技能
class043/Code01_KillMonsterEverySkillUseOnce.java:// 每一个技能会有一个伤害，
class043/Code01_KillMonsterEverySkillUseOnce.java:// 同时若怪物小于等于一定的血量，则该技能可能造成双倍伤害
class043/Code01_KillMonsterEverySkillUseOnce.java:// 每一个技能最多只能释放一次，已知怪物有m点血量
class043/Code01_KillMonsterEverySkillUseOnce.java:// 现在想问你最少用几个技能能消灭掉他(血量小于等于0)
class043/Code01_KillMonsterEverySkillUseOnce.java:// 技能的数量是n，怪物的血量是m
class043/Code01_KillMonsterEverySkillUseOnce.java:// i号技能的伤害是x[i]，i号技能触发双倍伤害的血量最小值是y[i]
class043/Code01_KillMonsterEverySkillUseOnce.java:// 1 <= n <= 10
class043/Code01_KillMonsterEverySkillUseOnce.java:// 1 <= m、x[i]、y[i] <= 10^6
class043/Code01_KillMonsterEverySkillUseOnce.java:// 测试链接 : https://www.nowcoder.com/practice/d88ef50f8dab4850be8cd4b95514bbbd
class043/Code01_KillMonsterEverySkillUseOnce.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class043/Code01_KillMonsterEverySkillUseOnce.java:// 这是输入输出处理效率很高的写法
class043/Code01_KillMonsterEverySkillUseOnce.java:// 提交以下的所有代码，并把主类名改成"Main"
class043/Code01_KillMonsterEverySkillUseOnce.java:// 可以直接通过
class043/Code02_SuperPalindromes.java:// 如果一个正整数自身是回文数，而且它也是一个回文数的平方，那么我们称这个数为超级回文数。
class043/Code02_SuperPalindromes.java:// 现在，给定两个正整数 L 和 R （以字符串形式表示），
class043/Code02_SuperPalindromes.java:// 返回包含在范围 [L, R] 中的超级回文数的数目。
class043/Code02_SuperPalindromes.java:// 1 <= len(L) <= 18
class043/Code02_SuperPalindromes.java:// 1 <= len(R) <= 18
class043/Code02_SuperPalindromes.java:// L 和 R 是表示 [1, 10^18) 范围的整数的字符串
class043/Code02_SuperPalindromes.java://测试链接 : https://leetcode.cn/problems/super-palindromes/
class043/Code03_IsPalindrome.java:// 超级回文数中的一个小函数，本身也是一道题 : 判断一个数字是不是回文数
class043/Code03_IsPalindrome.java:// 测试链接 : https://leetcode.cn/problems/palindrome-number/
算法讲解044【必备】前缀树原理和代码详解
class044/Code01_TrieTree.java:// 用类描述实现前缀树。不推荐！
class044/Code01_TrieTree.java:// 测试链接 : https://leetcode.cn/problems/implement-trie-ii-prefix-tree/
class044/Code02_TrieTree.java:// 用固定数组实现前缀树，空间使用是静态的。推荐！
class044/Code02_TrieTree.java:// 测试链接 : https://www.nowcoder.com/practice/7f8a8553ddbf4eaab749ec988726702b
class044/Code02_TrieTree.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class044/Code02_TrieTree.java:// 这是输入输出处理效率很高的写法
class044/Code02_TrieTree.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
算法讲解045【必备】前缀树的相关题目
class045/Code01_CountConsistentKeys.java:// 牛牛和他的朋友们约定了一套接头密匙系统，用于确认彼此身份
class045/Code01_CountConsistentKeys.java:// 密匙由一组数字序列表示，两个密匙被认为是一致的，如果满足以下条件：
class045/Code01_CountConsistentKeys.java:// 密匙 b 的长度不超过密匙 a 的长度。
class045/Code01_CountConsistentKeys.java:// 对于任意 0 <= i < length(b)，有b[i+1] - b[i] == a[i+1] - a[i]
class045/Code01_CountConsistentKeys.java:// 现在给定了m个密匙 b 的数组，以及n个密匙 a 的数组
class045/Code01_CountConsistentKeys.java:// 请你返回一个长度为 m 的结果数组 ans，表示每个密匙b都有多少一致的密匙
class045/Code01_CountConsistentKeys.java:// 数组 a 和数组 b 中的元素个数均不超过 10^5
class045/Code01_CountConsistentKeys.java:// 1 <= m, n <= 1000
class045/Code01_CountConsistentKeys.java:// 测试链接 : https://www.nowcoder.com/practice/c552d3b4dfda49ccb883a6371d9a6932
class045/Code02_TwoNumbersMaximumXor.java:// 数组中两个数的最大异或值
class045/Code02_TwoNumbersMaximumXor.java:// 给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0<=i<=j<=n
class045/Code02_TwoNumbersMaximumXor.java:// 1 <= nums.length <= 2 * 10^5
class045/Code02_TwoNumbersMaximumXor.java:// 0 <= nums[i] <= 2^31 - 1
class045/Code02_TwoNumbersMaximumXor.java:// 测试链接 : https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/
class045/Code03_WordSearchII.java:// 在二维字符数组中搜索可能的单词
class045/Code03_WordSearchII.java:// 给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words
class045/Code03_WordSearchII.java:// 返回所有二维网格上的单词。单词必须按照字母顺序，通过 相邻的单元格 内的字母构成
class045/Code03_WordSearchII.java:// 其中“相邻”单元格是那些水平相邻或垂直相邻的单元格
class045/Code03_WordSearchII.java:// 同一个单元格内的字母在一个单词中不允许被重复使用
class045/Code03_WordSearchII.java:// 1 <= m, n <= 12
class045/Code03_WordSearchII.java:// 1 <= words.length <= 3 * 10^4
class045/Code03_WordSearchII.java:// 1 <= words[i].length <= 10
class045/Code03_WordSearchII.java:// 测试链接 : https://leetcode.cn/problems/word-search-ii/
算法讲解046【必备】构建前缀信息的技巧-解决子数组相关问题
class046/Code01_PrefixSumArray.java:// 利用前缀和快速得到区域累加和
class046/Code01_PrefixSumArray.java:// 测试链接 : https://leetcode.cn/problems/range-sum-query-immutable/
class046/Code02_LongestSubarraySumEqualsAim.java:// 返回无序数组中累加和为给定值的最长子数组长度
class046/Code02_LongestSubarraySumEqualsAim.java:// 给定一个无序数组arr, 其中元素可正、可负、可0
class046/Code02_LongestSubarraySumEqualsAim.java:// 给定一个整数aim
class046/Code02_LongestSubarraySumEqualsAim.java:// 求arr所有子数组中累加和为aim的最长子数组长度
class046/Code02_LongestSubarraySumEqualsAim.java:// 测试链接 : https://www.nowcoder.com/practice/36fb0fd3c656480c92b569258a1223d5
class046/Code02_LongestSubarraySumEqualsAim.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class046/Code02_LongestSubarraySumEqualsAim.java:// 这是输入输出处理效率很高的写法
class046/Code02_LongestSubarraySumEqualsAim.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class046/Code03_NumberOfSubarraySumEqualsAim.java:// 返回无序数组中累加和为给定值的子数组个数
class046/Code03_NumberOfSubarraySumEqualsAim.java:// 测试链接 : https://leetcode.cn/problems/subarray-sum-equals-k/
class046/Code04_PositivesEqualsNegtivesLongestSubarray.java:// 返回无序数组中正数和负数个数相等的最长子数组长度
class046/Code04_PositivesEqualsNegtivesLongestSubarray.java:// 给定一个无序数组arr，其中元素可正、可负、可0
class046/Code04_PositivesEqualsNegtivesLongestSubarray.java:// 求arr所有子数组中正数与负数个数相等的最长子数组的长度
class046/Code04_PositivesEqualsNegtivesLongestSubarray.java:// 测试链接 : https://www.nowcoder.com/practice/545544c060804eceaed0bb84fcd992fb
class046/Code04_PositivesEqualsNegtivesLongestSubarray.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class046/Code04_PositivesEqualsNegtivesLongestSubarray.java:// 这是输入输出处理效率很高的写法
class046/Code04_PositivesEqualsNegtivesLongestSubarray.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class046/Code05_LongestWellPerformingInterval.java:// 表现良好的最长时间段
class046/Code05_LongestWellPerformingInterval.java:// 给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数
class046/Code05_LongestWellPerformingInterval.java:// 我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是 劳累的一天
class046/Code05_LongestWellPerformingInterval.java:// 所谓 表现良好的时间段 ，意味在这段时间内，「劳累的天数」是严格 大于 不劳累的天数
class046/Code05_LongestWellPerformingInterval.java:// 请你返回 表现良好时间段 的最大长度
class046/Code05_LongestWellPerformingInterval.java:// 测试链接 : https://leetcode.cn/problems/longest-well-performing-interval/
class046/Code06_MakeSumDivisibleByP.java:// 使数组和能被P整除
class046/Code06_MakeSumDivisibleByP.java:// 给你一个正整数数组 nums，请你移除 最短 子数组（可以为 空）
class046/Code06_MakeSumDivisibleByP.java:// 使得剩余元素的 和 能被 p 整除。 不允许 将整个数组都移除。
class046/Code06_MakeSumDivisibleByP.java:// 请你返回你需要移除的最短子数组的长度，如果无法满足题目要求，返回 -1 。
class046/Code06_MakeSumDivisibleByP.java:// 子数组 定义为原数组中连续的一组元素。
class046/Code06_MakeSumDivisibleByP.java:// 测试链接 : https://leetcode.cn/problems/make-sum-divisible-by-p/
class046/Code07_EvenCountsLongestSubarray.java:// 每个元音包含偶数次的最长子字符串
class046/Code07_EvenCountsLongestSubarray.java:// 给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度
class046/Code07_EvenCountsLongestSubarray.java:// 每个元音字母，即 'a'，'e'，'i'，'o'，'u'
class046/Code07_EvenCountsLongestSubarray.java:// 在子字符串中都恰好出现了偶数次。
class046/Code07_EvenCountsLongestSubarray.java:// 测试链接 : https://leetcode.cn/problems/find-the-longest-substring-containing-vowels-in-even-counts/
算法讲解047【必备】一维差分与等差数列差分
class047/Code01_CorporateFlightBookings.java:// 航班预订统计
class047/Code01_CorporateFlightBookings.java:// 这里有 n 个航班，它们分别从 1 到 n 进行编号。
class047/Code01_CorporateFlightBookings.java:// 有一份航班预订表 bookings ，
class047/Code01_CorporateFlightBookings.java:// 表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi]
class047/Code01_CorporateFlightBookings.java:// 意味着在从 firsti 到 lasti 
class047/Code01_CorporateFlightBookings.java://（包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。
class047/Code01_CorporateFlightBookings.java:// 请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。
class047/Code01_CorporateFlightBookings.java:// 测试链接 : https://leetcode.cn/problems/corporate-flight-bookings/
class047/Code02_ArithmeticSequenceDifference.java:// 一开始1~n范围上的数字都是0，一共有m个操作，每次操作为(l,r,s,e,d)
class047/Code02_ArithmeticSequenceDifference.java:// 表示在l~r范围上依次加上首项为s、末项为e、公差为d的数列
class047/Code02_ArithmeticSequenceDifference.java:// m个操作做完之后，统计1~n范围上所有数字的最大值和异或和
class047/Code02_ArithmeticSequenceDifference.java:// 测试链接 : https://www.luogu.com.cn/problem/P4231
class047/Code02_ArithmeticSequenceDifference.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class047/Code02_ArithmeticSequenceDifference.java:// 这是输入输出处理效率很高的写法
class047/Code02_ArithmeticSequenceDifference.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class047/Code03_WaterHeight.java:// 一群人落水后求每个位置的水位高度
class047/Code03_WaterHeight.java:// 问题描述比较复杂，见测试链接
class047/Code03_WaterHeight.java:// 测试链接 : https://www.luogu.com.cn/problem/P5026
class047/Code03_WaterHeight.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class047/Code03_WaterHeight.java:// 这是输入输出处理效率很高的写法
class047/Code03_WaterHeight.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
算法讲解048【必备】二维前缀和、二维差分、离散化技巧
class048/Code01_PrefixSumMatrix.java:// 利用二维前缀和信息迅速得到二维区域和
class048/Code01_PrefixSumMatrix.java:// 测试链接 : https://leetcode.cn/problems/range-sum-query-2d-immutable/
class048/Code02_LargestOneBorderedSquare.java:// 边框为1的最大正方形
class048/Code02_LargestOneBorderedSquare.java:// 给你一个由若干 0 和 1 组成的二维网格 grid
class048/Code02_LargestOneBorderedSquare.java:// 请你找出边界全部由 1 组成的最大 正方形 子网格
class048/Code02_LargestOneBorderedSquare.java:// 并返回该子网格中的元素数量。如果不存在，则返回 0。
class048/Code02_LargestOneBorderedSquare.java:// 测试链接 : https://leetcode.cn/problems/largest-1-bordered-square/
class048/Code03_DiffMatrixLuogu.java:// 二维差分模版(洛谷)
class048/Code03_DiffMatrixLuogu.java:// 测试链接 : https://www.luogu.com.cn/problem/P3397
class048/Code03_DiffMatrixLuogu.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class048/Code03_DiffMatrixLuogu.java:// 这是输入输出处理效率很高的写法
class048/Code03_DiffMatrixLuogu.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class048/Code03_DiffMatrixNowcoder.java:// 二维差分模版(牛客)
class048/Code03_DiffMatrixNowcoder.java:// 测试链接 : https://www.nowcoder.com/practice/50e1a93989df42efb0b1dec386fb4ccc
class048/Code03_DiffMatrixNowcoder.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class048/Code03_DiffMatrixNowcoder.java:// 这是输入输出处理效率很高的写法
class048/Code03_DiffMatrixNowcoder.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class048/Code04_StampingTheGrid.java:// 用邮票贴满网格图
class048/Code04_StampingTheGrid.java:// 给你一个 m * n 的二进制矩阵 grid
class048/Code04_StampingTheGrid.java:// 每个格子要么为 0 （空）要么为 1 （被占据）
class048/Code04_StampingTheGrid.java:// 给你邮票的尺寸为 stampHeight * stampWidth
class048/Code04_StampingTheGrid.java:// 我们想将邮票贴进二进制矩阵中，且满足以下 限制 和 要求 ：
class048/Code04_StampingTheGrid.java:// 覆盖所有空格子，不覆盖任何被占据的格子
class048/Code04_StampingTheGrid.java:// 可以放入任意数目的邮票，邮票可以相互有重叠部分
class048/Code04_StampingTheGrid.java:// 邮票不允许旋转，邮票必须完全在矩阵内
class048/Code04_StampingTheGrid.java:// 如果在满足上述要求的前提下，可以放入邮票，请返回 true ，否则返回 false
class048/Code04_StampingTheGrid.java:// 测试链接 : https://leetcode.cn/problems/stamping-the-grid/
class048/Code05_StrongestForceField.java:// 最强祝福力场
class048/Code05_StrongestForceField.java:// 小扣在探索丛林的过程中，无意间发现了传说中"落寞的黄金之都"
class048/Code05_StrongestForceField.java:// 而在这片建筑废墟的地带中，小扣使用探测仪监测到了存在某种带有「祝福」效果的力场
class048/Code05_StrongestForceField.java:// 经过不断的勘测记录，小扣将所有力场的分布都记录了下来
class048/Code05_StrongestForceField.java:// forceField[i] = [x,y,side] 
class048/Code05_StrongestForceField.java:// 表示第 i 片力场将覆盖以坐标 (x,y) 为中心，边长为 side 的正方形区域。
class048/Code05_StrongestForceField.java:// 若任意一点的 力场强度 等于覆盖该点的力场数量
class048/Code05_StrongestForceField.java:// 请求出在这片地带中 力场强度 最强处的 力场强度
class048/Code05_StrongestForceField.java:// 注意：力场范围的边缘同样被力场覆盖。
class048/Code05_StrongestForceField.java:// 测试链接 : https://leetcode.cn/problems/xepqZ5/
算法讲解049【必备】滑动窗口技巧与相关题目
class049/Code01_MinimumSizeSubarraySum.java:// 累加和大于等于target的最短子数组长度
class049/Code01_MinimumSizeSubarraySum.java:// 给定一个含有 n 个正整数的数组和一个正整数 target
class049/Code01_MinimumSizeSubarraySum.java:// 找到累加和 >= target 的长度最小的子数组并返回其长度
class049/Code01_MinimumSizeSubarraySum.java:// 如果不存在符合条件的子数组返回0
class049/Code01_MinimumSizeSubarraySum.java:// 测试链接 : https://leetcode.cn/problems/minimum-size-subarray-sum/
class049/Code02_LongestSubstringWithoutRepeatingCharacters.java:// 无重复字符的最长子串
class049/Code02_LongestSubstringWithoutRepeatingCharacters.java:// 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。
class049/Code02_LongestSubstringWithoutRepeatingCharacters.java:// 测试链接 : https://leetcode.cn/problems/longest-substring-without-repeating-characters/
class049/Code03_MinimumWindowSubstring.java:// 最小覆盖子串
class049/Code03_MinimumWindowSubstring.java:// 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串
class049/Code03_MinimumWindowSubstring.java:// 如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。
class049/Code03_MinimumWindowSubstring.java:// 测试链接 : https://leetcode.cn/problems/minimum-window-substring/
class049/Code04_GasStation.java:// 加油站
class049/Code04_GasStation.java:// 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。
class049/Code04_GasStation.java:// 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升
class049/Code04_GasStation.java:// 你从其中的一个加油站出发，开始时油箱为空。
class049/Code04_GasStation.java:// 给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周
class049/Code04_GasStation.java:// 则返回出发时加油站的编号，否则返回 -1
class049/Code04_GasStation.java:// 如果存在解，则 保证 它是 唯一 的。
class049/Code04_GasStation.java:// 测试链接 : https://leetcode.cn/problems/gas-station/
class049/Code05_ReplaceTheSubstringForBalancedString.java:// 替换子串得到平衡字符串
class049/Code05_ReplaceTheSubstringForBalancedString.java:// 有一个只含有 'Q', 'W', 'E', 'R' 四种字符，且长度为 n 的字符串。
class049/Code05_ReplaceTheSubstringForBalancedString.java:// 假如在该字符串中，这四个字符都恰好出现 n/4 次，那么它就是一个「平衡字符串」。
class049/Code05_ReplaceTheSubstringForBalancedString.java:// 给你一个这样的字符串 s，请通过「替换一个子串」的方式，使原字符串 s 变成一个「平衡字符串」。
class049/Code05_ReplaceTheSubstringForBalancedString.java:// 你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。
class049/Code05_ReplaceTheSubstringForBalancedString.java:// 请返回待替换子串的最小可能长度。
class049/Code05_ReplaceTheSubstringForBalancedString.java:// 如果原字符串自身就是一个平衡字符串，则返回 0。
class049/Code05_ReplaceTheSubstringForBalancedString.java:// 测试链接 : https://leetcode.cn/problems/replace-the-substring-for-balanced-string/
class049/Code06_SubarraysWithKDifferentIntegers.java:// K个不同整数的子数组
class049/Code06_SubarraysWithKDifferentIntegers.java:// 给定一个正整数数组 nums和一个整数 k，返回 nums 中 「好子数组」 的数目。
class049/Code06_SubarraysWithKDifferentIntegers.java:// 如果 nums 的某个子数组中不同整数的个数恰好为 k
class049/Code06_SubarraysWithKDifferentIntegers.java:// 则称 nums 的这个连续、不一定不同的子数组为 「好子数组 」。
class049/Code06_SubarraysWithKDifferentIntegers.java:// 例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。
class049/Code06_SubarraysWithKDifferentIntegers.java:// 子数组 是数组的 连续 部分。
class049/Code06_SubarraysWithKDifferentIntegers.java:// 测试链接 : https://leetcode.cn/problems/subarrays-with-k-different-integers/
class049/Code07_LongestSubstringWithAtLeastKRepeating.java:// 至少有K个重复字符的最长子串
class049/Code07_LongestSubstringWithAtLeastKRepeating.java:// 给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串
class049/Code07_LongestSubstringWithAtLeastKRepeating.java:// 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度
class049/Code07_LongestSubstringWithAtLeastKRepeating.java:// 如果不存在这样的子字符串，则返回 0。
class049/Code07_LongestSubstringWithAtLeastKRepeating.java:// 测试链接 : https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/
算法讲解050【必备】双指针技巧与相关题目
class050/Code01_SortArrayByParityII.java:// 按奇偶排序数组II
class050/Code01_SortArrayByParityII.java:// 给定一个非负整数数组 nums。nums 中一半整数是奇数 ，一半整数是偶数
class050/Code01_SortArrayByParityII.java:// 对数组进行排序，以便当 nums[i] 为奇数时，i也是奇数
class050/Code01_SortArrayByParityII.java:// 当 nums[i] 为偶数时， i 也是 偶数
class050/Code01_SortArrayByParityII.java:// 你可以返回 任何满足上述条件的数组作为答案
class050/Code01_SortArrayByParityII.java:// 测试链接 : https://leetcode.cn/problems/sort-array-by-parity-ii/
class050/Code02_FindTheDuplicateNumber.java:// 寻找重复数
class050/Code02_FindTheDuplicateNumber.java:// 给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n）
class050/Code02_FindTheDuplicateNumber.java:// 可知至少存在一个重复的整数。
class050/Code02_FindTheDuplicateNumber.java:// 假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。
class050/Code02_FindTheDuplicateNumber.java:// 你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。
class050/Code02_FindTheDuplicateNumber.java:// 测试链接 : https://leetcode.cn/problems/find-the-duplicate-number/
class050/Code03_TrappingRainWater.java:// 接雨水
class050/Code03_TrappingRainWater.java:// 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水
class050/Code03_TrappingRainWater.java:// 测试链接 : https://leetcode.cn/problems/trapping-rain-water/
class050/Code04_BoatsToSavePeople.java:// 救生艇
class050/Code04_BoatsToSavePeople.java:// 给定数组 people
class050/Code04_BoatsToSavePeople.java:// people[i]表示第 i 个人的体重 ，船的数量不限，每艘船可以承载的最大重量为 limit
class050/Code04_BoatsToSavePeople.java:// 每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit
class050/Code04_BoatsToSavePeople.java:// 返回 承载所有人所需的最小船数
class050/Code04_BoatsToSavePeople.java:// 测试链接 : https://leetcode.cn/problems/boats-to-save-people/
class050/Code05_ContainerWithMostWater.java:// 盛最多水的容器
class050/Code05_ContainerWithMostWater.java:// 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。
class050/Code05_ContainerWithMostWater.java:// 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水
class050/Code05_ContainerWithMostWater.java:// 返回容器可以储存的最大水量
class050/Code05_ContainerWithMostWater.java:// 说明：你不能倾斜容器
class050/Code05_ContainerWithMostWater.java:// 测试链接 : https://leetcode.cn/problems/container-with-most-water/
class050/Code06_Heaters.java:// 供暖器
class050/Code06_Heaters.java:// 冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。
class050/Code06_Heaters.java:// 在加热器的加热半径范围内的每个房屋都可以获得供暖。
class050/Code06_Heaters.java:// 现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters 的位置
class050/Code06_Heaters.java:// 请你找出并返回可以覆盖所有房屋的最小加热半径。
class050/Code06_Heaters.java:// 说明：所有供暖器都遵循你的半径标准，加热的半径也一样。
class050/Code06_Heaters.java:// 测试链接 : https://leetcode.cn/problems/heaters/
class050/Code07_FirstMissingPositive.java:// 缺失的第一个正数
class050/Code07_FirstMissingPositive.java:// 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。
class050/Code07_FirstMissingPositive.java:// 请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。
class050/Code07_FirstMissingPositive.java:// 测试链接 : https://leetcode.cn/problems/first-missing-positive/
算法讲解051【必备】二分答案法与相关题目
class051/Code01_KokoEatingBananas.java:// 爱吃香蕉的珂珂
class051/Code01_KokoEatingBananas.java:// 珂珂喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i] 根香蕉
class051/Code01_KokoEatingBananas.java:// 警卫已经离开了，将在 h 小时后回来。
class051/Code01_KokoEatingBananas.java:// 珂珂可以决定她吃香蕉的速度 k （单位：根/小时)
class051/Code01_KokoEatingBananas.java:// 每个小时，她将会选择一堆香蕉，从中吃掉 k 根
class051/Code01_KokoEatingBananas.java:// 如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉
class051/Code01_KokoEatingBananas.java:// 珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。
class051/Code01_KokoEatingBananas.java:// 返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）
class051/Code01_KokoEatingBananas.java:// 测试链接 : https://leetcode.cn/problems/koko-eating-bananas/
class051/Code02_SplitArrayLargestSum.java:// 分割数组的最大值(画匠问题)
class051/Code02_SplitArrayLargestSum.java:// 给定一个非负整数数组 nums 和一个整数 m
class051/Code02_SplitArrayLargestSum.java:// 你需要将这个数组分成 m 个非空的连续子数组。
class051/Code02_SplitArrayLargestSum.java:// 设计一个算法使得这 m 个子数组各自和的最大值最小。
class051/Code02_SplitArrayLargestSum.java:// 测试链接 : https://leetcode.cn/problems/split-array-largest-sum/
class051/Code03_RobotPassThroughBuilding.java:// 机器人跳跃问题
class051/Code03_RobotPassThroughBuilding.java:// 机器人正在玩一个古老的基于DOS的游戏
class051/Code03_RobotPassThroughBuilding.java:// 游戏中有N+1座建筑，从0到N编号，从左到右排列
class051/Code03_RobotPassThroughBuilding.java:// 编号为0的建筑高度为0个单位，编号为i的建筑的高度为H(i)个单位
class051/Code03_RobotPassThroughBuilding.java:// 起初机器人在编号为0的建筑处
class051/Code03_RobotPassThroughBuilding.java:// 每一步，它跳到下一个（右边）建筑。假设机器人在第k个建筑，且它现在的能量值是E
class051/Code03_RobotPassThroughBuilding.java:// 下一步它将跳到第个k+1建筑
class051/Code03_RobotPassThroughBuilding.java:// 它将会得到或者失去正比于与H(k+1)与E之差的能量
class051/Code03_RobotPassThroughBuilding.java:// 如果 H(k+1) > E 那么机器人就失去H(k+1)-E的能量值，否则它将得到E-H(k+1)的能量值
class051/Code03_RobotPassThroughBuilding.java:// 游戏目标是到达第个N建筑，在这个过程中，能量值不能为负数个单位
class051/Code03_RobotPassThroughBuilding.java:// 现在的问题是机器人以多少能量值开始游戏，才可以保证成功完成游戏
class051/Code03_RobotPassThroughBuilding.java:// 测试链接 : https://www.nowcoder.com/practice/7037a3d57bbd4336856b8e16a9cafd71
class051/Code03_RobotPassThroughBuilding.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class051/Code03_RobotPassThroughBuilding.java:// 这是输入输出处理效率很高的写法
class051/Code03_RobotPassThroughBuilding.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class051/Code04_FindKthSmallestPairDistance.java:// 找出第K小的数对距离
class051/Code04_FindKthSmallestPairDistance.java:// 数对 (a,b) 由整数 a 和 b 组成，其数对距离定义为 a 和 b 的绝对差值。
class051/Code04_FindKthSmallestPairDistance.java:// 给你一个整数数组 nums 和一个整数 k
class051/Code04_FindKthSmallestPairDistance.java:// 数对由 nums[i] 和 nums[j] 组成且满足 0 <= i < j < nums.length
class051/Code04_FindKthSmallestPairDistance.java:// 返回 所有数对距离中 第 k 小的数对距离。
class051/Code04_FindKthSmallestPairDistance.java:// 测试链接 : https://leetcode.cn/problems/find-k-th-smallest-pair-distance/
class051/Code05_MaximumRunningTimeOfNComputers.java:// 同时运行N台电脑的最长时间
class051/Code05_MaximumRunningTimeOfNComputers.java:// 你有 n 台电脑。给你整数 n 和一个下标从 0 开始的整数数组 batteries
class051/Code05_MaximumRunningTimeOfNComputers.java:// 其中第 i 个电池可以让一台电脑 运行 batteries[i] 分钟
class051/Code05_MaximumRunningTimeOfNComputers.java:// 你想使用这些电池让 全部 n 台电脑 同时 运行。
class051/Code05_MaximumRunningTimeOfNComputers.java:// 一开始，你可以给每台电脑连接 至多一个电池
class051/Code05_MaximumRunningTimeOfNComputers.java:// 然后在任意整数时刻，你都可以将一台电脑与它的电池断开连接，并连接另一个电池，你可以进行这个操作 任意次
class051/Code05_MaximumRunningTimeOfNComputers.java:// 新连接的电池可以是一个全新的电池，也可以是别的电脑用过的电池
class051/Code05_MaximumRunningTimeOfNComputers.java:// 断开连接和连接新的电池不会花费任何时间。
class051/Code05_MaximumRunningTimeOfNComputers.java:// 注意，你不能给电池充电。
class051/Code05_MaximumRunningTimeOfNComputers.java:// 请你返回你可以让 n 台电脑同时运行的 最长 分钟数。
class051/Code05_MaximumRunningTimeOfNComputers.java:// 测试链接 : https://leetcode.cn/problems/maximum-running-time-of-n-computers/
class051/Code06_WaitingTime.java:// 计算等位时间
class051/Code06_WaitingTime.java:// 给定一个数组arr长度为n，表示n个服务员，每服务一个人的时间
class051/Code06_WaitingTime.java:// 给定一个正数m，表示有m个人等位，如果你是刚来的人，请问你需要等多久？
class051/Code06_WaitingTime.java:// 假设m远远大于n，比如n <= 10^3, m <= 10^9，该怎么做是最优解？
class051/Code06_WaitingTime.java:// 谷歌的面试，这个题连考了2个月
class051/Code06_WaitingTime.java:// 找不到测试链接，所以用对数器验证
class051/Code07_CutOrPoison.java:// 刀砍毒杀怪兽问题
class051/Code07_CutOrPoison.java:// 怪兽的初始血量是一个整数hp，给出每一回合刀砍和毒杀的数值cuts和poisons
class051/Code07_CutOrPoison.java:// 第i回合如果用刀砍，怪兽在这回合会直接损失cuts[i]的血，不再有后续效果
class051/Code07_CutOrPoison.java:// 第i回合如果用毒杀，怪兽在这回合不会损失血量，但是之后每回合都损失poisons[i]的血量
class051/Code07_CutOrPoison.java:// 并且你选择的所有毒杀效果，在之后的回合都会叠加
class051/Code07_CutOrPoison.java:// 两个数组cuts、poisons，长度都是n，代表你一共可以进行n回合
class051/Code07_CutOrPoison.java:// 每一回合你只能选择刀砍或者毒杀中的一个动作
class051/Code07_CutOrPoison.java:// 如果你在n个回合内没有直接杀死怪兽，意味着你已经无法有新的行动了
class051/Code07_CutOrPoison.java:// 但是怪兽如果有中毒效果的话，那么怪兽依然会在血量耗尽的那回合死掉
class051/Code07_CutOrPoison.java:// 返回至少多少回合，怪兽会死掉
class051/Code07_CutOrPoison.java:// 数据范围 : 
class051/Code07_CutOrPoison.java:// 1 <= n <= 10^5
class051/Code07_CutOrPoison.java:// 1 <= hp <= 10^9
class051/Code07_CutOrPoison.java:// 1 <= cuts[i]、poisons[i] <= 10^9
class051/Code07_CutOrPoison.java:// 本题来自真实大厂笔试，找不到测试链接，所以用对数器验证
算法讲解052【必备】单调栈-上
class052/Code01_LeftRightLess.java:// 单调栈求每个位置左右两侧，离当前位置最近、且值严格小于的位置
class052/Code01_LeftRightLess.java:// 给定一个可能含有重复值的数组 arr
class052/Code01_LeftRightLess.java:// 找到每一个 i 位置左边和右边离 i 位置最近且值比 arr[i] 小的位置
class052/Code01_LeftRightLess.java:// 返回所有位置相应的信息。
class052/Code01_LeftRightLess.java:// 输入描述：
class052/Code01_LeftRightLess.java:// 第一行输入一个数字 n，表示数组 arr 的长度。
class052/Code01_LeftRightLess.java:// 以下一行输入 n 个数字，表示数组的值
class052/Code01_LeftRightLess.java:// 输出描述：
class052/Code01_LeftRightLess.java:// 输出n行，每行两个数字 L 和 R，如果不存在，则值为 -1，下标从 0 开始。
class052/Code01_LeftRightLess.java:// 测试链接 : https://www.nowcoder.com/practice/2a2c00e7a88a498693568cef63a4b7bb
class052/Code01_LeftRightLess.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class052/Code01_LeftRightLess.java:// 这是输入输出处理效率很高的写法
class052/Code01_LeftRightLess.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class052/Code02_DailyTemperatures.java:// 每日温度
class052/Code02_DailyTemperatures.java:// 给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer
class052/Code02_DailyTemperatures.java:// 其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后
class052/Code02_DailyTemperatures.java:// 如果气温在这之后都不会升高，请在该位置用 0 来代替。
class052/Code02_DailyTemperatures.java:// 测试链接 : https://leetcode.cn/problems/daily-temperatures/
class052/Code03_SumOfSubarrayMinimums.java:// 子数组的最小值之和
class052/Code03_SumOfSubarrayMinimums.java:// 给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。
class052/Code03_SumOfSubarrayMinimums.java:// 由于答案可能很大，因此 返回答案模 10^9 + 7
class052/Code03_SumOfSubarrayMinimums.java:// 测试链接 : https://leetcode.cn/problems/sum-of-subarray-minimums/
class052/Code04_LargestRectangleInHistogram.java:// 柱状图中最大的矩形
class052/Code04_LargestRectangleInHistogram.java:// 给定 n 个非负整数，用来表示柱状图中各个柱子的高度
class052/Code04_LargestRectangleInHistogram.java:// 每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积
class052/Code04_LargestRectangleInHistogram.java:// 测试链接：https://leetcode.cn/problems/largest-rectangle-in-histogram
class052/Code05_MaximalRectangle.java:// 最大矩形
class052/Code05_MaximalRectangle.java:// 给定一个仅包含 0 和 1 、大小为 rows * cols 的二维二进制矩阵
class052/Code05_MaximalRectangle.java:// 找出只包含 1 的最大矩形，并返回其面积
class052/Code05_MaximalRectangle.java:// 测试链接：https://leetcode.cn/problems/maximal-rectangle/
class052/Code06_MonotonicStackLuogu.java:// 课上没讲的代码，单调栈在洛谷上的测试，原理是一样的
class052/Code06_MonotonicStackLuogu.java:// 洛谷上这道题对java特别不友好，不这么写通过不了，注意看注释，非常极限
class052/Code06_MonotonicStackLuogu.java:// 建议看看就好，现在的笔试和比赛时，不会这么极限的
class052/Code06_MonotonicStackLuogu.java:// 给定一个长度为n的数组，打印每个位置的右侧，大于该位置数字的最近位置
class052/Code06_MonotonicStackLuogu.java:// 测试链接 : https://www.luogu.com.cn/problem/P5788
class052/Code06_MonotonicStackLuogu.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
算法讲解053【必备】单调栈-下
class053/Code01_MaximumWidthRamp.java:// 最大宽度坡
class053/Code01_MaximumWidthRamp.java:// 给定一个整数数组 A，坡是元组 (i, j)，其中  i < j 且 A[i] <= A[j]
class053/Code01_MaximumWidthRamp.java:// 这样的坡的宽度为 j - i，找出 A 中的坡的最大宽度，如果不存在，返回 0
class053/Code01_MaximumWidthRamp.java:// 测试链接 : https://leetcode.cn/problems/maximum-width-ramp/
class053/Code02_RemoveDuplicateLetters.java:// 去除重复字母保证剩余字符串的字典序最小
class053/Code02_RemoveDuplicateLetters.java:// 给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次
class053/Code02_RemoveDuplicateLetters.java:// 需保证 返回结果的字典序最小
class053/Code02_RemoveDuplicateLetters.java:// 要求不能打乱其他字符的相对位置
class053/Code02_RemoveDuplicateLetters.java:// 测试链接 : https://leetcode.cn/problems/remove-duplicate-letters/
class053/Code03_BigFishEatSmallFish.java:// 大鱼吃小鱼问题
class053/Code03_BigFishEatSmallFish.java:// 给定一个数组arr，每个值代表鱼的体重
class053/Code03_BigFishEatSmallFish.java:// 每一轮每条鱼都会吃掉右边离自己最近比自己体重小的鱼，每条鱼向右找只吃一条
class053/Code03_BigFishEatSmallFish.java:// 但是吃鱼这件事是同时发生的，也就是同一轮在A吃掉B的同时，A也可能被别的鱼吃掉
class053/Code03_BigFishEatSmallFish.java:// 如果有多条鱼在当前轮找到的是同一条小鱼，那么在这一轮，这条小鱼同时被这些大鱼吃
class053/Code03_BigFishEatSmallFish.java:// 请问多少轮后，鱼的数量就固定了
class053/Code03_BigFishEatSmallFish.java:// 比如 : 8 3 1 5 6 7 2 4
class053/Code03_BigFishEatSmallFish.java:// 第一轮 : 8吃3；3吃1；5、6、7吃2；4没有被吃。数组剩下 8 5 6 7 4
class053/Code03_BigFishEatSmallFish.java:// 第二轮 : 8吃5；5、6、7吃4。数组剩下 8 6 7
class053/Code03_BigFishEatSmallFish.java:// 第三轮 : 8吃6。数组剩下 8 7
class053/Code03_BigFishEatSmallFish.java:// 第四轮 : 8吃7。数组剩下 8。
class053/Code03_BigFishEatSmallFish.java:// 过程结束，返回4
class053/Code03_BigFishEatSmallFish.java:// 测试链接 : https://www.nowcoder.com/practice/77199defc4b74b24b8ebf6244e1793de
class053/Code03_BigFishEatSmallFish.java:// 测试链接 : https://leetcode.cn/problems/steps-to-make-array-non-decreasing/
class053/Code04_CountSubmatricesWithAllOnes.java:// 统计全1子矩形的数量
class053/Code04_CountSubmatricesWithAllOnes.java:// 给你一个 m * n 的矩阵 mat，其中只有0和1两种值
class053/Code04_CountSubmatricesWithAllOnes.java:// 请你返回有多少个 子矩形 的元素全部都是1
class053/Code04_CountSubmatricesWithAllOnes.java:// 测试链接 : https://leetcode.cn/problems/count-submatrices-with-all-ones/
算法讲解054【必备】单调队列-上
class054/Code01_SlidingWindowMaximum.java:// 滑动窗口最大值（单调队列经典用法模版）
class054/Code01_SlidingWindowMaximum.java:// 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧
class054/Code01_SlidingWindowMaximum.java:// 你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
class054/Code01_SlidingWindowMaximum.java:// 返回 滑动窗口中的最大值 。
class054/Code01_SlidingWindowMaximum.java:// 测试链接 : https://leetcode.cn/problems/sliding-window-maximum/
class054/Code02_LongestSubarrayAbsoluteLimit.java:// 绝对差不超过限制的最长连续子数组
class054/Code02_LongestSubarrayAbsoluteLimit.java:// 给你一个整数数组 nums ，和一个表示限制的整数 limit
class054/Code02_LongestSubarrayAbsoluteLimit.java:// 请你返回最长连续子数组的长度
class054/Code02_LongestSubarrayAbsoluteLimit.java:// 该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit
class054/Code02_LongestSubarrayAbsoluteLimit.java:// 如果不存在满足条件的子数组，则返回 0
class054/Code02_LongestSubarrayAbsoluteLimit.java:// 测试链接 : https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/
class054/Code03_FallingWaterSmallestFlowerPot.java:// 接取落水的最小花盆
class054/Code03_FallingWaterSmallestFlowerPot.java:// 老板需要你帮忙浇花。给出 N 滴水的坐标，y 表示水滴的高度，x 表示它下落到 x 轴的位置
class054/Code03_FallingWaterSmallestFlowerPot.java:// 每滴水以每秒1个单位长度的速度下落。你需要把花盆放在 x 轴上的某个位置
class054/Code03_FallingWaterSmallestFlowerPot.java:// 使得从被花盆接着的第 1 滴水开始，到被花盆接着的最后 1 滴水结束，之间的时间差至少为 D
class054/Code03_FallingWaterSmallestFlowerPot.java:// 我们认为，只要水滴落到 x 轴上，与花盆的边沿对齐，就认为被接住
class054/Code03_FallingWaterSmallestFlowerPot.java:// 给出 N 滴水的坐标和 D 的大小，请算出最小的花盆的宽度 W
class054/Code03_FallingWaterSmallestFlowerPot.java:// 测试链接 : https://www.luogu.com.cn/problem/P2698
class054/Code03_FallingWaterSmallestFlowerPot.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class054/Code03_FallingWaterSmallestFlowerPot.java:// 这是输入输出处理效率很高的写法
class054/Code03_FallingWaterSmallestFlowerPot.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
算法讲解055【必备】单调队列-下
class055/Code01_ShortestSubarrayWithSumAtLeastK.java:// 和至少为K的最短子数组
class055/Code01_ShortestSubarrayWithSumAtLeastK.java:// 给定一个数组arr，其中的值有可能正、负、0
class055/Code01_ShortestSubarrayWithSumAtLeastK.java:// 给定一个正数k
class055/Code01_ShortestSubarrayWithSumAtLeastK.java:// 返回累加和>=k的所有子数组中，最短的子数组长度
class055/Code01_ShortestSubarrayWithSumAtLeastK.java:// 测试链接 : https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/
class055/Code02_MaxValueOfEquation.java:// 满足不等式的最大值
class055/Code02_MaxValueOfEquation.java:// 给你一个数组 points 和一个整数 k
class055/Code02_MaxValueOfEquation.java:// 数组中每个元素都表示二维平面上的点的坐标，并按照横坐标 x 的值从小到大排序
class055/Code02_MaxValueOfEquation.java:// 也就是说 points[i] = [xi, yi]
class055/Code02_MaxValueOfEquation.java:// 并且在 1 <= i < j <= points.length 的前提下，xi < xj 总成立
class055/Code02_MaxValueOfEquation.java:// 请你找出 yi + yj + |xi - xj| 的 最大值，
class055/Code02_MaxValueOfEquation.java:// 其中 |xi - xj| <= k 且 1 <= i < j <= points.length
class055/Code02_MaxValueOfEquation.java:// 题目测试数据保证至少存在一对能够满足 |xi - xj| <= k 的点。
class055/Code02_MaxValueOfEquation.java:// 测试链接 : https://leetcode.cn/problems/max-value-of-equation/
class055/Code03_MaximumNumberOfTasksYouCanAssign.java:// 你可以安排的最多任务数目
class055/Code03_MaximumNumberOfTasksYouCanAssign.java:// 给你 n 个任务和 m 个工人。每个任务需要一定的力量值才能完成
class055/Code03_MaximumNumberOfTasksYouCanAssign.java:// 需要的力量值保存在下标从 0 开始的整数数组 tasks 中，
class055/Code03_MaximumNumberOfTasksYouCanAssign.java:// 第i个任务需要 tasks[i] 的力量才能完成
class055/Code03_MaximumNumberOfTasksYouCanAssign.java:// 每个工人的力量值保存在下标从 0 开始的整数数组workers中，
class055/Code03_MaximumNumberOfTasksYouCanAssign.java:// 第j个工人的力量值为 workers[j]
class055/Code03_MaximumNumberOfTasksYouCanAssign.java:// 每个工人只能完成一个任务，且力量值需要大于等于该任务的力量要求值，即workers[j]>=tasks[i]
class055/Code03_MaximumNumberOfTasksYouCanAssign.java:// 除此以外，你还有 pills 个神奇药丸，可以给 一个工人的力量值 增加 strength
class055/Code03_MaximumNumberOfTasksYouCanAssign.java:// 你可以决定给哪些工人使用药丸，但每个工人 最多 只能使用 一片 药丸
class055/Code03_MaximumNumberOfTasksYouCanAssign.java:// 给你下标从 0 开始的整数数组tasks 和 workers 以及两个整数 pills 和 strength
class055/Code03_MaximumNumberOfTasksYouCanAssign.java:// 请你返回 最多 有多少个任务可以被完成。
class055/Code03_MaximumNumberOfTasksYouCanAssign.java:// 测试链接 : https://leetcode.cn/problems/maximum-number-of-tasks-you-can-assign/
算法讲解056【必备】并查集-上
class056/Code01_UnionFindNowCoder.java:// 并查集模版(牛客)
class056/Code01_UnionFindNowCoder.java:// 路径压缩 + 小挂大
class056/Code01_UnionFindNowCoder.java:// 测试链接 : https://www.nowcoder.com/practice/e7ed657974934a30b2010046536a5372
class056/Code01_UnionFindNowCoder.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class056/Code01_UnionFindNowCoder.java:// 这是输入输出处理效率很高的写法
class056/Code01_UnionFindNowCoder.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class056/Code02_UnionFindLuogu.java:// 并查集模版(洛谷)
class056/Code02_UnionFindLuogu.java:// 本实现用递归函数实现路径压缩，而且省掉了小挂大的优化，一般情况下可以省略
class056/Code02_UnionFindLuogu.java:// 测试链接 : https://www.luogu.com.cn/problem/P3367
class056/Code02_UnionFindLuogu.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class056/Code02_UnionFindLuogu.java:// 这是输入输出处理效率很高的写法
class056/Code02_UnionFindLuogu.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class056/Code03_CouplesHoldingHands.java:// 情侣牵手
class056/Code03_CouplesHoldingHands.java:// n对情侣坐在连续排列的 2n 个座位上，想要牵到对方的手
class056/Code03_CouplesHoldingHands.java:// 人和座位由一个整数数组 row 表示，其中 row[i] 是坐在第 i 个座位上的人的ID
class056/Code03_CouplesHoldingHands.java:// 情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2n-2, 2n-1)
class056/Code03_CouplesHoldingHands.java:// 返回 最少交换座位的次数，以便每对情侣可以并肩坐在一起
class056/Code03_CouplesHoldingHands.java:// 每次交换可选择任意两人，让他们站起来交换座位
class056/Code03_CouplesHoldingHands.java:// 测试链接 : https://leetcode.cn/problems/couples-holding-hands/
class056/Code04_SimilarStringGroups.java:// 相似字符串组
class056/Code04_SimilarStringGroups.java:// 如果交换字符串 X 中的两个不同位置的字母，使得它和字符串 Y 相等
class056/Code04_SimilarStringGroups.java:// 那么称 X 和 Y 两个字符串相似
class056/Code04_SimilarStringGroups.java:// 如果这两个字符串本身是相等的，那它们也是相似的
class056/Code04_SimilarStringGroups.java:// 例如，"tars" 和 "rats" 是相似的 (交换 0 与 2 的位置)；
class056/Code04_SimilarStringGroups.java:// "rats" 和 "arts" 也是相似的，但是 "star" 不与 "tars"，"rats"，或 "arts" 相似
class056/Code04_SimilarStringGroups.java:// 总之，它们通过相似性形成了两个关联组：{"tars", "rats", "arts"} 和 {"star"}
class056/Code04_SimilarStringGroups.java:// 注意，"tars" 和 "arts" 是在同一组中，即使它们并不相似
class056/Code04_SimilarStringGroups.java:// 形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。
class056/Code04_SimilarStringGroups.java:// 给你一个字符串列表 strs列表中的每个字符串都是 strs 中其它所有字符串的一个字母异位词。
class056/Code04_SimilarStringGroups.java:// 返回 strs 中有多少字符串组
class056/Code04_SimilarStringGroups.java:// 测试链接 : https://leetcode.cn/problems/similar-string-groups/
class056/Code05_NumberOfIslands.java:// 岛屿数量
class056/Code05_NumberOfIslands.java:// 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量
class056/Code05_NumberOfIslands.java:// 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成
class056/Code05_NumberOfIslands.java:// 此外，你可以假设该网格的四条边均被水包围
class056/Code05_NumberOfIslands.java:// 测试链接 : https://leetcode.cn/problems/number-of-islands/
算法讲解057【必备】并查集-下
class057/Code01_MostStonesRemovedWithSameRowOrColumn.java:// 移除最多的同行或同列石头
class057/Code01_MostStonesRemovedWithSameRowOrColumn.java:// n 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头
class057/Code01_MostStonesRemovedWithSameRowOrColumn.java:// 如果一块石头的 同行或者同列 上有其他石头存在，那么就可以移除这块石头
class057/Code01_MostStonesRemovedWithSameRowOrColumn.java:// 给你一个长度为 n 的数组 stones ，其中 stones[i] = [xi, yi] 表示第 i 块石头的位置
class057/Code01_MostStonesRemovedWithSameRowOrColumn.java:// 返回 可以移除的石子 的最大数量。
class057/Code01_MostStonesRemovedWithSameRowOrColumn.java:// 测试链接 : https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/
class057/Code02_FindAllPeopleWithSecret.java:// 找出知晓秘密的所有专家
class057/Code02_FindAllPeopleWithSecret.java:// 给你一个整数 n ，表示有 n 个专家从 0 到 n - 1 编号
class057/Code02_FindAllPeopleWithSecret.java:// 另外给你一个下标从 0 开始的二维整数数组 meetings
class057/Code02_FindAllPeopleWithSecret.java:// 其中 meetings[i] = [xi, yi, timei] 表示专家 xi 和专家 yi 在时间 timei 要开一场会
class057/Code02_FindAllPeopleWithSecret.java:// 一个专家可以同时参加 多场会议 。最后，给你一个整数 firstPerson
class057/Code02_FindAllPeopleWithSecret.java:// 专家 0 有一个 秘密 ，最初，他在时间 0 将这个秘密分享给了专家 firstPerson
class057/Code02_FindAllPeopleWithSecret.java:// 接着，这个秘密会在每次有知晓这个秘密的专家参加会议时进行传播
class057/Code02_FindAllPeopleWithSecret.java:// 更正式的表达是，每次会议，如果专家 xi 在时间 timei 时知晓这个秘密
class057/Code02_FindAllPeopleWithSecret.java:// 那么他将会与专家 yi 分享这个秘密，反之亦然。秘密共享是 瞬时发生 的
class057/Code02_FindAllPeopleWithSecret.java:// 也就是说，在同一时间，一个专家不光可以接收到秘密，还能在其他会议上与其他专家分享
class057/Code02_FindAllPeopleWithSecret.java:// 在所有会议都结束之后，返回所有知晓这个秘密的专家列表
class057/Code02_FindAllPeopleWithSecret.java:// 你可以按 任何顺序 返回答案
class057/Code02_FindAllPeopleWithSecret.java:// 链接测试 : https://leetcode.cn/problems/find-all-people-with-secret/
class057/Code03_NumberOfGoodPaths.java:// 好路径的数目
class057/Code03_NumberOfGoodPaths.java:// 给你一棵 n 个节点的树（连通无向无环的图）
class057/Code03_NumberOfGoodPaths.java:// 节点编号从0到n-1，且恰好有n-1条边
class057/Code03_NumberOfGoodPaths.java:// 给你一个长度为 n 下标从 0 开始的整数数组 vals
class057/Code03_NumberOfGoodPaths.java:// 分别表示每个节点的值。同时给你一个二维整数数组 edges
class057/Code03_NumberOfGoodPaths.java:// 其中 edges[i] = [ai, bi] 表示节点 ai 和 bi 之间有一条 无向 边
class057/Code03_NumberOfGoodPaths.java:// 好路径需要满足以下条件：开始和结束节点的值相同、 路径中所有值都小于等于开始的值
class057/Code03_NumberOfGoodPaths.java:// 请你返回不同好路径的数目
class057/Code03_NumberOfGoodPaths.java:// 注意，一条路径和它反向的路径算作 同一 路径
class057/Code03_NumberOfGoodPaths.java:// 比方说， 0 -> 1 与 1 -> 0 视为同一条路径。单个节点也视为一条合法路径
class057/Code03_NumberOfGoodPaths.java:// 测试链接 : https://leetcode.cn/problems/number-of-good-paths/
class057/Code04_MinimizeMalwareSpreadII.java:// 尽量减少恶意软件的传播 II
class057/Code04_MinimizeMalwareSpreadII.java:// 给定一个由 n 个节点组成的网络，用 n x n 个邻接矩阵 graph 表示
class057/Code04_MinimizeMalwareSpreadII.java:// 在节点网络中，只有当 graph[i][j] = 1 时，节点 i 能够直接连接到另一个节点 j。
class057/Code04_MinimizeMalwareSpreadII.java:// 一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，
class057/Code04_MinimizeMalwareSpreadII.java:// 且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。
class057/Code04_MinimizeMalwareSpreadII.java:// 这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。
class057/Code04_MinimizeMalwareSpreadII.java:// 假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。
class057/Code04_MinimizeMalwareSpreadII.java:// 我们可以从 initial 中删除一个节点，
class057/Code04_MinimizeMalwareSpreadII.java:// 并完全移除该节点以及从该节点到任何其他节点的任何连接。
class057/Code04_MinimizeMalwareSpreadII.java:// 请返回移除后能够使 M(initial) 最小化的节点。
class057/Code04_MinimizeMalwareSpreadII.java:// 如果有多个节点满足条件，返回索引 最小的节点 。
class057/Code04_MinimizeMalwareSpreadII.java:// initial 中每个整数都不同
class057/Code04_MinimizeMalwareSpreadII.java:// 测试链接 : https://leetcode.cn/problems/minimize-malware-spread-ii/
算法讲解058【必备】洪水填充
class058/Code01_NumberOfIslands.java:// 岛屿数量
class058/Code01_NumberOfIslands.java:// 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量
class058/Code01_NumberOfIslands.java:// 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成
class058/Code01_NumberOfIslands.java:// 此外，你可以假设该网格的四条边均被水包围
class058/Code01_NumberOfIslands.java:// 测试链接 : https://leetcode.cn/problems/number-of-islands/
class058/Code02_SurroundedRegions.java:// 被围绕的区域
class058/Code02_SurroundedRegions.java:// 给你一个 m x n 的矩阵 board ，由若干字符 'X' 和 'O' ，找到所有被 'X' 围绕的区域
class058/Code02_SurroundedRegions.java:// 并将这些区域里所有的 'O' 用 'X' 填充。
class058/Code02_SurroundedRegions.java:// 测试链接 : https://leetcode.cn/problems/surrounded-regions/
class058/Code03_MakingLargeIsland.java:// 最大人工岛
class058/Code03_MakingLargeIsland.java:// 给你一个大小为 n * n 二进制矩阵 grid 。最多 只能将一格 0 变成 1 。
class058/Code03_MakingLargeIsland.java:// 返回执行此操作后，grid 中最大的岛屿面积是多少？
class058/Code03_MakingLargeIsland.java:// 岛屿 由一组上、下、左、右四个方向相连的 1 形成
class058/Code03_MakingLargeIsland.java:// 测试链接 : https://leetcode.cn/problems/making-a-large-island/
class058/Code04_BricksFallingWhenHit.java:// 打砖块
class058/Code04_BricksFallingWhenHit.java:// 有一个 m * n 的二元网格 grid ，其中 1 表示砖块，0 表示空白
class058/Code04_BricksFallingWhenHit.java:// 砖块 稳定（不会掉落）的前提是：
class058/Code04_BricksFallingWhenHit.java:// 一块砖直接连接到网格的顶部，或者
class058/Code04_BricksFallingWhenHit.java:// 至少有一块相邻（4 个方向之一）砖块 稳定 不会掉落时
class058/Code04_BricksFallingWhenHit.java:// 给你一个数组 hits ，这是需要依次消除砖块的位置
class058/Code04_BricksFallingWhenHit.java:// 每当消除 hits[i] = (rowi, coli) 位置上的砖块时，对应位置的砖块（若存在）会消失
class058/Code04_BricksFallingWhenHit.java:// 然后其他的砖块可能因为这一消除操作而 掉落
class058/Code04_BricksFallingWhenHit.java:// 一旦砖块掉落，它会 立即 从网格 grid 中消失（即，它不会落在其他稳定的砖块上）
class058/Code04_BricksFallingWhenHit.java:// 返回一个数组 result ，其中 result[i] 表示第 i 次消除操作对应掉落的砖块数目。
class058/Code04_BricksFallingWhenHit.java:// 注意，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。
class058/Code04_BricksFallingWhenHit.java:// 测试链接 : https://leetcode.cn/problems/bricks-falling-when-hit/
算法讲解059【必备】建图、链式前向星、拓扑排序
class059/Code02_TopoSortDynamicLeetcode.java:// 拓扑排序模版（Leetcode）
class059/Code02_TopoSortDynamicLeetcode.java:// 邻接表建图（动态方式）
class059/Code02_TopoSortDynamicLeetcode.java:// 课程表II
class059/Code02_TopoSortDynamicLeetcode.java:// 现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1
class059/Code02_TopoSortDynamicLeetcode.java:// 给你一个数组 prerequisites ，其中 prerequisites[i] = [ai, bi]
class059/Code02_TopoSortDynamicLeetcode.java:// 表示在选修课程 ai 前 必须 先选修 bi
class059/Code02_TopoSortDynamicLeetcode.java:// 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1]
class059/Code02_TopoSortDynamicLeetcode.java:// 返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序
class059/Code02_TopoSortDynamicLeetcode.java:// 你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组
class059/Code02_TopoSortDynamicLeetcode.java:// 测试链接 : https://leetcode.cn/problems/course-schedule-ii/
class059/Code02_TopoSortDynamicNowcoder.java:// 拓扑排序模版（牛客）
class059/Code02_TopoSortDynamicNowcoder.java:// 邻接表建图（动态方式）
class059/Code02_TopoSortDynamicNowcoder.java:// 测试链接 : https://www.nowcoder.com/practice/88f7e156ca7d43a1a535f619cd3f495c
class059/Code02_TopoSortDynamicNowcoder.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class059/Code02_TopoSortDynamicNowcoder.java:// 这是输入输出处理效率很高的写法
class059/Code02_TopoSortDynamicNowcoder.java:// 提交以下所有代码，把主类名改成Main，可以直接通过
class059/Code02_TopoSortStaticNowcoder.java:// 拓扑排序模版（牛客）
class059/Code02_TopoSortStaticNowcoder.java:// 链式前向星建图（静态方式）
class059/Code02_TopoSortStaticNowcoder.java:// 测试链接 : https://www.nowcoder.com/practice/88f7e156ca7d43a1a535f619cd3f495c
class059/Code02_TopoSortStaticNowcoder.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class059/Code02_TopoSortStaticNowcoder.java:// 这是输入输出处理效率很高的写法
class059/Code02_TopoSortStaticNowcoder.java:// 提交以下所有代码，把主类名改成Main，可以直接通过
class059/Code03_TopoSortStaticLuogu.java:// 字典序最小的拓扑排序
class059/Code03_TopoSortStaticLuogu.java:// 要求返回所有正确的拓扑排序中 字典序最小 的结果
class059/Code03_TopoSortStaticLuogu.java:// 建图请使用链式前向星方式，因为比赛平台用其他建图方式会卡空间
class059/Code03_TopoSortStaticLuogu.java:// 测试链接 : https://www.luogu.com.cn/problem/U107394
class059/Code03_TopoSortStaticLuogu.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class059/Code03_TopoSortStaticLuogu.java:// 这是输入输出处理效率很高的写法
class059/Code03_TopoSortStaticLuogu.java:// 提交以下所有代码，把主类名改成Main，可以直接通过
class059/Code04_AlienDictionary.java:// 火星词典
class059/Code04_AlienDictionary.java:// 现有一种使用英语字母的火星语言
class059/Code04_AlienDictionary.java:// 这门语言的字母顺序对你来说是未知的。
class059/Code04_AlienDictionary.java:// 给你一个来自这种外星语言字典的字符串列表 words
class059/Code04_AlienDictionary.java:// words 中的字符串已经 按这门新语言的字母顺序进行了排序 。
class059/Code04_AlienDictionary.java:// 如果这种说法是错误的，并且给出的 words 不能对应任何字母的顺序，则返回 ""
class059/Code04_AlienDictionary.java:// 否则，返回一个按新语言规则的 字典递增顺序 排序的独特字符串
class059/Code04_AlienDictionary.java:// 如果有多个解决方案，则返回其中任意一个
class059/Code04_AlienDictionary.java:// words中的单词一定都是小写英文字母组成的
class059/Code04_AlienDictionary.java:// 测试链接 : https://leetcode.cn/problems/alien-dictionary/
class059/Code04_AlienDictionary.java:// 测试链接(不需要会员) : https://leetcode.cn/problems/Jf1JuT/
class059/Code05_StampingTheSequence.java:// 戳印序列
class059/Code05_StampingTheSequence.java:// 你想最终得到"abcbc"，认为初始序列为"?????"。印章是"abc"
class059/Code05_StampingTheSequence.java:// 那么可以先用印章盖出"??abc"的状态，
class059/Code05_StampingTheSequence.java:// 然后用印章最左字符和序列的0位置对齐，就盖出了"abcbc"
class059/Code05_StampingTheSequence.java:// 这个过程中，"??abc"中的a字符，被印章中的c字符覆盖了
class059/Code05_StampingTheSequence.java:// 每次盖章的时候，印章必须完全盖在序列内
class059/Code05_StampingTheSequence.java:// 给定一个字符串target是最终的目标，长度为n，认为初始序列为n个'?'
class059/Code05_StampingTheSequence.java:// 给定一个印章字符串stamp，目标是最终盖出target
class059/Code05_StampingTheSequence.java:// 但是印章的使用次数必须在10*n次以内
class059/Code05_StampingTheSequence.java:// 返回一个数组，该数组由每个回合中被印下的最左边字母的索引组成
class059/Code05_StampingTheSequence.java:// 上面的例子返回[2,0]，表示印章最左字符依次和序列2位置、序列0位置对齐盖下去，就得到了target
class059/Code05_StampingTheSequence.java:// 如果不能在10*n次内印出序列，就返回一个空数组
class059/Code05_StampingTheSequence.java:// 测试链接 : https://leetcode.cn/problems/stamping-the-sequence/
算法讲解060【必备】拓扑排序的扩展技巧
class060/Code01_FoodLines.java:// 最大食物链计数
class060/Code01_FoodLines.java:// a -> b，代表a在食物链中被b捕食
class060/Code01_FoodLines.java:// 给定一个有向无环图，返回
class060/Code01_FoodLines.java:// 这个图中从最初级动物到最顶级捕食者的食物链有几条
class060/Code01_FoodLines.java:// 测试链接 : https://www.luogu.com.cn/problem/P4017
class060/Code01_FoodLines.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class060/Code01_FoodLines.java:// 这是输入输出处理效率很高的写法
class060/Code01_FoodLines.java:// 提交以下所有代码，把主类名改成Main，可以直接通过
class060/Code02_LoudAndRich.java:// 喧闹和富有
class060/Code02_LoudAndRich.java:// 从 0 到 n - 1 编号，其中每个人都有不同数目的钱，以及不同程度的安静值
class060/Code02_LoudAndRich.java:// 给你一个数组richer，其中richer[i] = [ai, bi] 表示 
class060/Code02_LoudAndRich.java:// person ai 比 person bi 更有钱
class060/Code02_LoudAndRich.java:// 还有一个整数数组 quiet ，其中 quiet[i] 是 person i 的安静值
class060/Code02_LoudAndRich.java:// richer 中所给出的数据 逻辑自洽
class060/Code02_LoudAndRich.java:// 也就是说，在 person x 比 person y 更有钱的同时，不会出现
class060/Code02_LoudAndRich.java:// person y 比 person x 更有钱的情况
class060/Code02_LoudAndRich.java:// 现在，返回一个整数数组 answer 作为答案，其中 answer[x] = y 的前提是,
class060/Code02_LoudAndRich.java:// 在所有拥有的钱肯定不少于 person x 的人中，
class060/Code02_LoudAndRich.java:// person y 是最安静的人（也就是安静值 quiet[y] 最小的人）。
class060/Code02_LoudAndRich.java:// 测试链接 : https://leetcode.cn/problems/loud-and-rich/
class060/Code03_ParallelCoursesIII.java:// 并行课程 III
class060/Code03_ParallelCoursesIII.java:// 给你一个整数 n ，表示有 n 节课，课程编号从 1 到 n
class060/Code03_ParallelCoursesIII.java:// 同时给你一个二维整数数组 relations ，
class060/Code03_ParallelCoursesIII.java:// 其中 relations[j] = [prevCoursej, nextCoursej]
class060/Code03_ParallelCoursesIII.java:// 表示课程 prevCoursej 必须在课程 nextCoursej 之前 完成（先修课的关系）
class060/Code03_ParallelCoursesIII.java:// 同时给你一个下标从 0 开始的整数数组 time
class060/Code03_ParallelCoursesIII.java:// 其中 time[i] 表示完成第 (i+1) 门课程需要花费的 月份 数。
class060/Code03_ParallelCoursesIII.java:// 请你根据以下规则算出完成所有课程所需要的 最少 月份数：
class060/Code03_ParallelCoursesIII.java:// 如果一门课的所有先修课都已经完成，你可以在 任意 时间开始这门课程。
class060/Code03_ParallelCoursesIII.java:// 你可以 同时 上 任意门课程 。请你返回完成所有课程所需要的 最少 月份数。
class060/Code03_ParallelCoursesIII.java:// 注意：测试数据保证一定可以完成所有课程（也就是先修课的关系构成一个有向无环图）
class060/Code03_ParallelCoursesIII.java:// 测试链接 : https://leetcode.cn/problems/parallel-courses-iii/
class060/Code04_MaximumEmployeesToBeInvitedToAMeeting.java:// 参加会议的最多员工数
class060/Code04_MaximumEmployeesToBeInvitedToAMeeting.java:// 一个公司准备组织一场会议，邀请名单上有 n 位员工
class060/Code04_MaximumEmployeesToBeInvitedToAMeeting.java:// 公司准备了一张 圆形 的桌子，可以坐下 任意数目 的员工
class060/Code04_MaximumEmployeesToBeInvitedToAMeeting.java:// 员工编号为 0 到 n - 1 。每位员工都有一位 喜欢 的员工
class060/Code04_MaximumEmployeesToBeInvitedToAMeeting.java:// 每位员工 当且仅当 他被安排在喜欢员工的旁边，他才会参加会议
class060/Code04_MaximumEmployeesToBeInvitedToAMeeting.java:// 每位员工喜欢的员工 不会 是他自己。给你一个下标从 0 开始的整数数组 favorite
class060/Code04_MaximumEmployeesToBeInvitedToAMeeting.java:// 其中 favorite[i] 表示第 i 位员工喜欢的员工。请你返回参加会议的 最多员工数目
class060/Code04_MaximumEmployeesToBeInvitedToAMeeting.java:// 测试链接 : https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/
算法讲解061【必备】最小生成树
class061/Code01_Kruskal.java:// Kruskal算法模版（洛谷）
class061/Code01_Kruskal.java:// 静态空间实现
class061/Code01_Kruskal.java:// 测试链接 : https://www.luogu.com.cn/problem/P3366
class061/Code01_Kruskal.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class061/Code01_Kruskal.java:// 这是输入输出处理效率很高的写法
class061/Code01_Kruskal.java:// 提交以下所有代码，把主类名改成Main，可以直接通过
class061/Code01_Kruskal.java:// 时间复杂度O(m * log m) + O(n + m)
class061/Code02_PrimDynamic.java:// Prim算法模版（洛谷）
class061/Code02_PrimDynamic.java:// 动态空间实现
class061/Code02_PrimDynamic.java:// 测试链接 : https://www.luogu.com.cn/problem/P3366
class061/Code02_PrimDynamic.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class061/Code02_PrimDynamic.java:// 这是输入输出处理效率很高的写法
class061/Code02_PrimDynamic.java:// 提交以下所有代码，把主类名改成Main，可以直接通过
class061/Code02_PrimDynamic.java:// 时间复杂度O(n + m) + O(m * log m)
class061/Code02_PrimStatic.java:// Prim算法优化（洛谷）
class061/Code02_PrimStatic.java:// 静态空间实现
class061/Code02_PrimStatic.java:// 时间复杂度O(n + m) + O((m+n) * log n)
class061/Code02_PrimStatic.java:// 测试链接 : https://www.luogu.com.cn/problem/P3366
class061/Code02_PrimStatic.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class061/Code02_PrimStatic.java:// 这是输入输出处理效率很高的写法
class061/Code02_PrimStatic.java:// 提交以下所有代码，把主类名改成Main，可以直接通过
class061/Code02_PrimStatic.java:// 建图用链式前向星
class061/Code02_PrimStatic.java:// 堆也是用数组结构手写的、且只和节点个数有关
class061/Code02_PrimStatic.java:// 这个实现留给有需要的同学
class061/Code02_PrimStatic.java:// 但是一般情况下并不需要做到这个程度
class061/Code03_OptimizeWaterDistribution.java:// 水资源分配优化
class061/Code03_OptimizeWaterDistribution.java:// 村里面一共有 n 栋房子。我们希望通过建造水井和铺设管道来为所有房子供水。
class061/Code03_OptimizeWaterDistribution.java:// 对于每个房子 i，我们有两种可选的供水方案：一种是直接在房子内建造水井
class061/Code03_OptimizeWaterDistribution.java:// 成本为 wells[i - 1] （注意 -1 ，因为 索引从0开始 ）
class061/Code03_OptimizeWaterDistribution.java:// 另一种是从另一口井铺设管道引水，数组 pipes 给出了在房子间铺设管道的成本，
class061/Code03_OptimizeWaterDistribution.java:// 其中每个 pipes[j] = [house1j, house2j, costj] 
class061/Code03_OptimizeWaterDistribution.java:// 代表用管道将 house1j 和 house2j连接在一起的成本。连接是双向的。
class061/Code03_OptimizeWaterDistribution.java:// 请返回 为所有房子都供水的最低总成本
class061/Code03_OptimizeWaterDistribution.java:// 测试链接 : https://leetcode.cn/problems/optimize-water-distribution-in-a-village/
class061/Code04_CheckingExistenceOfEdgeLengthLimit.java:// 检查边长度限制的路径是否存在
class061/Code04_CheckingExistenceOfEdgeLengthLimit.java:// 给你一个 n 个点组成的无向图边集 edgeList
class061/Code04_CheckingExistenceOfEdgeLengthLimit.java:// 其中 edgeList[i] = [ui, vi, disi] 表示点 ui 和点 vi 之间有一条长度为 disi 的边
class061/Code04_CheckingExistenceOfEdgeLengthLimit.java:// 请注意，两个点之间可能有 超过一条边 。
class061/Code04_CheckingExistenceOfEdgeLengthLimit.java:// 给你一个查询数组queries ，其中 queries[j] = [pj, qj, limitj]
class061/Code04_CheckingExistenceOfEdgeLengthLimit.java:// 你的任务是对于每个查询 queries[j] ，判断是否存在从 pj 到 qj 的路径
class061/Code04_CheckingExistenceOfEdgeLengthLimit.java:// 且这条路径上的每一条边都 严格小于 limitj 。
class061/Code04_CheckingExistenceOfEdgeLengthLimit.java:// 请你返回一个 布尔数组 answer ，其中 answer.length == queries.length
class061/Code04_CheckingExistenceOfEdgeLengthLimit.java:// 当 queries[j] 的查询结果为 true 时， answer 第 j 个值为 true ，否则为 false
class061/Code04_CheckingExistenceOfEdgeLengthLimit.java:// 测试链接 : https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/
class061/Code05_BusyCities.java:// 繁忙的都市
class061/Code05_BusyCities.java:// 一个非常繁忙的大都市，城市中的道路十分的拥挤，于是市长决定对其中的道路进行改造
class061/Code05_BusyCities.java:// 城市的道路是这样分布的：城市中有n个交叉路口，有些交叉路口之间有道路相连
class061/Code05_BusyCities.java:// 两个交叉路口之间最多有一条道路相连接，这些道路是双向的
class061/Code05_BusyCities.java:// 且把所有的交叉路口直接或间接的连接起来了
class061/Code05_BusyCities.java:// 每条道路都有一个分值，分值越小表示这个道路越繁忙，越需要进行改造
class061/Code05_BusyCities.java:// 但是市政府的资金有限，市长希望进行改造的道路越少越好，于是他提出下面的要求：
class061/Code05_BusyCities.java:// 1. 改造的那些道路能够把所有的交叉路口直接或间接的连通起来
class061/Code05_BusyCities.java:// 2. 在满足要求1的情况下，改造的道路尽量少
class061/Code05_BusyCities.java:// 3. 在满足要求1、2的情况下，改造的那些道路中分值最大的道路分值尽量小
class061/Code05_BusyCities.java:// 作为市规划局的你，应当作出最佳的决策，选择哪些道路应当被修建
class061/Code05_BusyCities.java:// 返回选出了几条道路 以及 分值最大的那条道路的分值是多少
class061/Code05_BusyCities.java:// 测试链接 : https://www.luogu.com.cn/problem/P2330
class061/Code05_BusyCities.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class061/Code05_BusyCities.java:// 这是输入输出处理效率很高的写法
class061/Code05_BusyCities.java:// 提交以下所有代码，把主类名改成Main，可以直接通过
算法讲解062【必备】宽度优先遍历及其扩展
class062/Code01_AsFarFromLandAsPossible.java:// 地图分析
class062/Code01_AsFarFromLandAsPossible.java:// 你现在手里有一份大小为 n x n 的 网格 grid
class062/Code01_AsFarFromLandAsPossible.java:// 上面的每个 单元格 都用 0 和 1 标记好了其中 0 代表海洋，1 代表陆地。
class062/Code01_AsFarFromLandAsPossible.java:// 请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的
class062/Code01_AsFarFromLandAsPossible.java:// 并返回该距离。如果网格上只有陆地或者海洋，请返回 -1。
class062/Code01_AsFarFromLandAsPossible.java:// 我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：
class062/Code01_AsFarFromLandAsPossible.java:// (x0, y0) 和 (x1, y1) 这两个单元格之间的距离是 |x0 - x1| + |y0 - y1| 。
class062/Code01_AsFarFromLandAsPossible.java:// 测试链接 : https://leetcode.cn/problems/as-far-from-land-as-possible/
class062/Code02_StickersToSpellWord.java:// 贴纸拼词
class062/Code02_StickersToSpellWord.java:// 我们有 n 种不同的贴纸。每个贴纸上都有一个小写的英文单词。
class062/Code02_StickersToSpellWord.java:// 您想要拼写出给定的字符串 target ，方法是从收集的贴纸中切割单个字母并重新排列它们
class062/Code02_StickersToSpellWord.java:// 如果你愿意，你可以多次使用每个贴纸，每个贴纸的数量是无限的。
class062/Code02_StickersToSpellWord.java:// 返回你需要拼出 target 的最小贴纸数量。如果任务不可能，则返回 -1
class062/Code02_StickersToSpellWord.java:// 注意：在所有的测试用例中，所有的单词都是从 1000 个最常见的美国英语单词中随机选择的
class062/Code02_StickersToSpellWord.java:// 并且 target 被选择为两个随机单词的连接。
class062/Code02_StickersToSpellWord.java:// 测试链接 : https://leetcode.cn/problems/stickers-to-spell-word/
class062/Code03_MinimumObstacleRemovalToReachCorner.java:// 到达角落需要移除障碍物的最小数目
class062/Code03_MinimumObstacleRemovalToReachCorner.java:// 给你一个下标从 0 开始的二维整数数组 grid ，数组大小为 m x n
class062/Code03_MinimumObstacleRemovalToReachCorner.java:// 每个单元格都是两个值之一：
class062/Code03_MinimumObstacleRemovalToReachCorner.java:// 0 表示一个 空 单元格，
class062/Code03_MinimumObstacleRemovalToReachCorner.java:// 1 表示一个可以移除的 障碍物
class062/Code03_MinimumObstacleRemovalToReachCorner.java:// 你可以向上、下、左、右移动，从一个空单元格移动到另一个空单元格。
class062/Code03_MinimumObstacleRemovalToReachCorner.java:// 现在你需要从左上角 (0, 0) 移动到右下角 (m - 1, n - 1) 
class062/Code03_MinimumObstacleRemovalToReachCorner.java:// 返回需要移除的障碍物的最小数目
class062/Code03_MinimumObstacleRemovalToReachCorner.java:// 测试链接 : https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/
class062/Code04_MinimumCostToMakeAtLeastOneValidPath.java:// 使网格图至少有一条有效路径的最小代价
class062/Code04_MinimumCostToMakeAtLeastOneValidPath.java:// 给你一个 m * n 的网格图 grid 。 grid 中每个格子都有一个数字
class062/Code04_MinimumCostToMakeAtLeastOneValidPath.java:// 对应着从该格子出发下一步走的方向。 grid[i][j] 中的数字可能为以下几种情况：
class062/Code04_MinimumCostToMakeAtLeastOneValidPath.java:// 1 ，下一步往右走，也就是你会从 grid[i][j] 走到 grid[i][j + 1]
class062/Code04_MinimumCostToMakeAtLeastOneValidPath.java:// 2 ，下一步往左走，也就是你会从 grid[i][j] 走到 grid[i][j - 1]
class062/Code04_MinimumCostToMakeAtLeastOneValidPath.java:// 3 ，下一步往下走，也就是你会从 grid[i][j] 走到 grid[i + 1][j]
class062/Code04_MinimumCostToMakeAtLeastOneValidPath.java:// 4 ，下一步往上走，也就是你会从 grid[i][j] 走到 grid[i - 1][j]
class062/Code04_MinimumCostToMakeAtLeastOneValidPath.java:// 注意网格图中可能会有 无效数字 ，因为它们可能指向 grid 以外的区域
class062/Code04_MinimumCostToMakeAtLeastOneValidPath.java:// 一开始，你会从最左上角的格子 (0,0) 出发
class062/Code04_MinimumCostToMakeAtLeastOneValidPath.java:// 我们定义一条 有效路径 为从格子 (0,0) 出发，每一步都顺着数字对应方向走
class062/Code04_MinimumCostToMakeAtLeastOneValidPath.java:// 最终在最右下角的格子 (m - 1, n - 1) 结束的路径
class062/Code04_MinimumCostToMakeAtLeastOneValidPath.java:// 有效路径 不需要是最短路径
class062/Code04_MinimumCostToMakeAtLeastOneValidPath.java:// 你可以花费1的代价修改一个格子中的数字，但每个格子中的数字 只能修改一次
class062/Code04_MinimumCostToMakeAtLeastOneValidPath.java:// 请你返回让网格图至少有一条有效路径的最小代价
class062/Code04_MinimumCostToMakeAtLeastOneValidPath.java:// 测试链接 : https://leetcode.cn/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/
class062/Code05_TrappingRainWaterII.java:// 二维接雨水
class062/Code05_TrappingRainWaterII.java:// 给你一个 m * n 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度
class062/Code05_TrappingRainWaterII.java:// 请计算图中形状最多能接多少体积的雨水。
class062/Code05_TrappingRainWaterII.java:// 测试链接 : https://leetcode.cn/problems/trapping-rain-water-ii/
class062/Code06_WordLadderII.java:// 单词接龙 II
class062/Code06_WordLadderII.java:// 按字典 wordList 完成从单词 beginWord 到单词 endWord 转化
class062/Code06_WordLadderII.java:// 一个表示此过程的 转换序列 是形式上像 
class062/Code06_WordLadderII.java:// beginWord -> s1 -> s2 -> ... -> sk 这样的单词序列，并满足：
class062/Code06_WordLadderII.java:// 每对相邻的单词之间仅有单个字母不同
class062/Code06_WordLadderII.java:// 转换过程中的每个单词 si（1 <= i <= k）必须是字典 wordList 中的单词
class062/Code06_WordLadderII.java:// 注意，beginWord 不必是字典 wordList 中的单词
class062/Code06_WordLadderII.java:// sk == endWord
class062/Code06_WordLadderII.java:// 给你两个单词 beginWord 和 endWord ，以及一个字典 wordList
class062/Code06_WordLadderII.java:// 请你找出并返回所有从 beginWord 到 endWord 的 最短转换序列
class062/Code06_WordLadderII.java:// 如果不存在这样的转换序列，返回一个空列表
class062/Code06_WordLadderII.java:// 每个序列都应该以单词列表 [beginWord, s1, s2, ..., sk] 的形式返回
class062/Code06_WordLadderII.java:// 测试链接 : https://leetcode.cn/problems/word-ladder-ii/
算法讲解063【必备】双向广搜
class063/Code01_WordLadder.java:// 单词接龙
class063/Code01_WordLadder.java:// 字典 wordList 中从单词 beginWord 和 endWord 的 转换序列
class063/Code01_WordLadder.java:// 是一个按下述规格形成的序列 beginWord -> s1 -> s2 -> ... -> sk ：
class063/Code01_WordLadder.java:// 每一对相邻的单词只差一个字母。
class063/Code01_WordLadder.java:// 对于 1 <= i <= k 时，每个 si 都在 wordList 中
class063/Code01_WordLadder.java:// 注意， beginWord 不需要在 wordList 中。sk == endWord
class063/Code01_WordLadder.java:// 给你两个单词 beginWord 和 endWord 和一个字典 wordList
class063/Code01_WordLadder.java:// 返回 从 beginWord 到 endWord 的 最短转换序列 中的 单词数目
class063/Code01_WordLadder.java:// 如果不存在这样的转换序列，返回 0 。
class063/Code01_WordLadder.java:// 测试链接 : https://leetcode.cn/problems/word-ladder/
class063/Code02_SnacksWaysBuyTickets.java:// 牛牛的背包问题 & 世界冰球锦标赛
class063/Code02_SnacksWaysBuyTickets.java:// 牛牛准备参加学校组织的春游, 出发前牛牛准备往背包里装入一些零食, 牛牛的背包容量为w。
class063/Code02_SnacksWaysBuyTickets.java:// 牛牛家里一共有n袋零食, 第i袋零食体积为v[i]。
class063/Code02_SnacksWaysBuyTickets.java:// 牛牛想知道在总体积不超过背包容量的情况下,他一共有多少种零食放法(总体积为0也算一种放法)。
class063/Code02_SnacksWaysBuyTickets.java:// 输入描述：
class063/Code02_SnacksWaysBuyTickets.java:// 输入包括两行
class063/Code02_SnacksWaysBuyTickets.java:// 第一行为两个正整数n和w(1 <= n <= 30, 1 <= w <= 2 * 10^9),表示零食的数量和背包的容量
class063/Code02_SnacksWaysBuyTickets.java:// 第二行n个正整数v[i](0 <= v[i] <= 10^9),表示每袋零食的体积
class063/Code02_SnacksWaysBuyTickets.java:// 输出描述：
class063/Code02_SnacksWaysBuyTickets.java:// 输出一个正整数, 表示牛牛一共有多少种零食放法。
class063/Code02_SnacksWaysBuyTickets.java:// 测试链接 : https://www.luogu.com.cn/problem/P4799
class063/Code02_SnacksWaysBuyTickets.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class063/Code02_SnacksWaysBuyTickets.java:// 这是输入输出处理效率很高的写法
class063/Code02_SnacksWaysBuyTickets.java:// 提交以下所有代码，把主类名改成Main，可以直接通过
class063/Code03_ClosestSubsequenceSum.java:// 最接近目标值的子序列和
class063/Code03_ClosestSubsequenceSum.java:// 给你一个整数数组 nums 和一个目标值 goal
class063/Code03_ClosestSubsequenceSum.java:// 你需要从 nums 中选出一个子序列，使子序列元素总和最接近 goal
class063/Code03_ClosestSubsequenceSum.java:// 也就是说，如果子序列元素和为 sum ，你需要 最小化绝对差 abs(sum - goal)
class063/Code03_ClosestSubsequenceSum.java:// 返回 abs(sum - goal) 可能的 最小值
class063/Code03_ClosestSubsequenceSum.java:// 注意，数组的子序列是通过移除原始数组中的某些元素（可能全部或无）而形成的数组。
class063/Code03_ClosestSubsequenceSum.java:// 数据量描述:
class063/Code03_ClosestSubsequenceSum.java:// 1 <= nums.length <= 40
class063/Code03_ClosestSubsequenceSum.java:// -10^7 <= nums[i] <= 10^7
class063/Code03_ClosestSubsequenceSum.java:// -10^9 <= goal <= 10^9
class063/Code03_ClosestSubsequenceSum.java:// 测试链接 : https://leetcode.cn/problems/closest-subsequence-sum/
算法讲解064【必备】Dijkstra算法、分层图最短路
class064/Code01_DijkstraLeetcode.java:// Dijkstra算法模版（Leetcode）
class064/Code01_DijkstraLeetcode.java:// 网络延迟时间
class064/Code01_DijkstraLeetcode.java:// 有 n 个网络节点，标记为 1 到 n
class064/Code01_DijkstraLeetcode.java:// 给你一个列表 times，表示信号经过 有向 边的传递时间
class064/Code01_DijkstraLeetcode.java:// times[i] = (ui, vi, wi)，表示从ui到vi传递信号的时间是wi
class064/Code01_DijkstraLeetcode.java:// 现在，从某个节点 s 发出一个信号
class064/Code01_DijkstraLeetcode.java:// 需要多久才能使所有节点都收到信号
class064/Code01_DijkstraLeetcode.java:// 如果不能使所有节点收到信号，返回 -1
class064/Code01_DijkstraLeetcode.java:// 测试链接 : https://leetcode.cn/problems/network-delay-time
class064/Code01_DijkstraLuogu.java:// Dijkstra算法模版（洛谷）
class064/Code01_DijkstraLuogu.java:// 静态空间实现 : 链式前向星 + 反向索引堆
class064/Code01_DijkstraLuogu.java:// 测试链接 : https://www.luogu.com.cn/problem/P4779
class064/Code01_DijkstraLuogu.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class064/Code01_DijkstraLuogu.java:// 这是输入输出处理效率很高的写法
class064/Code01_DijkstraLuogu.java:// 提交以下所有代码，把主类名改成Main，可以直接通过
class064/Code02_PathWithMinimumEffort.java:// 最小体力消耗路径
class064/Code02_PathWithMinimumEffort.java:// 你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights
class064/Code02_PathWithMinimumEffort.java:// 其中 heights[row][col] 表示格子 (row, col) 的高度
class064/Code02_PathWithMinimumEffort.java:// 一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) 
class064/Code02_PathWithMinimumEffort.java:// （注意下标从 0 开始编号）。你每次可以往 上，下，左，右 四个方向之一移动
class064/Code02_PathWithMinimumEffort.java:// 你想要找到耗费 体力 最小的一条路径
class064/Code02_PathWithMinimumEffort.java:// 一条路径耗费的体力值是路径上，相邻格子之间高度差绝对值的最大值
class064/Code02_PathWithMinimumEffort.java:// 请你返回从左上角走到右下角的最小 体力消耗值
class064/Code02_PathWithMinimumEffort.java:// 测试链接 ：https://leetcode.cn/problems/path-with-minimum-effort/
class064/Code03_SwimInRisingWater.java:// 水位上升的泳池中游泳
class064/Code03_SwimInRisingWater.java:// 在一个 n x n 的整数矩阵 grid 中
class064/Code03_SwimInRisingWater.java:// 每一个方格的值 grid[i][j] 表示位置 (i, j) 的平台高度
class064/Code03_SwimInRisingWater.java:// 当开始下雨时，在时间为 t 时，水池中的水位为 t
class064/Code03_SwimInRisingWater.java:// 你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台
class064/Code03_SwimInRisingWater.java:// 假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的
class064/Code03_SwimInRisingWater.java:// 当然，在你游泳的时候你必须待在坐标方格里面。
class064/Code03_SwimInRisingWater.java:// 你从坐标方格的左上平台 (0，0) 出发
class064/Code03_SwimInRisingWater.java:// 返回 你到达坐标方格的右下平台 (n-1, n-1) 所需的最少时间
class064/Code03_SwimInRisingWater.java:// 测试链接 : https://leetcode.cn/problems/swim-in-rising-water/
class064/Code04_ShortestPathToGetAllKeys.java:// 获取所有钥匙的最短路径
class064/Code04_ShortestPathToGetAllKeys.java:// 给定一个二维网格 grid ，其中：
class064/Code04_ShortestPathToGetAllKeys.java:// '.' 代表一个空房间、'#' 代表一堵、'@' 是起点
class064/Code04_ShortestPathToGetAllKeys.java:// 小写字母代表钥匙、大写字母代表锁
class064/Code04_ShortestPathToGetAllKeys.java:// 从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间
class064/Code04_ShortestPathToGetAllKeys.java:// 不能在网格外面行走，也无法穿过一堵墙
class064/Code04_ShortestPathToGetAllKeys.java:// 如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。
class064/Code04_ShortestPathToGetAllKeys.java:// 假设 k 为 钥匙/锁 的个数，且满足 1 <= k <= 6，
class064/Code04_ShortestPathToGetAllKeys.java:// 字母表中的前 k 个字母在网格中都有自己对应的一个小写和一个大写字母
class064/Code04_ShortestPathToGetAllKeys.java:// 换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁
class064/Code04_ShortestPathToGetAllKeys.java:// 另外，代表钥匙和锁的字母互为大小写并按字母顺序排列
class064/Code04_ShortestPathToGetAllKeys.java:// 返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 -1 。
class064/Code04_ShortestPathToGetAllKeys.java:// 测试链接：https://leetcode.cn/problems/shortest-path-to-get-all-keys
class064/Code05_VisitCityMinCost.java:// 电动车游城市
class064/Code05_VisitCityMinCost.java:// 小明的电动车电量充满时可行驶距离为 cnt，每行驶 1 单位距离消耗 1 单位电量，且花费 1 单位时间
class064/Code05_VisitCityMinCost.java:// 小明想选择电动车作为代步工具。地图上共有 N 个景点，景点编号为 0 ~ N-1
class064/Code05_VisitCityMinCost.java:// 他将地图信息以 [城市 A 编号,城市 B 编号,两城市间距离] 格式整理在在二维数组 paths，
class064/Code05_VisitCityMinCost.java:// 表示城市 A、B 间存在双向通路。
class064/Code05_VisitCityMinCost.java:// 初始状态，电动车电量为 0。每个城市都设有充电桩，
class064/Code05_VisitCityMinCost.java:// charge[i] 表示第 i 个城市每充 1 单位电量需要花费的单位时间。
class064/Code05_VisitCityMinCost.java:// 请返回小明最少需要花费多少单位时间从起点城市 start 抵达终点城市 end
class064/Code05_VisitCityMinCost.java:// 测试链接 : https://leetcode.cn/problems/DFPeFJ/
class064/Code06_FlightPath1.java:// 飞行路线（语言提供的堆）
class064/Code06_FlightPath1.java:// Alice和Bob现在要乘飞机旅行，他们选择了一家相对便宜的航空公司
class064/Code06_FlightPath1.java:// 该航空公司一共在n个城市设有业务，设这些城市分别标记为0 ~ n−1
class064/Code06_FlightPath1.java:// 一共有m种航线，每种航线连接两个城市，并且航线有一定的价格
class064/Code06_FlightPath1.java:// Alice 和 Bob 现在要从一个城市沿着航线到达另一个城市，途中可以进行转机
class064/Code06_FlightPath1.java:// 航空公司对他们这次旅行也推出优惠，他们可以免费在最多k种航线上搭乘飞机
class064/Code06_FlightPath1.java:// 那么 Alice 和 Bob 这次出行最少花费多少
class064/Code06_FlightPath1.java:// 测试链接 : https://www.luogu.com.cn/problem/P4568
class064/Code06_FlightPath1.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class064/Code06_FlightPath1.java:// 这是输入输出处理效率很高的写法
class064/Code06_FlightPath1.java:// 提交以下所有代码，把主类名改成Main，可以直接通过
class064/Code06_FlightPath2.java:// 飞行路线（自己手撸的堆）
class064/Code06_FlightPath2.java:// Alice和Bob现在要乘飞机旅行，他们选择了一家相对便宜的航空公司
class064/Code06_FlightPath2.java:// 该航空公司一共在n个城市设有业务，设这些城市分别标记为0 ~ n−1
class064/Code06_FlightPath2.java:// 一共有m种航线，每种航线连接两个城市，并且航线有一定的价格
class064/Code06_FlightPath2.java:// Alice 和 Bob 现在要从一个城市沿着航线到达另一个城市，途中可以进行转机
class064/Code06_FlightPath2.java:// 航空公司对他们这次旅行也推出优惠，他们可以免费在最多k种航线上搭乘飞机
class064/Code06_FlightPath2.java:// 那么 Alice 和 Bob 这次出行最少花费多少
class064/Code06_FlightPath2.java:// 测试链接 : https://www.luogu.com.cn/problem/P4568
class064/Code06_FlightPath2.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class064/Code06_FlightPath2.java:// 这是输入输出处理效率很高的写法
class064/Code06_FlightPath2.java:// 提交以下所有代码，把主类名改成Main，可以直接通过
算法讲解065【必备】A星、Floyd、Bellman Ford与SPFA
class065/Code01_AStarAlgorithm.java:// A*算法模版（对数器验证）
class065/Code02_Floyd.java:// Floyd算法模版（洛谷）
class065/Code02_Floyd.java:// 测试链接 : https://www.luogu.com.cn/problem/P2910
class065/Code02_Floyd.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class065/Code02_Floyd.java:// 这是输入输出处理效率很高的写法
class065/Code02_Floyd.java:// 提交以下所有代码，把主类名改成Main，可以直接通过
class065/Code03_BellmanFord.java:// Bellman-Ford算法应用（不是模版）
class065/Code03_BellmanFord.java:// k站中转内最便宜的航班
class065/Code03_BellmanFord.java:// 有 n 个城市通过一些航班连接。给你一个数组 flights
class065/Code03_BellmanFord.java:// 其中 flights[i] = [fromi, toi, pricei]
class065/Code03_BellmanFord.java:// 表示该航班都从城市 fromi 开始，以价格 pricei 抵达 toi。
class065/Code03_BellmanFord.java:// 现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到出一条最多经过 k 站中转的路线
class065/Code03_BellmanFord.java:// 使得从 src 到 dst 的 价格最便宜 ，并返回该价格。 如果不存在这样的路线，则输出 -1。
class065/Code03_BellmanFord.java:// 测试链接 : https://leetcode.cn/problems/cheapest-flights-within-k-stops/
class065/Code04_SPFA.java:// Bellman-Ford + SPFA优化模版（洛谷）
class065/Code04_SPFA.java:// 给定n个点的有向图，请求出图中是否存在从顶点1出发能到达的负环
class065/Code04_SPFA.java:// 负环的定义是：一条边权之和为负数的回路
class065/Code04_SPFA.java:// 测试链接 : https://www.luogu.com.cn/problem/P3385
class065/Code04_SPFA.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class065/Code04_SPFA.java:// 这是输入输出处理效率很高的写法
class065/Code04_SPFA.java:// 提交以下所有代码，把主类名改成Main，可以直接通过
算法讲解066【必备】从递归入手一维动态规划
class066/Code01_FibonacciNumber.java:// 斐波那契数
class066/Code01_FibonacciNumber.java:// 斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列
class066/Code01_FibonacciNumber.java:// 该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。
class066/Code01_FibonacciNumber.java:// 也就是：F(0) = 0，F(1) = 1
class066/Code01_FibonacciNumber.java:// F(n) = F(n - 1) + F(n - 2)，其中 n > 1
class066/Code01_FibonacciNumber.java:// 给定 n ，请计算 F(n)
class066/Code01_FibonacciNumber.java:// 测试链接 : https://leetcode.cn/problems/fibonacci-number/
class066/Code01_FibonacciNumber.java:// 注意：最优解来自矩阵快速幂，时间复杂度可以做到O(log n)
class066/Code01_FibonacciNumber.java:// 后续课程一定会讲述！本节课不涉及！
class066/Code02_MinimumCostForTickets.java:// 最低票价
class066/Code02_MinimumCostForTickets.java:// 在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行
class066/Code02_MinimumCostForTickets.java:// 在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出
class066/Code02_MinimumCostForTickets.java:// 每一项是一个从 1 到 365 的整数
class066/Code02_MinimumCostForTickets.java:// 火车票有 三种不同的销售方式
class066/Code02_MinimumCostForTickets.java:// 一张 为期1天 的通行证售价为 costs[0] 美元
class066/Code02_MinimumCostForTickets.java:// 一张 为期7天 的通行证售价为 costs[1] 美元
class066/Code02_MinimumCostForTickets.java:// 一张 为期30天 的通行证售价为 costs[2] 美元
class066/Code02_MinimumCostForTickets.java:// 通行证允许数天无限制的旅行
class066/Code02_MinimumCostForTickets.java:// 例如，如果我们在第 2 天获得一张 为期 7 天 的通行证
class066/Code02_MinimumCostForTickets.java:// 那么我们可以连着旅行 7 天(第2~8天)
class066/Code02_MinimumCostForTickets.java:// 返回 你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费
class066/Code02_MinimumCostForTickets.java:// 测试链接 : https://leetcode.cn/problems/minimum-cost-for-tickets/
class066/Code03_DecodeWays.java:// 解码方法
class066/Code03_DecodeWays.java:// 一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：
class066/Code03_DecodeWays.java:// 'A' -> "1"
class066/Code03_DecodeWays.java:// 'B' -> "2"
class066/Code03_DecodeWays.java:// ...
class066/Code03_DecodeWays.java:// 'Z' -> "26"
class066/Code03_DecodeWays.java:// 要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）
class066/Code03_DecodeWays.java:// 例如，"11106" 可以映射为："AAJF"、"KJF"
class066/Code03_DecodeWays.java:// 注意，消息不能分组为(1 11 06)，因为 "06" 不能映射为 "F"
class066/Code03_DecodeWays.java:// 这是由于 "6" 和 "06" 在映射中并不等价
class066/Code03_DecodeWays.java:// 给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数
class066/Code03_DecodeWays.java:// 题目数据保证答案肯定是一个 32位 的整数
class066/Code03_DecodeWays.java:// 测试链接 : https://leetcode.cn/problems/decode-ways/
class066/Code04_DecodeWaysII.java:// 解码方法 II
class066/Code04_DecodeWaysII.java:// 一条包含字母 A-Z 的消息通过以下的方式进行了 编码 ：
class066/Code04_DecodeWaysII.java:// 'A' -> "1"
class066/Code04_DecodeWaysII.java:// 'B' -> "2"
class066/Code04_DecodeWaysII.java:// ...
class066/Code04_DecodeWaysII.java:// 'Z' -> "26"
class066/Code04_DecodeWaysII.java:// 要 解码 一条已编码的消息，所有的数字都必须分组
class066/Code04_DecodeWaysII.java:// 然后按原来的编码方案反向映射回字母（可能存在多种方式）
class066/Code04_DecodeWaysII.java:// 例如，"11106" 可以映射为："AAJF"、"KJF"
class066/Code04_DecodeWaysII.java:// 注意，像 (1 11 06) 这样的分组是无效的，"06"不可以映射为'F'
class066/Code04_DecodeWaysII.java:// 除了上面描述的数字字母映射方案，编码消息中可能包含 '*' 字符
class066/Code04_DecodeWaysII.java:// 可以表示从 '1' 到 '9' 的任一数字（不包括 '0'）
class066/Code04_DecodeWaysII.java:// 例如，"1*" 可以表示 "11"、"12"、"13"、"14"、"15"、"16"、"17"、"18" 或 "19"
class066/Code04_DecodeWaysII.java:// 对 "1*" 进行解码，相当于解码该字符串可以表示的任何编码消息
class066/Code04_DecodeWaysII.java:// 给你一个字符串 s ，由数字和 '*' 字符组成，返回 解码 该字符串的方法 数目
class066/Code04_DecodeWaysII.java:// 由于答案数目可能非常大，返回10^9 + 7的模
class066/Code04_DecodeWaysII.java:// 测试链接 : https://leetcode.cn/problems/decode-ways-ii/
class066/Code05_UglyNumberII.java:// 丑数 II
class066/Code05_UglyNumberII.java:// 给你一个整数 n ，请你找出并返回第 n 个 丑数
class066/Code05_UglyNumberII.java:// 丑数 就是只包含质因数 2、3 或 5 的正整数
class066/Code05_UglyNumberII.java:// 测试链接 : https://leetcode.cn/problems/ugly-number-ii/
class066/Code06_LongestValidParentheses.java:// 最长有效括号
class066/Code06_LongestValidParentheses.java:// 给你一个只包含 '(' 和 ')' 的字符串
class066/Code06_LongestValidParentheses.java:// 找出最长有效（格式正确且连续）括号子串的长度。
class066/Code06_LongestValidParentheses.java:// 测试链接 : https://leetcode.cn/problems/longest-valid-parentheses/
class066/Code07_UniqueSubstringsWraparoundString.java:// 环绕字符串中唯一的子字符串
class066/Code07_UniqueSubstringsWraparoundString.java:// 定义字符串 base 为一个 "abcdefghijklmnopqrstuvwxyz" 无限环绕的字符串
class066/Code07_UniqueSubstringsWraparoundString.java:// 所以 base 看起来是这样的：
class066/Code07_UniqueSubstringsWraparoundString.java:// "..zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd.."
class066/Code07_UniqueSubstringsWraparoundString.java:// 给你一个字符串 s ，请你统计并返回 s 中有多少 不同非空子串 也在 base 中出现
class066/Code07_UniqueSubstringsWraparoundString.java:// 测试链接 : https://leetcode.cn/problems/unique-substrings-in-wraparound-string/
class066/Code08_DistinctSubsequencesII.java:// 不同的子序列 II
class066/Code08_DistinctSubsequencesII.java:// 给定一个字符串 s，计算 s 的 不同非空子序列 的个数
class066/Code08_DistinctSubsequencesII.java:// 因为结果可能很大，所以返回答案需要对 10^9 + 7 取余
class066/Code08_DistinctSubsequencesII.java:// 字符串的 子序列 是经由原字符串删除一些（也可能不删除）
class066/Code08_DistinctSubsequencesII.java:// 字符但不改变剩余字符相对位置的一个新字符串
class066/Code08_DistinctSubsequencesII.java:// 例如，"ace" 是 "abcde" 的一个子序列，但 "aec" 不是
class066/Code08_DistinctSubsequencesII.java:// 测试链接 : https://leetcode.cn/problems/distinct-subsequences-ii/
算法讲解067【必备】从递归入手二维动态规划
class067/Code01_MinimumPathSum.java:// 最小路径和
class067/Code01_MinimumPathSum.java:// 给定一个包含非负整数的 m x n 网格 grid
class067/Code01_MinimumPathSum.java:// 请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
class067/Code01_MinimumPathSum.java:// 说明：每次只能向下或者向右移动一步。
class067/Code01_MinimumPathSum.java:// 测试链接 : https://leetcode.cn/problems/minimum-path-sum/
class067/Code02_WordSearch.java:// 单词搜索（无法改成动态规划）
class067/Code02_WordSearch.java:// 给定一个 m x n 二维字符网格 board 和一个字符串单词 word
class067/Code02_WordSearch.java:// 如果 word 存在于网格中，返回 true ；否则，返回 false 。
class067/Code02_WordSearch.java:// 单词必须按照字母顺序，通过相邻的单元格内的字母构成
class067/Code02_WordSearch.java:// 其中"相邻"单元格是那些水平相邻或垂直相邻的单元格
class067/Code02_WordSearch.java:// 同一个单元格内的字母不允许被重复使用
class067/Code02_WordSearch.java:// 测试链接 : https://leetcode.cn/problems/word-search/
class067/Code03_LongestCommonSubsequence.java:// 最长公共子序列
class067/Code03_LongestCommonSubsequence.java:// 给定两个字符串text1和text2
class067/Code03_LongestCommonSubsequence.java:// 返回这两个字符串的最长 公共子序列 的长度
class067/Code03_LongestCommonSubsequence.java:// 如果不存在公共子序列，返回0
class067/Code03_LongestCommonSubsequence.java:// 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列
class067/Code03_LongestCommonSubsequence.java:// 测试链接 : https://leetcode.cn/problems/longest-common-subsequence/
class067/Code04_LongestPalindromicSubsequence.java:// 最长回文子序列
class067/Code04_LongestPalindromicSubsequence.java:// 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度
class067/Code04_LongestPalindromicSubsequence.java:// 测试链接 : https://leetcode.cn/problems/longest-palindromic-subsequence/
class067/Code05_NodenHeightNotLargerThanm.java:// 节点数为n高度不大于m的二叉树个数
class067/Code05_NodenHeightNotLargerThanm.java:// 现在有n个节点，计算出有多少个不同结构的二叉树
class067/Code05_NodenHeightNotLargerThanm.java:// 满足节点个数为n且树的高度不超过m的方案
class067/Code05_NodenHeightNotLargerThanm.java:// 因为答案很大，所以答案需要模上1000000007后输出
class067/Code05_NodenHeightNotLargerThanm.java:// 测试链接 : https://www.nowcoder.com/practice/aaefe5896cce4204b276e213e725f3ea
class067/Code05_NodenHeightNotLargerThanm.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class067/Code05_NodenHeightNotLargerThanm.java:// 这是输入输出处理效率很高的写法
class067/Code05_NodenHeightNotLargerThanm.java:// 提交以下所有代码，把主类名改成Main，可以直接通过
class067/Code06_LongestIncreasingPath.java:// 矩阵中的最长递增路径
class067/Code06_LongestIncreasingPath.java:// 给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度
class067/Code06_LongestIncreasingPath.java:// 对于每个单元格，你可以往上，下，左，右四个方向移动
class067/Code06_LongestIncreasingPath.java:// 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）
class067/Code06_LongestIncreasingPath.java:// 测试链接 : https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/
算法讲解068【必备】见识更多二维动态规划题目
class068/Code01_DistinctSubsequences.java:// 不同的子序列
class068/Code01_DistinctSubsequences.java:// 给你两个字符串s和t ，统计并返回在s的子序列中t出现的个数
class068/Code01_DistinctSubsequences.java:// 答案对1000000007取余
class068/Code01_DistinctSubsequences.java:// 测试链接 : https://leetcode.cn/problems/distinct-subsequences/
class068/Code02_EditDistance.java:// 编辑距离
class068/Code02_EditDistance.java:// 给你两个单词 word1 和 word2
class068/Code02_EditDistance.java:// 请返回将 word1 转换成 word2 所使用的最少代价
class068/Code02_EditDistance.java:// 你可以对一个单词进行如下三种操作：
class068/Code02_EditDistance.java:// 插入一个字符，代价a
class068/Code02_EditDistance.java:// 删除一个字符，代价b
class068/Code02_EditDistance.java:// 替换一个字符，代价c
class068/Code02_EditDistance.java:// 测试链接 : https://leetcode.cn/problems/edit-distance/
class068/Code03_InterleavingString.java:// 交错字符串
class068/Code03_InterleavingString.java:// 给定三个字符串 s1、s2、s3
class068/Code03_InterleavingString.java:// 请帮忙验证s3是否由s1和s2交错组成
class068/Code03_InterleavingString.java:// 测试链接 : https://leetcode.cn/problems/interleaving-string/
class068/Code04_FillCellsUseAllColorsWays.java:// 有效涂色问题
class068/Code04_FillCellsUseAllColorsWays.java:// 给定n、m两个参数
class068/Code04_FillCellsUseAllColorsWays.java:// 一共有n个格子，每个格子可以涂上一种颜色，颜色在m种里选
class068/Code04_FillCellsUseAllColorsWays.java:// 当涂满n个格子，并且m种颜色都使用了，叫一种有效方法
class068/Code04_FillCellsUseAllColorsWays.java:// 求一共有多少种有效的涂色方法
class068/Code04_FillCellsUseAllColorsWays.java:// 1 <= n, m <= 5000
class068/Code04_FillCellsUseAllColorsWays.java:// 结果比较大请 % 1000000007 之后返回
class068/Code04_FillCellsUseAllColorsWays.java:// 对数器验证
class068/Code05_MinimumDeleteBecomeSubstring.java:// 删除至少几个字符可以变成另一个字符串的子串
class068/Code05_MinimumDeleteBecomeSubstring.java:// 给定两个字符串s1和s2
class068/Code05_MinimumDeleteBecomeSubstring.java:// 返回s1至少删除多少字符可以成为s2的子串
class068/Code05_MinimumDeleteBecomeSubstring.java:// 对数器验证
算法讲解069【必备】从递归入手三维动态规划
class069/Code01_OnesAndZeroes.java:// 一和零(多维费用背包)
class069/Code01_OnesAndZeroes.java:// 给你一个二进制字符串数组 strs 和两个整数 m 和 n
class069/Code01_OnesAndZeroes.java:// 请你找出并返回 strs 的最大子集的长度
class069/Code01_OnesAndZeroes.java:// 该子集中 最多 有 m 个 0 和 n 个 1
class069/Code01_OnesAndZeroes.java:// 如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集
class069/Code01_OnesAndZeroes.java:// 测试链接 : https://leetcode.cn/problems/ones-and-zeroes/
class069/Code02_ProfitableSchemes.java:// 盈利计划(多维费用背包)
class069/Code02_ProfitableSchemes.java:// 集团里有 n 名员工，他们可以完成各种各样的工作创造利润
class069/Code02_ProfitableSchemes.java:// 第 i 种工作会产生 profit[i] 的利润，它要求 group[i] 名成员共同参与
class069/Code02_ProfitableSchemes.java:// 如果成员参与了其中一项工作，就不能参与另一项工作
class069/Code02_ProfitableSchemes.java:// 工作的任何至少产生 minProfit 利润的子集称为 盈利计划
class069/Code02_ProfitableSchemes.java:// 并且工作的成员总数最多为 n
class069/Code02_ProfitableSchemes.java:// 有多少种计划可以选择？因为答案很大，所以 返回结果模 10^9 + 7 的值。
class069/Code02_ProfitableSchemes.java:// 测试链接 : https://leetcode.cn/problems/profitable-schemes/
class069/Code03_KnightProbabilityInChessboard.java:// 骑士在棋盘上的概率
class069/Code03_KnightProbabilityInChessboard.java:// n * n的国际象棋棋盘上，一个骑士从单元格(row, col)开始，并尝试进行 k 次移动
class069/Code03_KnightProbabilityInChessboard.java:// 行和列从0开始，所以左上单元格是 (0,0)，右下单元格是 (n-1, n-1)
class069/Code03_KnightProbabilityInChessboard.java:// 象棋骑士有8种可能的走法。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格
class069/Code03_KnightProbabilityInChessboard.java:// 每次骑士要移动时，它都会随机从8种可能的移动中选择一种，然后移动到那里
class069/Code03_KnightProbabilityInChessboard.java:// 骑士继续移动，直到它走了 k 步或离开了棋盘
class069/Code03_KnightProbabilityInChessboard.java:// 返回 骑士在棋盘停止移动后仍留在棋盘上的概率 
class069/Code03_KnightProbabilityInChessboard.java:// 测试链接 : https://leetcode.cn/problems/knight-probability-in-chessboard/
class069/Code04_PathsDivisibleByK.java:// 矩阵中和能被 K 整除的路径
class069/Code04_PathsDivisibleByK.java:// 给一个下标从0开始的 n * m 整数矩阵 grid 和一个整数 k
class069/Code04_PathsDivisibleByK.java:// 从起点(0,0)出发，每步只能往下或者往右，你想要到达终点(m-1, n-1)
class069/Code04_PathsDivisibleByK.java:// 请你返回路径和能被 k 整除的路径数目
class069/Code04_PathsDivisibleByK.java:// 由于答案可能很大，返回答案对10^9+7取余的结果
class069/Code04_PathsDivisibleByK.java:// 测试链接 : https://leetcode.cn/problems/paths-in-matrix-whose-sum-is-divisible-by-k/
class069/Code05_ScrambleString.java:// 扰乱字符串
class069/Code05_ScrambleString.java:// 使用下面描述的算法可以扰乱字符串 s 得到字符串 t ：
class069/Code05_ScrambleString.java:// 步骤1 : 如果字符串的长度为 1 ，算法停止
class069/Code05_ScrambleString.java:// 步骤2 : 如果字符串的长度 > 1 ，执行下述步骤：
class069/Code05_ScrambleString.java://        在一个随机下标处将字符串分割成两个非空的子字符串
class069/Code05_ScrambleString.java://        已知字符串s，则可以将其分成两个子字符串x和y且满足s=x+y
class069/Code05_ScrambleString.java://        可以决定是要 交换两个子字符串 还是要 保持这两个子字符串的顺序不变
class069/Code05_ScrambleString.java://        即s可能是 s = x + y 或者 s = y + x
class069/Code05_ScrambleString.java://        在x和y这两个子字符串上继续从步骤1开始递归执行此算法
class069/Code05_ScrambleString.java:// 给你两个 长度相等 的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串
class069/Code05_ScrambleString.java:// 如果是，返回true ；否则，返回false
class069/Code05_ScrambleString.java:// 测试链接 : https://leetcode.cn/problems/scramble-string/
算法讲解070【必备】子数组最大累加和问题与扩展-上
class070/Code01_MaximumSubarray.java:// 子数组最大累加和
class070/Code01_MaximumSubarray.java:// 给你一个整数数组 nums
class070/Code01_MaximumSubarray.java:// 返回非空子数组的最大累加和
class070/Code01_MaximumSubarray.java:// 测试链接 : https://leetcode.cn/problems/maximum-subarray/
class070/Code02_HouseRobber.java:// 数组中不能选相邻元素的最大累加和
class070/Code02_HouseRobber.java:// 给定一个数组，可以随意选择数字
class070/Code02_HouseRobber.java:// 但是不能选择相邻的数字，返回能得到的最大累加和
class070/Code02_HouseRobber.java:// 测试链接 : https://leetcode.cn/problems/house-robber/
class070/Code03_MaximumSumCircularSubarray.java:// 环形数组的子数组最大累加和
class070/Code03_MaximumSumCircularSubarray.java:// 给定一个数组nums，长度为n
class070/Code03_MaximumSumCircularSubarray.java:// nums是一个环形数组，下标0和下标n-1是连在一起的
class070/Code03_MaximumSumCircularSubarray.java:// 返回环形数组中，子数组最大累加和
class070/Code03_MaximumSumCircularSubarray.java:// 测试链接 : https://leetcode.cn/problems/maximum-sum-circular-subarray/
class070/Code04_HouseRobberII.java:// 环形数组中不能选相邻元素的最大累加和
class070/Code04_HouseRobberII.java:// 给定一个数组nums，长度为n
class070/Code04_HouseRobberII.java:// nums是一个环形数组，下标0和下标n-1是连在一起的
class070/Code04_HouseRobberII.java:// 可以随意选择数字，但是不能选择相邻的数字
class070/Code04_HouseRobberII.java:// 返回能得到的最大累加和
class070/Code04_HouseRobberII.java:// 测试链接 : https://leetcode.cn/problems/house-robber-ii/
class070/Code05_HouseRobberIV.java:// 打家劫舍 IV
class070/Code05_HouseRobberIV.java:// 沿街有一排连续的房屋。每间房屋内都藏有一定的现金
class070/Code05_HouseRobberIV.java:// 现在有一位小偷计划从这些房屋中窃取现金
class070/Code05_HouseRobberIV.java:// 由于相邻的房屋装有相互连通的防盗系统，所以小偷不会窃取相邻的房屋
class070/Code05_HouseRobberIV.java:// 小偷的 窃取能力 定义为他在窃取过程中能从单间房屋中窃取的 最大金额
class070/Code05_HouseRobberIV.java:// 给你一个整数数组 nums 表示每间房屋存放的现金金额
class070/Code05_HouseRobberIV.java:// 第i间房屋中放有nums[i]的钱数
class070/Code05_HouseRobberIV.java:// 另给你一个整数k，表示小偷需要窃取至少 k 间房屋
class070/Code05_HouseRobberIV.java:// 返回小偷需要的最小窃取能力值
class070/Code05_HouseRobberIV.java:// 测试链接 : https://leetcode.cn/problems/house-robber-iv/
class070/Code06_MaximumSubmatrix.java:// 子矩阵最大累加和问题
class070/Code06_MaximumSubmatrix.java:// 给定一个二维数组grid，找到其中子矩阵的最大累加和
class070/Code06_MaximumSubmatrix.java:// 返回拥有最大累加和的子矩阵左上角和右下角坐标
class070/Code06_MaximumSubmatrix.java:// 如果有多个子矩阵都有最大累加和，返回哪一个都可以
class070/Code06_MaximumSubmatrix.java:// 测试链接 : https://leetcode.cn/problems/max-submatrix-lcci/
算法讲解071【必备】子数组最大累加和问题与扩展-下
class071/Code01_MaximumProductSubarray.java:// 乘积最大子数组
class071/Code01_MaximumProductSubarray.java:// 给你一个整数数组 nums
class071/Code01_MaximumProductSubarray.java:// 请你找出数组中乘积最大的非空连续子数组
class071/Code01_MaximumProductSubarray.java:// 并返回该子数组所对应的乘积
class071/Code01_MaximumProductSubarray.java:// 测试链接 : https://leetcode.cn/problems/maximum-product-subarray/
class071/Code02_MaxSumDividedBy7.java:// 子序列累加和必须被7整除的最大累加和
class071/Code02_MaxSumDividedBy7.java:// 给定一个非负数组nums，
class071/Code02_MaxSumDividedBy7.java:// 可以任意选择数字组成子序列，但是子序列的累加和必须被7整除
class071/Code02_MaxSumDividedBy7.java:// 返回最大累加和
class071/Code02_MaxSumDividedBy7.java:// 对数器验证
class071/Code03_MagicScrollProbelm.java:// 魔法卷轴
class071/Code03_MagicScrollProbelm.java:// 给定一个数组nums，其中可能有正、负、0
class071/Code03_MagicScrollProbelm.java:// 每个魔法卷轴可以把nums中连续的一段全变成0
class071/Code03_MagicScrollProbelm.java:// 你希望数组整体的累加和尽可能大
class071/Code03_MagicScrollProbelm.java:// 卷轴使不使用、使用多少随意，但一共只有2个魔法卷轴
class071/Code03_MagicScrollProbelm.java:// 请返回数组尽可能大的累加和
class071/Code03_MagicScrollProbelm.java:// 对数器验证
class071/Code04_MaximumSum3UnoverlappingSubarrays.java:// 三个无重叠子数组的最大和
class071/Code04_MaximumSum3UnoverlappingSubarrays.java:// 给你一个整数数组 nums 和一个整数 k
class071/Code04_MaximumSum3UnoverlappingSubarrays.java:// 找出三个长度为 k 、互不重叠、且全部数字和（3 * k 项）最大的子数组
class071/Code04_MaximumSum3UnoverlappingSubarrays.java:// 并返回这三个子数组
class071/Code04_MaximumSum3UnoverlappingSubarrays.java:// 以下标的数组形式返回结果，数组中的每一项分别指示每个子数组的起始位置
class071/Code04_MaximumSum3UnoverlappingSubarrays.java:// 如果有多个结果，返回字典序最小的一个
class071/Code04_MaximumSum3UnoverlappingSubarrays.java:// 测试链接 : https://leetcode.cn/problems/maximum-sum-of-3-non-overlapping-subarrays/
class071/Code05_ReverseArraySubarrayMaxSum.java:// 可以翻转1次的情况下子数组最大累加和
class071/Code05_ReverseArraySubarrayMaxSum.java:// 给定一个数组nums，
class071/Code05_ReverseArraySubarrayMaxSum.java:// 现在允许你随意选择数组连续一段进行翻转，也就是子数组逆序的调整
class071/Code05_ReverseArraySubarrayMaxSum.java:// 比如翻转[1,2,3,4,5,6]的[2~4]范围，得到的是[1,2,5,4,3,6]
class071/Code05_ReverseArraySubarrayMaxSum.java:// 返回必须随意翻转1次之后，子数组的最大累加和
class071/Code05_ReverseArraySubarrayMaxSum.java:// 对数器验证
class071/Code06_DeleteOneNumberLengthKMaxSum.java:// 删掉1个数字后长度为k的子数组最大累加和
class071/Code06_DeleteOneNumberLengthKMaxSum.java:// 给定一个数组nums，求必须删除一个数字后的新数组中
class071/Code06_DeleteOneNumberLengthKMaxSum.java:// 长度为k的子数组最大累加和，删除哪个数字随意
class071/Code06_DeleteOneNumberLengthKMaxSum.java:// 对数器验证
算法讲解072【必备】最长递增子序列问题与扩展
class072/Code01_LongestIncreasingSubsequence.java:// 最长递增子序列和最长不下降子序列
class072/Code01_LongestIncreasingSubsequence.java:// 给定一个整数数组nums
class072/Code01_LongestIncreasingSubsequence.java:// 找到其中最长严格递增子序列长度、最长不下降子序列长度
class072/Code01_LongestIncreasingSubsequence.java:// 测试链接 : https://leetcode.cn/problems/longest-increasing-subsequence/
class072/Code02_RussianDollEnvelopes.java:// 俄罗斯套娃信封问题
class072/Code02_RussianDollEnvelopes.java:// 给你一个二维整数数组envelopes ，其中envelopes[i]=[wi, hi]
class072/Code02_RussianDollEnvelopes.java:// 表示第 i 个信封的宽度和高度
class072/Code02_RussianDollEnvelopes.java:// 当另一个信封的宽度和高度都比这个信封大的时候
class072/Code02_RussianDollEnvelopes.java:// 这个信封就可以放进另一个信封里，如同俄罗斯套娃一样
class072/Code02_RussianDollEnvelopes.java:// 请计算 最多能有多少个信封能组成一组“俄罗斯套娃”信封
class072/Code02_RussianDollEnvelopes.java:// 即可以把一个信封放到另一个信封里面，注意不允许旋转信封
class072/Code02_RussianDollEnvelopes.java:// 测试链接 : https://leetcode.cn/problems/russian-doll-envelopes/
class072/Code03_MinimumOperationsToMakeArraykIncreasing.java:// 使数组K递增的最少操作次数
class072/Code03_MinimumOperationsToMakeArraykIncreasing.java:// 给你一个下标从0开始包含n个正整数的数组arr，和一个正整数k
class072/Code03_MinimumOperationsToMakeArraykIncreasing.java:// 如果对于每个满足 k <= i <= n-1 的下标 i
class072/Code03_MinimumOperationsToMakeArraykIncreasing.java:// 都有 arr[i-k] <= arr[i] ，那么称 arr 是K递增的
class072/Code03_MinimumOperationsToMakeArraykIncreasing.java:// 每一次操作中，你可以选择一个下标i并将arr[i]改成任意正整数
class072/Code03_MinimumOperationsToMakeArraykIncreasing.java:// 请你返回对于给定的 k ，使数组变成K递增的最少操作次数
class072/Code03_MinimumOperationsToMakeArraykIncreasing.java:// 测试链接 : https://leetcode.cn/problems/minimum-operations-to-make-the-array-k-increasing/
class072/Code04_MaximumLengthOfPairChain.java:// 最长数对链
class072/Code04_MaximumLengthOfPairChain.java:// 给你一个由n个数对组成的数对数组pairs
class072/Code04_MaximumLengthOfPairChain.java:// 其中 pairs[i] = [lefti, righti] 且 lefti < righti
class072/Code04_MaximumLengthOfPairChain.java:// 现在，我们定义一种 跟随 关系，当且仅当 b < c 时
class072/Code04_MaximumLengthOfPairChain.java:// 数对 p2 = [c, d] 才可以跟在 p1 = [a, b] 后面
class072/Code04_MaximumLengthOfPairChain.java:// 我们用这种形式来构造 数对链
class072/Code04_MaximumLengthOfPairChain.java:// 找出并返回能够形成的最长数对链的长度
class072/Code04_MaximumLengthOfPairChain.java:// 测试链接 : https://leetcode.cn/problems/maximum-length-of-pair-chain/
class072/Code05_LongestNoDecreaseModifyKSubarray.java:// 有一次修改机会的最长不下降子序列
class072/Code05_LongestNoDecreaseModifyKSubarray.java:// 给定一个长度为n的数组arr，和一个整数k
class072/Code05_LongestNoDecreaseModifyKSubarray.java:// 只有一次机会可以将其中连续的k个数全修改成任意一个值
class072/Code05_LongestNoDecreaseModifyKSubarray.java:// 这次机会你可以用也可以不用，请返回最长不下降子序列长度
class072/Code05_LongestNoDecreaseModifyKSubarray.java:// 1 <= k, n <= 10^5
class072/Code05_LongestNoDecreaseModifyKSubarray.java:// 1 <= arr[i] <= 10^6
class072/Code05_LongestNoDecreaseModifyKSubarray.java:// 测试链接 : https://www.luogu.com.cn/problem/P8776
class072/Code05_LongestNoDecreaseModifyKSubarray.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class072/Code05_LongestNoDecreaseModifyKSubarray.java:// 这是输入输出处理效率很高的写法
class072/Code05_LongestNoDecreaseModifyKSubarray.java:// 提交以下的所有代码，并把主类名改成"Main"，可以直接通过
算法讲解073【必备】背包dp-01背包、有依赖的背包
class073/Code01_01Knapsack.java:// 01背包(模版)
class073/Code01_01Knapsack.java:// 给定一个正数t，表示背包的容量
class073/Code01_01Knapsack.java:// 有m个货物，每个货物可以选择一次
class073/Code01_01Knapsack.java:// 每个货物有自己的体积costs[i]和价值values[i]
class073/Code01_01Knapsack.java:// 返回在不超过总容量的情况下，怎么挑选货物能达到价值最大
class073/Code01_01Knapsack.java:// 返回最大的价值
class073/Code01_01Knapsack.java:// 测试链接 : https://www.luogu.com.cn/problem/P1048
class073/Code01_01Knapsack.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class073/Code01_01Knapsack.java:// 这是输入输出处理效率很高的写法
class073/Code01_01Knapsack.java:// 提交以下的所有代码，并把主类名改成"Main"，可以直接通过
class073/Code02_BuyGoodsHaveDiscount.java:// 夏季特惠
class073/Code02_BuyGoodsHaveDiscount.java:// 某公司游戏平台的夏季特惠开始了，你决定入手一些游戏
class073/Code02_BuyGoodsHaveDiscount.java:// 现在你一共有X元的预算，平台上所有的 n 个游戏均有折扣
class073/Code02_BuyGoodsHaveDiscount.java:// 标号为 i 的游戏的原价a_i元，现价只要b_i元
class073/Code02_BuyGoodsHaveDiscount.java:// 也就是说该游戏可以优惠 a_i - b_i，并且你购买该游戏能获得快乐值为w_i
class073/Code02_BuyGoodsHaveDiscount.java:// 由于优惠的存在，你可能做出一些冲动消费导致最终买游戏的总费用超过预算
class073/Code02_BuyGoodsHaveDiscount.java:// 只要满足 : 获得的总优惠金额不低于超过预算的总金额
class073/Code02_BuyGoodsHaveDiscount.java:// 那在心理上就不会觉得吃亏。
class073/Code02_BuyGoodsHaveDiscount.java:// 现在你希望在心理上不觉得吃亏的前提下，获得尽可能多的快乐值。
class073/Code02_BuyGoodsHaveDiscount.java:// 测试链接 : https://leetcode.cn/problems/tJau2o/
class073/Code02_BuyGoodsHaveDiscount.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class073/Code02_BuyGoodsHaveDiscount.java:// 这是输入输出处理效率很高的写法
class073/Code02_BuyGoodsHaveDiscount.java:// 提交以下的所有代码，并把主类名改成"Main"，可以直接通过
class073/Code03_TargetSum.java:// 目标和
class073/Code03_TargetSum.java:// 给你一个非负整数数组 nums 和一个整数 target 。
class073/Code03_TargetSum.java:// 向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数
class073/Code03_TargetSum.java:// 可以构造一个表达式
class073/Code03_TargetSum.java:// 例如nums=[2, 1]，可以在2之前添加'+' ，在1之前添加'-'
class073/Code03_TargetSum.java:// 然后串联起来得到表达式 "+2-1" 。
class073/Code03_TargetSum.java:// 返回可以通过上述方法构造的，运算结果等于 target 的不同表达式的数目
class073/Code03_TargetSum.java:// 测试链接 : https://leetcode.cn/problems/target-sum/
class073/Code04_LastStoneWeightII.java:// 最后一块石头的重量 II
class073/Code04_LastStoneWeightII.java:// 有一堆石头，用整数数组 stones 表示
class073/Code04_LastStoneWeightII.java:// 其中 stones[i] 表示第 i 块石头的重量。
class073/Code04_LastStoneWeightII.java:// 每一回合，从中选出任意两块石头，然后将它们一起粉碎
class073/Code04_LastStoneWeightII.java:// 假设石头的重量分别为 x 和 y，且 x <= y
class073/Code04_LastStoneWeightII.java:// 那么粉碎的可能结果如下：
class073/Code04_LastStoneWeightII.java:// 如果 x == y，那么两块石头都会被完全粉碎；
class073/Code04_LastStoneWeightII.java:// 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x
class073/Code04_LastStoneWeightII.java:// 最后，最多只会剩下一块 石头，返回此石头 最小的可能重量
class073/Code04_LastStoneWeightII.java:// 如果没有石头剩下，就返回 0
class073/Code04_LastStoneWeightII.java:// 测试链接 : https://leetcode.cn/problems/last-stone-weight-ii/
class073/Code05_DependentKnapsack.java:// 有依赖的背包(模版)
class073/Code05_DependentKnapsack.java:// 物品分为两大类：主件和附件
class073/Code05_DependentKnapsack.java:// 主件的购买没有限制，钱够就可以；附件的购买有限制，该附件所归属的主件先购买，才能购买这个附件
class073/Code05_DependentKnapsack.java:// 例如，若想买打印机或扫描仪这样的附件，必须先购买电脑这个主件
class073/Code05_DependentKnapsack.java:// 以下是一些主件及其附件的展示：
class073/Code05_DependentKnapsack.java:// 电脑：打印机，扫描仪 | 书柜：图书 | 书桌：台灯，文具 | 工作椅：无附件
class073/Code05_DependentKnapsack.java:// 每个主件最多有2个附件，并且附件不会再有附件，主件购买后，怎么去选择归属附件完全随意，钱够就可以
class073/Code05_DependentKnapsack.java:// 所有的物品编号都在1~m之间，每个物品有三个信息：价格v、重要度p、归属q
class073/Code05_DependentKnapsack.java:// 价格就是花费，价格 * 重要度 就是收益，归属就是该商品是依附于哪个编号的主件
class073/Code05_DependentKnapsack.java:// 比如一件商品信息为[300,2,6]，花费300，收益600，该商品是6号主件商品的附件
class073/Code05_DependentKnapsack.java:// 再比如一件商品信息[100,4,0]，花费100，收益400，该商品自身是主件(q==0)
class073/Code05_DependentKnapsack.java:// 给定m件商品的信息，给定总钱数n，返回在不违反购买规则的情况下最大的收益
class073/Code05_DependentKnapsack.java:// 测试链接 : https://www.luogu.com.cn/problem/P1064
class073/Code05_DependentKnapsack.java:// 测试链接 : https://www.nowcoder.com/practice/f9c6f980eeec43ef85be20755ddbeaf4
class073/Code05_DependentKnapsack.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class073/Code05_DependentKnapsack.java:// 这是输入输出处理效率很高的写法
class073/Code05_DependentKnapsack.java:// 提交以下的所有代码，并把主类名改成"Main"，可以直接通过
class073/Code06_TopKMinimumSubsequenceSum.java:// 非负数组前k个最小的子序列累加和
class073/Code06_TopKMinimumSubsequenceSum.java:// 给定一个数组nums，含有n个数字，都是非负数
class073/Code06_TopKMinimumSubsequenceSum.java:// 给定一个正数k，返回所有子序列中累加和最小的前k个累加和
class073/Code06_TopKMinimumSubsequenceSum.java:// 子序列是包含空集的
class073/Code06_TopKMinimumSubsequenceSum.java:// 1 <= n <= 10^5
class073/Code06_TopKMinimumSubsequenceSum.java:// 1 <= nums[i] <= 10^6
class073/Code06_TopKMinimumSubsequenceSum.java:// 1 <= k <= 10^5
class073/Code06_TopKMinimumSubsequenceSum.java:// 注意这个数据量，用01背包的解法是不行的，时间复杂度太高了
class073/Code06_TopKMinimumSubsequenceSum.java:// 对数器验证
算法讲解074【必备】背包dp-分组背包、完全背包
class074/Code01_PartitionedKnapsack.java:// 分组背包(模版)
class074/Code01_PartitionedKnapsack.java:// 给定一个正数m表示背包的容量，有n个货物可供挑选
class074/Code01_PartitionedKnapsack.java:// 每个货物有自己的体积(容量消耗)、价值(获得收益)、组号(分组)
class074/Code01_PartitionedKnapsack.java:// 同一个组的物品只能挑选1件，所有挑选物品的体积总和不能超过背包容量
class074/Code01_PartitionedKnapsack.java:// 怎么挑选货物能达到价值最大，返回最大的价值
class074/Code01_PartitionedKnapsack.java:// 测试链接 : https://www.luogu.com.cn/problem/P1757
class074/Code01_PartitionedKnapsack.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class074/Code01_PartitionedKnapsack.java:// 这是输入输出处理效率很高的写法
class074/Code01_PartitionedKnapsack.java:// 提交以下的所有代码，并把主类名改成"Main"，可以直接通过
class074/Code02_MaximumValueOfKcoinsFromPiles.java:// 从栈中取出K个硬币的最大面值和
class074/Code02_MaximumValueOfKcoinsFromPiles.java:// 一张桌子上总共有 n 个硬币 栈 。每个栈有 正整数 个带面值的硬币
class074/Code02_MaximumValueOfKcoinsFromPiles.java:// 每一次操作中，你可以从任意一个栈的 顶部 取出 1 个硬币，从栈中移除它，并放入你的钱包里
class074/Code02_MaximumValueOfKcoinsFromPiles.java:// 给你一个列表 piles ，其中 piles[i] 是一个整数数组
class074/Code02_MaximumValueOfKcoinsFromPiles.java:// 分别表示第 i 个栈里 从顶到底 的硬币面值。同时给你一个正整数 k
class074/Code02_MaximumValueOfKcoinsFromPiles.java:// 请你返回在 恰好 进行 k 次操作的前提下，你钱包里硬币面值之和 最大为多少
class074/Code02_MaximumValueOfKcoinsFromPiles.java:// 测试链接 : https://leetcode.cn/problems/maximum-value-of-k-coins-from-piles/
class074/Code03_UnboundedKnapsack.java:// 完全背包(模版)
class074/Code03_UnboundedKnapsack.java:// 给定一个正数t，表示背包的容量
class074/Code03_UnboundedKnapsack.java:// 有m种货物，每种货物可以选择任意个
class074/Code03_UnboundedKnapsack.java:// 每种货物都有体积costs[i]和价值values[i]
class074/Code03_UnboundedKnapsack.java:// 返回在不超过总容量的情况下，怎么挑选货物能达到价值最大
class074/Code03_UnboundedKnapsack.java:// 返回最大的价值
class074/Code03_UnboundedKnapsack.java:// 测试链接 : https://www.luogu.com.cn/problem/P1616
class074/Code03_UnboundedKnapsack.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class074/Code03_UnboundedKnapsack.java:// 这是输入输出处理效率很高的写法
class074/Code03_UnboundedKnapsack.java:// 提交以下的所有代码，并把主类名改成"Main"，可以直接通过
class074/Code04_RegularExpressionMatching.java:// 正则表达式匹配
class074/Code04_RegularExpressionMatching.java:// 给你字符串s、字符串p
class074/Code04_RegularExpressionMatching.java:// s中一定不含有'.'、'*'字符，p中可能含有'.'、'*'字符
class074/Code04_RegularExpressionMatching.java:// '.' 表示可以变成任意字符，数量1个
class074/Code04_RegularExpressionMatching.java:// '*' 表示可以让 '*' 前面那个字符数量任意(甚至可以是0个)
class074/Code04_RegularExpressionMatching.java:// p中即便有'*'，一定不会出现以'*'开头的情况，也一定不会出现多个'*'相邻的情况(无意义)
class074/Code04_RegularExpressionMatching.java:// 请实现一个支持 '.' 和 '*' 的正则表达式匹配
class074/Code04_RegularExpressionMatching.java:// 返回p的整个字符串能不能匹配出s的整个字符串
class074/Code04_RegularExpressionMatching.java:// 测试链接 : https://leetcode.cn/problems/regular-expression-matching/
class074/Code05_WildcardMatching.java:// 通配符匹配（和题目4高度相似，只是边界条件不同而已，而且更简单）
class074/Code05_WildcardMatching.java:// 给你字符串s、字符串p
class074/Code05_WildcardMatching.java:// s中一定不含有'?'、'*'字符，p中可能含有'?'、'*'字符
class074/Code05_WildcardMatching.java:// '?' 表示可以变成任意字符，数量1个
class074/Code05_WildcardMatching.java:// '*' 表示可以匹配任何字符串
class074/Code05_WildcardMatching.java:// 请实现一个支持 '?' 和 '*' 的通配符匹配
class074/Code05_WildcardMatching.java:// 返回p的整个字符串能不能匹配出s的整个字符串
class074/Code05_WildcardMatching.java:// 测试链接 : https://leetcode.cn/problems/wildcard-matching/
class074/Code06_BuyingHayMinimumCost.java:// 购买足量干草的最小花费
class074/Code06_BuyingHayMinimumCost.java:// 有n个提供干草的公司，每个公司都有两个信息
class074/Code06_BuyingHayMinimumCost.java:// cost[i]代表购买1次产品需要花的钱
class074/Code06_BuyingHayMinimumCost.java:// val[i]代表购买1次产品所获得的干草数量
class074/Code06_BuyingHayMinimumCost.java:// 每个公司的产品都可以购买任意次
class074/Code06_BuyingHayMinimumCost.java:// 你一定要至少购买h数量的干草，返回最少要花多少钱
class074/Code06_BuyingHayMinimumCost.java:// 测试链接 : https://www.luogu.com.cn/problem/P2918
class074/Code06_BuyingHayMinimumCost.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class074/Code06_BuyingHayMinimumCost.java:// 这是输入输出处理效率很高的写法
class074/Code06_BuyingHayMinimumCost.java:// 提交以下的所有代码，并把主类名改成"Main"，可以直接通过
算法讲解075【必备】背包dp-多重背包、混合背包
class075/Code01_BoundedKnapsack.java:// 多重背包不进行枚举优化
class075/Code01_BoundedKnapsack.java:// 宝物筛选
class075/Code01_BoundedKnapsack.java:// 一共有n种货物, 背包容量为t
class075/Code01_BoundedKnapsack.java:// 每种货物的价值(v[i])、重量(w[i])、数量(c[i])都给出
class075/Code01_BoundedKnapsack.java:// 请返回选择货物不超过背包容量的情况下，能得到的最大的价值
class075/Code01_BoundedKnapsack.java:// 测试链接 : https://www.luogu.com.cn/problem/P1776
class075/Code01_BoundedKnapsack.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class075/Code01_BoundedKnapsack.java:// 这是输入输出处理效率很高的写法
class075/Code01_BoundedKnapsack.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class075/Code02_BoundedKnapsackWithBinarySplitting.java:// 多重背包通过二进制分组转化成01背包(模版)
class075/Code02_BoundedKnapsackWithBinarySplitting.java:// 宝物筛选
class075/Code02_BoundedKnapsackWithBinarySplitting.java:// 一共有n种货物, 背包容量为t
class075/Code02_BoundedKnapsackWithBinarySplitting.java:// 每种货物的价值(v[i])、重量(w[i])、数量(c[i])都给出
class075/Code02_BoundedKnapsackWithBinarySplitting.java:// 请返回选择货物不超过背包容量的情况下，能得到的最大的价值
class075/Code02_BoundedKnapsackWithBinarySplitting.java:// 测试链接 : https://www.luogu.com.cn/problem/P1776
class075/Code02_BoundedKnapsackWithBinarySplitting.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class075/Code02_BoundedKnapsackWithBinarySplitting.java:// 这是输入输出处理效率很高的写法
class075/Code02_BoundedKnapsackWithBinarySplitting.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class075/Code03_CherryBlossomViewing.java:// 观赏樱花
class075/Code03_CherryBlossomViewing.java:// 给定一个背包的容量t，一共有n种货物，并且给定每种货物的信息
class075/Code03_CherryBlossomViewing.java:// 花费(cost)、价值(val)、数量(cnt)
class075/Code03_CherryBlossomViewing.java:// 如果cnt == 0，代表这种货物可以无限选择
class075/Code03_CherryBlossomViewing.java:// 如果cnt > 0，那么cnt代表这种货物的数量
class075/Code03_CherryBlossomViewing.java:// 挑选货物的总容量在不超过t的情况下，返回能得到的最大价值
class075/Code03_CherryBlossomViewing.java:// 背包容量不超过1000，每一种货物的花费都>0
class075/Code03_CherryBlossomViewing.java:// 测试链接 : https://www.luogu.com.cn/problem/P1833
class075/Code03_CherryBlossomViewing.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class075/Code03_CherryBlossomViewing.java:// 这是输入输出处理效率很高的写法
class075/Code03_CherryBlossomViewing.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class075/Code03_CherryBlossomViewing.java:// 完全背包转化为多重背包
class075/Code03_CherryBlossomViewing.java:// 再把多重背包通过二进制分组转化为01背包
class075/Code04_BoundedKnapsackWithMonotonicQueue.java:// 多重背包单调队列优化
class075/Code04_BoundedKnapsackWithMonotonicQueue.java:// 宝物筛选
class075/Code04_BoundedKnapsackWithMonotonicQueue.java:// 一共有n种货物, 背包容量为t
class075/Code04_BoundedKnapsackWithMonotonicQueue.java:// 每种货物的价值(v[i])、重量(w[i])、数量(c[i])都给出
class075/Code04_BoundedKnapsackWithMonotonicQueue.java:// 请返回选择货物不超过背包容量的情况下，能得到的最大的价值
class075/Code04_BoundedKnapsackWithMonotonicQueue.java:// 测试链接 : https://www.luogu.com.cn/problem/P1776
class075/Code04_BoundedKnapsackWithMonotonicQueue.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class075/Code04_BoundedKnapsackWithMonotonicQueue.java:// 这是输入输出处理效率很高的写法
class075/Code04_BoundedKnapsackWithMonotonicQueue.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class075/Code05_MixedKnapsack.java:// 混合背包 + 多重背包普通窗口优化
class075/Code05_MixedKnapsack.java:// 能成功找零的钱数种类
class075/Code05_MixedKnapsack.java:// 每一种货币都给定面值val[i]，和拥有的数量cnt[i]
class075/Code05_MixedKnapsack.java:// 想知道目前拥有的货币，在钱数为1、2、3...m时
class075/Code05_MixedKnapsack.java:// 能找零成功的钱数有多少
class075/Code05_MixedKnapsack.java:// 也就是说当钱数的范围是1~m
class075/Code05_MixedKnapsack.java:// 返回这个范围上有多少可以找零成功的钱数
class075/Code05_MixedKnapsack.java:// 比如只有3元的货币，数量是5张
class075/Code05_MixedKnapsack.java:// m = 10
class075/Code05_MixedKnapsack.java:// 那么在1~10范围上，只有钱数是3、6、9时，可以成功找零
class075/Code05_MixedKnapsack.java:// 所以返回3表示有3种钱数可以找零成功
class075/Code05_MixedKnapsack.java:// 测试链接 : http://poj.org/problem?id=1742
class075/Code05_MixedKnapsack.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class075/Code05_MixedKnapsack.java:// 这是输入输出处理效率很高的写法
class075/Code05_MixedKnapsack.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
算法讲解076【必备】区间dp-上
class076/Code01_MinimumInsertionToPalindrome.java:// 让字符串成为回文串的最少插入次数
class076/Code01_MinimumInsertionToPalindrome.java:// 给你一个字符串 s
class076/Code01_MinimumInsertionToPalindrome.java:// 每一次操作你都可以在字符串的任意位置插入任意字符
class076/Code01_MinimumInsertionToPalindrome.java:// 请你返回让s成为回文串的最少操作次数
class076/Code01_MinimumInsertionToPalindrome.java:// 测试链接 : https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/
class076/Code02_PredictTheWinner.java:// 预测赢家
class076/Code02_PredictTheWinner.java:// 给你一个整数数组 nums 。玩家 1 和玩家 2 基于这个数组设计了一个游戏
class076/Code02_PredictTheWinner.java:// 玩家 1 和玩家 2 轮流进行自己的回合，玩家 1 先手
class076/Code02_PredictTheWinner.java:// 开始时，两个玩家的初始分值都是 0
class076/Code02_PredictTheWinner.java:// 每一回合，玩家从数组的任意一端取一个数字
class076/Code02_PredictTheWinner.java:// 取到的数字将会从数组中移除，数组长度减1
class076/Code02_PredictTheWinner.java:// 玩家选中的数字将会加到他的得分上
class076/Code02_PredictTheWinner.java:// 当数组中没有剩余数字可取时游戏结束
class076/Code02_PredictTheWinner.java:// 如果玩家 1 能成为赢家，返回 true
class076/Code02_PredictTheWinner.java:// 如果两个玩家得分相等，同样认为玩家 1 是游戏的赢家，也返回 true
class076/Code02_PredictTheWinner.java:// 你可以假设每个玩家的玩法都会使他的分数最大化
class076/Code02_PredictTheWinner.java:// 测试链接 : https://leetcode.cn/problems/predict-the-winner/
class076/Code03_MinimumScoreTriangulationOfPolygon.java:// 多边形三角剖分的最低得分
class076/Code03_MinimumScoreTriangulationOfPolygon.java:// 你有一个凸的 n 边形，其每个顶点都有一个整数值
class076/Code03_MinimumScoreTriangulationOfPolygon.java:// 给定一个整数数组values，其中values[i]是第i个顶点的值(顺时针顺序)
class076/Code03_MinimumScoreTriangulationOfPolygon.java:// 假设将多边形 剖分 为 n - 2 个三角形
class076/Code03_MinimumScoreTriangulationOfPolygon.java:// 对于每个三角形，该三角形的值是顶点标记的乘积
class076/Code03_MinimumScoreTriangulationOfPolygon.java:// 三角剖分的分数是进行三角剖分后所有 n - 2 个三角形的值之和
class076/Code03_MinimumScoreTriangulationOfPolygon.java:// 返回 多边形进行三角剖分后可以得到的最低分
class076/Code03_MinimumScoreTriangulationOfPolygon.java:// 测试链接 : https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/
class076/Code04_MinimumCostToCutAStick.java:// 切棍子的最小成本
class076/Code04_MinimumCostToCutAStick.java:// 有一根长度为n个单位的木棍，棍上从0到n标记了若干位置
class076/Code04_MinimumCostToCutAStick.java:// 给你一个整数数组cuts，其中cuts[i]表示你需要将棍子切开的位置
class076/Code04_MinimumCostToCutAStick.java:// 你可以按顺序完成切割，也可以根据需要更改切割的顺序
class076/Code04_MinimumCostToCutAStick.java:// 每次切割的成本都是当前要切割的棍子的长度，切棍子的总成本是历次切割成本的总和
class076/Code04_MinimumCostToCutAStick.java:// 对棍子进行切割将会把一根木棍分成两根较小的木棍
class076/Code04_MinimumCostToCutAStick.java:// 这两根木棍的长度和就是切割前木棍的长度
class076/Code04_MinimumCostToCutAStick.java:// 返回切棍子的最小总成本
class076/Code04_MinimumCostToCutAStick.java:// 测试链接 : https://leetcode.cn/problems/minimum-cost-to-cut-a-stick/
class076/Code05_BurstBalloons.java:// 戳气球
class076/Code05_BurstBalloons.java:// 有 n 个气球，编号为0到n-1，每个气球上都标有一个数字，这些数字存在数组nums中
class076/Code05_BurstBalloons.java:// 现在要求你戳破所有的气球。戳破第 i 个气球
class076/Code05_BurstBalloons.java:// 你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币
class076/Code05_BurstBalloons.java:// 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号
class076/Code05_BurstBalloons.java:// 如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球
class076/Code05_BurstBalloons.java:// 求所能获得硬币的最大数量
class076/Code05_BurstBalloons.java:// 测试链接 : https://leetcode.cn/problems/burst-balloons/
class076/Code06_BooleanEvaluation.java:// 布尔运算
class076/Code06_BooleanEvaluation.java:// 给定一个布尔表达式和一个期望的布尔结果 result
class076/Code06_BooleanEvaluation.java:// 布尔表达式由 0 (false)、1 (true)、& (AND)、 | (OR) 和 ^ (XOR) 符号组成
class076/Code06_BooleanEvaluation.java:// 布尔表达式一定是正确的，不需要检查有效性
class076/Code06_BooleanEvaluation.java:// 但是其中没有任何括号来表示优先级
class076/Code06_BooleanEvaluation.java:// 你可以随意添加括号来改变逻辑优先级
class076/Code06_BooleanEvaluation.java:// 目的是让表达式能够最终得出result的结果
class076/Code06_BooleanEvaluation.java:// 返回最终得出result有多少种不同的逻辑计算顺序
class076/Code06_BooleanEvaluation.java:// 测试链接 : https://leetcode.cn/problems/boolean-evaluation-lcci/
算法讲解077【必备】区间dp-下
class077/Code01_MinimumInsertionsToMatch.java:// 完成配对需要的最少字符数量
class077/Code01_MinimumInsertionsToMatch.java:// 给定一个由'['、']'、'('，')'组成的字符串
class077/Code01_MinimumInsertionsToMatch.java:// 请问最少插入多少个括号就能使这个字符串的所有括号正确配对
class077/Code01_MinimumInsertionsToMatch.java:// 例如当前串是 "([[])"，那么插入一个']'即可满足
class077/Code01_MinimumInsertionsToMatch.java:// 输出最少需要插入多少个字符
class077/Code01_MinimumInsertionsToMatch.java:// 测试链接 : https://www.nowcoder.com/practice/e391767d80d942d29e6095a935a5b96b
class077/Code01_MinimumInsertionsToMatch.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class077/Code01_MinimumInsertionsToMatch.java:// 这是输入输出处理效率很高的写法
class077/Code01_MinimumInsertionsToMatch.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class077/Code02_Coloring.java:// 涂色 & 奇怪打印机
class077/Code02_Coloring.java:// 假设你有一条长度为5的木板，初始时没有涂过任何颜色
class077/Code02_Coloring.java:// 你希望把它的5个单位长度分别涂上红、绿、蓝、绿、红
class077/Code02_Coloring.java:// 用一个长度为5的字符串表示这个目标：RGBGR
class077/Code02_Coloring.java:// 每次你可以把一段连续的木板涂成一个给定的颜色，后涂的颜色覆盖先涂的颜色
class077/Code02_Coloring.java:// 例如第一次把木板涂成RRRRR
class077/Code02_Coloring.java:// 第二次涂成RGGGR
class077/Code02_Coloring.java:// 第三次涂成RGBGR，达到目标
class077/Code02_Coloring.java:// 返回尽量少的涂色次数
class077/Code02_Coloring.java:// 测试链接 : https://www.luogu.com.cn/problem/P4170
class077/Code02_Coloring.java:// 测试链接 : https://leetcode.cn/problems/strange-printer/
class077/Code02_Coloring.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class077/Code02_Coloring.java:// 这是输入输出处理效率很高的写法
class077/Code02_Coloring.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class077/Code03_HeightAndChoir.java:// 合唱队
class077/Code03_HeightAndChoir.java:// 具体描述情打开链接查看
class077/Code03_HeightAndChoir.java:// 测试链接 : https://www.luogu.com.cn/problem/P3205
class077/Code03_HeightAndChoir.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class077/Code03_HeightAndChoir.java:// 这是输入输出处理效率很高的写法
class077/Code03_HeightAndChoir.java:// 提交以下的所有代码，并把主类名改成"Main"，可以直接通过
class077/Code04_RemoveBoxes.java:// 移除盒子
class077/Code04_RemoveBoxes.java:// 给出一些不同颜色的盒子boxes，盒子的颜色由不同的正数表示
class077/Code04_RemoveBoxes.java:// 你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止
class077/Code04_RemoveBoxes.java:// 每一轮你可以移除具有相同颜色的连续 k 个盒子（k >= 1）
class077/Code04_RemoveBoxes.java:// 这样一轮之后你将得到 k * k 个积分
class077/Code04_RemoveBoxes.java:// 返回你能获得的最大积分总和
class077/Code04_RemoveBoxes.java:// 测试链接 : https://leetcode.cn/problems/remove-boxes/
class077/Code05_MinimumCostToMergeStones.java:// 合并石头的最低成本
class077/Code05_MinimumCostToMergeStones.java:// 有 n 堆石头排成一排，第 i 堆中有 stones[i] 块石头
class077/Code05_MinimumCostToMergeStones.java:// 每次 移动 需要将 连续的 k 堆石头合并为一堆，而这次移动的成本为这 k 堆中石头的总数
class077/Code05_MinimumCostToMergeStones.java:// 返回把所有石头合并成一堆的最低成本
class077/Code05_MinimumCostToMergeStones.java:// 如果无法合并成一堆返回-1
class077/Code05_MinimumCostToMergeStones.java:// 测试链接 : https://leetcode.cn/problems/minimum-cost-to-merge-stones/
class077/Code06_CountDifferentPalindromicSubsequences.java:// 统计不同回文子序列
class077/Code06_CountDifferentPalindromicSubsequences.java:// 给你一个字符串s，返回s中不同的非空回文子序列个数
class077/Code06_CountDifferentPalindromicSubsequences.java:// 由于答案可能很大，请你将答案对10^9+7取余后返回
class077/Code06_CountDifferentPalindromicSubsequences.java:// 测试链接 : https://leetcode.cn/problems/count-different-palindromic-subsequences/
算法讲解078【必备】树型dp-上
class078/Code01_LargestBstSubtree.java:// 最大BST子树
class078/Code01_LargestBstSubtree.java:// 给定一个二叉树，找到其中最大的二叉搜索树（BST）子树，并返回该子树的大小
class078/Code01_LargestBstSubtree.java:// 其中，最大指的是子树节点数最多的
class078/Code01_LargestBstSubtree.java:// 二叉搜索树（BST）中的所有节点都具备以下属性：
class078/Code01_LargestBstSubtree.java:// 左子树的值小于其父（根）节点的值
class078/Code01_LargestBstSubtree.java:// 右子树的值大于其父（根）节点的值
class078/Code01_LargestBstSubtree.java:// 注意：子树必须包含其所有后代
class078/Code01_LargestBstSubtree.java:// 测试链接 : https://leetcode.cn/problems/largest-bst-subtree/
class078/Code02_MaximumSumBst.java:// 二叉搜索子树的最大键值和
class078/Code02_MaximumSumBst.java:// 给你一棵以 root 为根的二叉树
class078/Code02_MaximumSumBst.java:// 请你返回 任意 二叉搜索子树的最大键值和
class078/Code02_MaximumSumBst.java:// 二叉搜索树的定义如下：
class078/Code02_MaximumSumBst.java:// 任意节点的左子树中的键值都 小于 此节点的键值
class078/Code02_MaximumSumBst.java:// 任意节点的右子树中的键值都 大于 此节点的键值
class078/Code02_MaximumSumBst.java:// 任意节点的左子树和右子树都是二叉搜索树
class078/Code02_MaximumSumBst.java:// 测试链接 : https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/
class078/Code03_DiameterOfBinaryTree.java:// 二叉树的直径
class078/Code03_DiameterOfBinaryTree.java:// 给你一棵二叉树的根节点，返回该树的直径
class078/Code03_DiameterOfBinaryTree.java:// 二叉树的 直径 是指树中任意两个节点之间最长路径的长度
class078/Code03_DiameterOfBinaryTree.java:// 这条路径可能经过也可能不经过根节点 root
class078/Code03_DiameterOfBinaryTree.java:// 两节点之间路径的 长度 由它们之间边数表示
class078/Code03_DiameterOfBinaryTree.java:// 测试链接 : https://leetcode.cn/problems/diameter-of-binary-tree/
class078/Code04_DistributeCoins.java:// 在二叉树中分配硬币
class078/Code04_DistributeCoins.java:// 给你一个有 n 个结点的二叉树的根结点 root
class078/Code04_DistributeCoins.java:// 其中树中每个结点 node 都对应有 node.val 枚硬币
class078/Code04_DistributeCoins.java:// 整棵树上一共有 n 枚硬币
class078/Code04_DistributeCoins.java:// 在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点
class078/Code04_DistributeCoins.java:// 移动可以是从父结点到子结点，或者从子结点移动到父结点
class078/Code04_DistributeCoins.java:// 返回使每个结点上 只有 一枚硬币所需的 最少 移动次数
class078/Code04_DistributeCoins.java:// 测试链接 : https://leetcode.cn/problems/distribute-coins-in-binary-tree/
class078/Code05_Dancing.java:// 没有上司的舞会
class078/Code05_Dancing.java:// 某大学有n个职员，编号为1...n
class078/Code05_Dancing.java:// 他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树
class078/Code05_Dancing.java:// 父结点就是子结点的直接上司
class078/Code05_Dancing.java:// 现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 
class078/Code05_Dancing.java:// 但是如果某个职员的直接上司来参加舞会了
class078/Code05_Dancing.java:// 那么这个职员就无论如何也不肯来参加舞会了
class078/Code05_Dancing.java:// 所以请你编程计算邀请哪些职员可以使快乐指数最大
class078/Code05_Dancing.java:// 返回最大的快乐指数。
class078/Code05_Dancing.java:// 测试链接 : https://www.luogu.com.cn/problem/P1352
class078/Code05_Dancing.java:// 本题和讲解037的题目7类似
class078/Code05_Dancing.java:// 链式链接 : https://leetcode.cn/problems/house-robber-iii/
class078/Code05_Dancing.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class078/Code05_Dancing.java:// 这是输入输出处理效率很高的写法
class078/Code05_Dancing.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class078/Code06_BinaryTreeCameras.java:// 监控二叉树
class078/Code06_BinaryTreeCameras.java:// 给定一个二叉树，我们在树的节点上安装摄像头
class078/Code06_BinaryTreeCameras.java:// 节点上的每个摄影头都可以监视其父对象、自身及其直接子对象
class078/Code06_BinaryTreeCameras.java:// 计算监控树的所有节点所需的最小摄像头数量
class078/Code06_BinaryTreeCameras.java:// 测试链接 : https://leetcode.cn/problems/binary-tree-cameras/
class078/Code07_PathSumIII.java:// 路径总和 III
class078/Code07_PathSumIII.java:// 给定一个二叉树的根节点 root ，和一个整数 targetSum
class078/Code07_PathSumIII.java:// 求该二叉树里节点值之和等于 targetSum 的 路径 的数目
class078/Code07_PathSumIII.java:// 路径 不需要从根节点开始，也不需要在叶子节点结束
class078/Code07_PathSumIII.java:// 但是路径方向必须是向下的（只能从父节点到子节点）
class078/Code07_PathSumIII.java:// 测试链接 : https://leetcode.cn/problems/path-sum-iii/
算法讲解079【必备】树型dp-下
class079/Code01_MinimumFuelCost.java:// 到达首都的最少油耗
class079/Code01_MinimumFuelCost.java:// 给你一棵 n 个节点的树（一个无向、连通、无环图）
class079/Code01_MinimumFuelCost.java:// 每个节点表示一个城市，编号从 0 到 n - 1 ，且恰好有 n - 1 条路
class079/Code01_MinimumFuelCost.java:// 0 是首都。给你一个二维整数数组 roads
class079/Code01_MinimumFuelCost.java:// 其中 roads[i] = [ai, bi] ，表示城市 ai 和 bi 之间有一条 双向路
class079/Code01_MinimumFuelCost.java:// 每个城市里有一个代表，他们都要去首都参加一个会议
class079/Code01_MinimumFuelCost.java:// 每座城市里有一辆车。给你一个整数 seats 表示每辆车里面座位的数目
class079/Code01_MinimumFuelCost.java:// 城市里的代表可以选择乘坐所在城市的车，或者乘坐其他城市的车
class079/Code01_MinimumFuelCost.java:// 相邻城市之间一辆车的油耗是一升汽油
class079/Code01_MinimumFuelCost.java:// 请你返回到达首都最少需要多少升汽油
class079/Code01_MinimumFuelCost.java:// 测试链接 : https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/
class079/Code02_LongestPathWithDifferentAdjacent.java:// 相邻字符不同的最长路径
class079/Code02_LongestPathWithDifferentAdjacent.java:// 给你一棵 树（即一个连通、无向、无环图），根节点是节点 0
class079/Code02_LongestPathWithDifferentAdjacent.java:// 这棵树由编号从 0 到 n - 1 的 n 个节点组成
class079/Code02_LongestPathWithDifferentAdjacent.java:// 用下标从 0 开始、长度为 n 的数组 parent 来表示这棵树
class079/Code02_LongestPathWithDifferentAdjacent.java:// 其中 parent[i] 是节点 i 的父节点
class079/Code02_LongestPathWithDifferentAdjacent.java:// 由于节点 0 是根节点，所以 parent[0] == -1
class079/Code02_LongestPathWithDifferentAdjacent.java:// 另给你一个字符串 s ，长度也是 n ，其中 s[i] 表示分配给节点 i 的字符
class079/Code02_LongestPathWithDifferentAdjacent.java:// 请你找出路径上任意一对相邻节点都没有分配到相同字符的 最长路径
class079/Code02_LongestPathWithDifferentAdjacent.java:// 并返回该路径的长度
class079/Code02_LongestPathWithDifferentAdjacent.java:// 测试链接 : https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/
class079/Code03_HeightRemovalQueries.java:// 移除子树后的二叉树高度
class079/Code03_HeightRemovalQueries.java:// 给你一棵 二叉树 的根节点 root ，树中有 n 个节点
class079/Code03_HeightRemovalQueries.java:// 每个节点都可以被分配一个从 1 到 n 且互不相同的值
class079/Code03_HeightRemovalQueries.java:// 另给你一个长度为 m 的数组 queries
class079/Code03_HeightRemovalQueries.java:// 你必须在树上执行 m 个 独立 的查询，其中第 i 个查询你需要执行以下操作：
class079/Code03_HeightRemovalQueries.java:// 从树中 移除 以 queries[i] 的值作为根节点的子树
class079/Code03_HeightRemovalQueries.java:// 题目所用测试用例保证 queries[i] 不等于根节点的值
class079/Code03_HeightRemovalQueries.java:// 返回一个长度为 m 的数组 answer
class079/Code03_HeightRemovalQueries.java:// 其中 answer[i] 是执行第 i 个查询后树的高度
class079/Code03_HeightRemovalQueries.java:// 注意：
class079/Code03_HeightRemovalQueries.java:// 查询之间是独立的，所以在每个查询执行后，树会回到其初始状态
class079/Code03_HeightRemovalQueries.java:// 树的高度是从根到树中某个节点的 最长简单路径中的边数
class079/Code03_HeightRemovalQueries.java:// 测试链接 : https://leetcode.cn/problems/height-of-binary-tree-after-subtree-removal-queries/
class079/Code04_MinimumScoreAfterRemovals.java:// 从树中删除边的最小分数
class079/Code04_MinimumScoreAfterRemovals.java:// 存在一棵无向连通树，树中有编号从0到n-1的n个节点，以及n-1条边
class079/Code04_MinimumScoreAfterRemovals.java:// 给你一个下标从0开始的整数数组nums长度为n，其中nums[i]表示第i个节点的值
class079/Code04_MinimumScoreAfterRemovals.java:// 另给你一个二维整数数组edges长度为n-1
class079/Code04_MinimumScoreAfterRemovals.java:// 其中 edges[i] = [ai, bi] 表示树中存在一条位于节点 ai 和 bi 之间的边
class079/Code04_MinimumScoreAfterRemovals.java:// 删除树中两条不同的边以形成三个连通组件，对于一种删除边方案，定义如下步骤以计算其分数：
class079/Code04_MinimumScoreAfterRemovals.java:// 分别获取三个组件每个组件中所有节点值的异或值
class079/Code04_MinimumScoreAfterRemovals.java:// 最大 异或值和 最小 异或值的 差值 就是这种删除边方案的分数
class079/Code04_MinimumScoreAfterRemovals.java:// 返回可能的最小分数
class079/Code04_MinimumScoreAfterRemovals.java:// 测试链接 : https://leetcode.cn/problems/minimum-score-after-removals-on-a-tree/
class079/Code05_CourseSelection1.java:// 选课
class079/Code05_CourseSelection1.java:// 在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习
class079/Code05_CourseSelection1.java:// 在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习
class079/Code05_CourseSelection1.java:// 现在有 N 门功课，每门课有个学分，每门课有一门或没有直接先修课
class079/Code05_CourseSelection1.java:// 若课程 a 是课程 b 的先修课即只有学完了课程 a，才能学习课程 b
class079/Code05_CourseSelection1.java:// 一个学生要从这些课程里选择 M 门课程学习
class079/Code05_CourseSelection1.java:// 问他能获得的最大学分是多少
class079/Code05_CourseSelection1.java:// 测试链接 : https://www.luogu.com.cn/problem/P2014
class079/Code05_CourseSelection1.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class079/Code05_CourseSelection1.java:// 这是输入输出处理效率很高的写法
class079/Code05_CourseSelection1.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class079/Code05_CourseSelection1.java:// 普通解法，邻接表建图 + 相对好懂的动态规划
class079/Code05_CourseSelection1.java:// 几乎所有题解都是普通解法的思路，只不过优化了常数时间、做了空间压缩
class079/Code05_CourseSelection1.java:// 但时间复杂度依然是O(n * 每个节点的孩子平均数量 * m的平方)
class079/Code05_CourseSelection2.java:// 选课
class079/Code05_CourseSelection2.java:// 在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习
class079/Code05_CourseSelection2.java:// 在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习
class079/Code05_CourseSelection2.java:// 现在有 N 门功课，每门课有个学分，每门课有一门或没有直接先修课
class079/Code05_CourseSelection2.java:// 若课程 a 是课程 b 的先修课即只有学完了课程 a，才能学习课程 b
class079/Code05_CourseSelection2.java:// 一个学生要从这些课程里选择 M 门课程学习
class079/Code05_CourseSelection2.java:// 问他能获得的最大学分是多少
class079/Code05_CourseSelection2.java:// 测试链接 : https://www.luogu.com.cn/problem/P2014
class079/Code05_CourseSelection2.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class079/Code05_CourseSelection2.java:// 这是输入输出处理效率很高的写法
class079/Code05_CourseSelection2.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class079/Code05_CourseSelection2.java:// 最优解，链式前向星建图 + dfn序的利用 + 巧妙定义下的尝试
class079/Code05_CourseSelection2.java:// 时间复杂度O(n*m)，觉得难可以跳过，这个最优解是非常巧妙和精彩的！
算法讲解080【必备】状压dp-上
class080/Code01_CanIWin.java:// 我能赢吗
class080/Code01_CanIWin.java:// 给定两个整数n和m
class080/Code01_CanIWin.java:// 两个玩家可以轮流从公共整数池中抽取从1到n的整数（不放回）
class080/Code01_CanIWin.java:// 抽取的整数会累加起来（两个玩家都算）
class080/Code01_CanIWin.java:// 谁在自己的回合让累加和 >= m，谁获胜
class080/Code01_CanIWin.java:// 若先出手的玩家能稳赢则返回true，否则返回false
class080/Code01_CanIWin.java:// 假设两位玩家游戏时都绝顶聪明，可以全盘为自己打算
class080/Code01_CanIWin.java:// 测试链接 : https://leetcode.cn/problems/can-i-win/
class080/Code02_MatchsticksToSquare.java:// 火柴拼正方形
class080/Code02_MatchsticksToSquare.java:// 你将得到一个整数数组 matchsticks
class080/Code02_MatchsticksToSquare.java:// 其中 matchsticks[i] 是第 i 个火柴棒的长度
class080/Code02_MatchsticksToSquare.java:// 你要用 所有的火柴棍 拼成一个正方形
class080/Code02_MatchsticksToSquare.java:// 你 不能折断 任何一根火柴棒，但你可以把它们连在一起，而且每根火柴棒必须 使用一次
class080/Code02_MatchsticksToSquare.java:// 如果你能拼出正方形，则返回 true ，否则返回 false
class080/Code02_MatchsticksToSquare.java:// 测试链接 : https://leetcode.cn/problems/matchsticks-to-square/
class080/Code03_PartitionToKEqualSumSubsets.java:// 划分为k个相等的子集
class080/Code03_PartitionToKEqualSumSubsets.java:// 给定一个整数数组  nums 和一个正整数 k，
class080/Code03_PartitionToKEqualSumSubsets.java:// 找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。
class080/Code03_PartitionToKEqualSumSubsets.java:// 测试链接 : https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/
class080/Code04_TSP1.java:// 售货员的难题 - TSP问题
class080/Code04_TSP1.java:// 某乡有n个村庄(1<=n<=20)，有一个售货员，他要到各个村庄去售货
class080/Code04_TSP1.java:// 各村庄之间的路程s(1<=s<=1000)是已知的
class080/Code04_TSP1.java:// 且A村到B村的路程，与B到A的路大多不同(有向带权图)
class080/Code04_TSP1.java:// 为了提高效率，他从商店出发到每个村庄一次，然后返回商店所在的村，
class080/Code04_TSP1.java:// 假设商店所在的村庄为1
class080/Code04_TSP1.java:// 他不知道选择什么样的路线才能使所走的路程最短
class080/Code04_TSP1.java:// 请你帮他选择一条最短的路
class080/Code04_TSP1.java:// 测试链接 : https://www.luogu.com.cn/problem/P1171
class080/Code04_TSP1.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class080/Code04_TSP1.java:// 这是输入输出处理效率很高的写法
class080/Code04_TSP1.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class080/Code04_TSP1.java:// 正常来说把MAXN改成20能通过，实现是正确的
class080/Code04_TSP1.java:// 问题是卡空间，而且c++的实现不卡空间，就卡java的实现
class080/Code04_TSP1.java:// 但如果把MAXN改成19，会有一个测试用例通过不了
class080/Code04_TSP1.java:// 那就差这么一点空间...看不起java是吗？
class080/Code04_TSP1.java:// 好，你歧视java实现，那就别怪我了
class080/Code04_TSP1.java:// 完全能通过的版本看Code04_TSP2的实现
class080/Code04_TSP2.java:// 售货员的难题 - TSP问题
class080/Code04_TSP2.java:// 某乡有n个村庄(1<=n<=20)，有一个售货员，他要到各个村庄去售货
class080/Code04_TSP2.java:// 各村庄之间的路程s(1<=s<=1000)是已知的
class080/Code04_TSP2.java:// 且A村到B村的路程，与B到A的路大多不同(有向带权图)
class080/Code04_TSP2.java:// 为了提高效率，他从商店出发到每个村庄一次，然后返回商店所在的村，
class080/Code04_TSP2.java:// 假设商店所在的村庄为1
class080/Code04_TSP2.java:// 他不知道选择什么样的路线才能使所走的路程最短
class080/Code04_TSP2.java:// 请你帮他选择一条最短的路
class080/Code04_TSP2.java:// 测试链接 : https://www.luogu.com.cn/problem/P1171
class080/Code04_TSP2.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class080/Code04_TSP2.java:// 这是输入输出处理效率很高的写法
class080/Code04_TSP2.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class080/Code04_TSP2.java:// 卡空间是吧？绕一下！
算法讲解081【必备】状压dp-下
class081/Code01_NumberOfWaysWearDifferentHats.java:// 每个人戴不同帽子的方案数
class081/Code01_NumberOfWaysWearDifferentHats.java:// 总共有 n 个人和 40 种不同的帽子，帽子编号从 1 到 40
class081/Code01_NumberOfWaysWearDifferentHats.java:// 给你一个整数列表的列表 hats ，其中 hats[i] 是第 i 个人所有喜欢帽子的列表
class081/Code01_NumberOfWaysWearDifferentHats.java:// 请你给每个人安排一顶他喜欢的帽子，确保每个人戴的帽子跟别人都不一样，并返回方案数
class081/Code01_NumberOfWaysWearDifferentHats.java:// 由于答案可能很大，请返回它对10^9+7取余后的结果
class081/Code01_NumberOfWaysWearDifferentHats.java:// 测试链接 : https://leetcode.cn/problems/number-of-ways-to-wear-different-hats-to-each-other
class081/Code02_OptimalAccountBalancing.java:// 最优账单平衡
class081/Code02_OptimalAccountBalancing.java:// 给你一个表示交易的数组 transactions
class081/Code02_OptimalAccountBalancing.java:// 其中 transactions[i] = [fromi, toi, amounti]
class081/Code02_OptimalAccountBalancing.java:// 表示 ID = fromi 的人给 ID = toi 的人共计 amounti
class081/Code02_OptimalAccountBalancing.java:// 请你计算并返回还清所有债务的最小交易笔数
class081/Code02_OptimalAccountBalancing.java:// 测试链接 : https://leetcode.cn/problems/optimal-account-balancing/
class081/Code03_TheNumberOfGoodSubsets.java:// 好子集的数目
class081/Code03_TheNumberOfGoodSubsets.java:// 给你一个整数数组 nums，好子集的定义如下：
class081/Code03_TheNumberOfGoodSubsets.java:// nums的某个子集，所有元素的乘积可以表示为一个或多个互不相同质数的乘积
class081/Code03_TheNumberOfGoodSubsets.java:// 比如nums = [1, 2, 3, 4]
class081/Code03_TheNumberOfGoodSubsets.java:// [2, 3]，[1, 2, 3]，[1, 3] 是好子集
class081/Code03_TheNumberOfGoodSubsets.java:// 乘积分别为6=2*3，6=2*3，3=3
class081/Code03_TheNumberOfGoodSubsets.java:// [1, 4]和[4]不是好子集，因为乘积分别为4=2*2和4=2*2
class081/Code03_TheNumberOfGoodSubsets.java:// 请你返回nums中不同的好子集的数目对10^9+7取余的结果
class081/Code03_TheNumberOfGoodSubsets.java:// 如果两个子集删除的下标不同，那么它们被视为不同的子集
class081/Code03_TheNumberOfGoodSubsets.java:// 测试链接 : https://leetcode.cn/problems/the-number-of-good-subsets/
class081/Code04_DistributeRepeatingIntegers.java:// 分配重复整数
class081/Code04_DistributeRepeatingIntegers.java:// 给你一个长度为n的整数数组nums，这个数组中至多有50个不同的值
class081/Code04_DistributeRepeatingIntegers.java:// 同时你有m个顾客的订单quantity，其中整数quantity[i]是第i位顾客订单的数目
class081/Code04_DistributeRepeatingIntegers.java:// 请你判断是否能将nums中的整数分配给这些顾客，且满足：
class081/Code04_DistributeRepeatingIntegers.java:// 第i位顾客恰好有quantity[i]个整数、第i位顾客拿到的整数都是相同的
class081/Code04_DistributeRepeatingIntegers.java:// 每位顾客都要满足上述两个要求，返回是否能都满足
class081/Code04_DistributeRepeatingIntegers.java:// 测试链接 : https://leetcode.cn/problems/distribute-repeating-integers/
算法讲解082【必备】动态规划中用观察优化枚举的技巧-上
class082/Code01_Stock1.java:// 买卖股票的最佳时机
class082/Code01_Stock1.java:// 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格
class082/Code01_Stock1.java:// 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票
class082/Code01_Stock1.java:// 设计一个算法来计算你所能获取的最大利润
class082/Code01_Stock1.java:// 返回你可以从这笔交易中获取的最大利润
class082/Code01_Stock1.java:// 如果你不能获取任何利润，返回 0
class082/Code01_Stock1.java:// 测试链接 : https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/
class082/Code02_Stock2.java:// 买卖股票的最佳时机 II
class082/Code02_Stock2.java:// 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格
class082/Code02_Stock2.java:// 在每一天，你可以决定是否购买和/或出售股票
class082/Code02_Stock2.java:// 你在任何时候 最多 只能持有 一股 股票
class082/Code02_Stock2.java:// 你也可以先购买，然后在 同一天 出售
class082/Code02_Stock2.java:// 返回 你能获得的 最大 利润
class082/Code02_Stock2.java:// 测试链接 : https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/
class082/Code03_Stock3.java:// 买卖股票的最佳时机 III
class082/Code03_Stock3.java:// 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。
class082/Code03_Stock3.java:// 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易
class082/Code03_Stock3.java:// 注意：你不能同时参与多笔交易，你必须在再次购买前出售掉之前的股票
class082/Code03_Stock3.java:// 测试链接 : https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii
class082/Code04_Stock4.java:// 买卖股票的最佳时机 IV
class082/Code04_Stock4.java:// 给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格
class082/Code04_Stock4.java:// 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易
class082/Code04_Stock4.java:// 也就是说，你最多可以买 k 次，卖 k 次
class082/Code04_Stock4.java:// 注意：你不能同时参与多笔交易，你必须在再次购买前出售掉之前的股票
class082/Code04_Stock4.java:// 测试链接 : https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/
class082/Code05_Stack5.java:// 买卖股票的最佳时机含手续费
class082/Code05_Stack5.java:// 给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格
class082/Code05_Stack5.java:// 整数 fee 代表了交易股票的手续费用
class082/Code05_Stack5.java:// 你可以无限次地完成交易，但是你每笔交易都需要付手续费
class082/Code05_Stack5.java:// 如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。
class082/Code05_Stack5.java:// 返回获得利润的最大值
class082/Code05_Stack5.java:// 注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费
class082/Code05_Stack5.java:// 测试链接 : https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/
class082/Code06_Stack6.java:// 买卖股票的最佳时机含冷冻期
class082/Code06_Stack6.java:// 给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格
class082/Code06_Stack6.java:// 设计一个算法计算出最大利润
class082/Code06_Stack6.java:// 在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
class082/Code06_Stack6.java:// 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)
class082/Code06_Stack6.java:// 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）
class082/Code06_Stack6.java:// 测试链接 : https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/
class082/Code07_DiSequence.java:// DI序列的有效排列
class082/Code07_DiSequence.java:// 给定一个长度为n的字符串s，其中s[i]是:
class082/Code07_DiSequence.java:// "D"意味着减少，"I"意味着增加
class082/Code07_DiSequence.java:// 有效排列是对有n+1个在[0,n]范围内的整数的一个排列perm，使得对所有的i：
class082/Code07_DiSequence.java:// 如果 s[i] == 'D'，那么 perm[i] > perm[i+1]
class082/Code07_DiSequence.java:// 如果 s[i] == 'I'，那么 perm[i] < perm[i+1]
class082/Code07_DiSequence.java:// 返回有效排列的perm的数量
class082/Code07_DiSequence.java:// 因为答案可能很大，所以请返回你的答案对10^9+7取余
class082/Code07_DiSequence.java:// 测试链接 : https://leetcode.cn/problems/valid-permutations-for-di-sequence/
算法讲解083【必备】动态规划中用观察优化枚举的技巧-下
class083/Code01_MaximumProfitInJobScheduling.java:// 规划兼职工作
class083/Code01_MaximumProfitInJobScheduling.java:// 你打算利用空闲时间来做兼职工作赚些零花钱，这里有n份兼职工作
class083/Code01_MaximumProfitInJobScheduling.java:// 每份工作预计从startTime[i]开始、endTime[i]结束，报酬为profit[i]
class083/Code01_MaximumProfitInJobScheduling.java:// 返回可以获得的最大报酬
class083/Code01_MaximumProfitInJobScheduling.java:// 注意，时间上出现重叠的 2 份工作不能同时进行
class083/Code01_MaximumProfitInJobScheduling.java:// 如果你选择的工作在时间X结束，那么你可以立刻进行在时间X开始的下一份工作
class083/Code01_MaximumProfitInJobScheduling.java:// 测试链接 : https://leetcode.cn/problems/maximum-profit-in-job-scheduling/
class083/Code02_KInversePairsArray.java:// K个逆序对数组
class083/Code02_KInversePairsArray.java:// 逆序对的定义如下：
class083/Code02_KInversePairsArray.java:// 对于数组nums的第i个和第j个元素
class083/Code02_KInversePairsArray.java:// 如果满足0<=i<j<nums.length 且 nums[i]>nums[j]，则为一个逆序对
class083/Code02_KInversePairsArray.java:// 给你两个整数n和k，找出所有包含从1到n的数字
class083/Code02_KInversePairsArray.java:// 且恰好拥有k个逆序对的不同的数组的个数
class083/Code02_KInversePairsArray.java:// 由于答案可能很大，只需要返回对10^9+7取余的结果
class083/Code02_KInversePairsArray.java:// 测试链接 : https://leetcode.cn/problems/k-inverse-pairs-array/
class083/Code03_FreedomTrail.java:// 自由之路
class083/Code03_FreedomTrail.java:// 题目描述比较多，打开链接查看
class083/Code03_FreedomTrail.java:// 测试链接 : https://leetcode.cn/problems/freedom-trail/
class083/Code04_LongestSubarraySumNoMoreK.java:// 累加和不大于k的最长子数组
class083/Code04_LongestSubarraySumNoMoreK.java:// 给定一个无序数组arr，长度为n，其中元素可能是正、负、0
class083/Code04_LongestSubarraySumNoMoreK.java:// 给定一个整数k，求arr所有的子数组中累加和不大于k的最长子数组长度
class083/Code04_LongestSubarraySumNoMoreK.java:// 要求时间复杂度为O(n)
class083/Code04_LongestSubarraySumNoMoreK.java:// 测试链接 : https://www.nowcoder.com/practice/3473e545d6924077a4f7cbc850408ade
class083/Code04_LongestSubarraySumNoMoreK.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class083/Code04_LongestSubarraySumNoMoreK.java:// 这是输入输出处理效率很高的写法
class083/Code04_LongestSubarraySumNoMoreK.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class083/Code04_LongestSubarraySumNoMoreK.java:// 至今的最优解，全网题解几乎都是我几年前讲的方法
算法讲解084【必备】数位dp-上
class084/Code01_CountNumbersWithUniqueDigits.java:// 统计各位数字都不同的数字个数
class084/Code01_CountNumbersWithUniqueDigits.java:// 给你一个整数n，代表十进制数字最多有n位
class084/Code01_CountNumbersWithUniqueDigits.java:// 如果某个数字，每一位都不同，那么这个数字叫做有效数字
class084/Code01_CountNumbersWithUniqueDigits.java:// 返回有效数字的个数，不统计负数范围
class084/Code01_CountNumbersWithUniqueDigits.java:// 测试链接 : https://leetcode.cn/problems/count-numbers-with-unique-digits/
class084/Code02_NumbersAtMostGivenDigitSet.java:// 最大为N的数字组合
class084/Code02_NumbersAtMostGivenDigitSet.java:// 给定一个按 非递减顺序 排列的数字数组 digits
class084/Code02_NumbersAtMostGivenDigitSet.java:// 已知digits一定不包含'0'，可能包含'1' ~ '9'，且无重复字符
class084/Code02_NumbersAtMostGivenDigitSet.java:// 你可以用任意次数 digits[i] 来写的数字
class084/Code02_NumbersAtMostGivenDigitSet.java:// 例如，如果 digits = ['1','3','5']
class084/Code02_NumbersAtMostGivenDigitSet.java:// 我们可以写数字，如 '13', '551', 和 '1351315'
class084/Code02_NumbersAtMostGivenDigitSet.java:// 返回 可以生成的小于或等于给定整数 n 的正整数的个数
class084/Code02_NumbersAtMostGivenDigitSet.java:// 测试链接 : https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/
class084/Code03_CountOfIntegers.java:// 统计整数数目
class084/Code03_CountOfIntegers.java:// 给你两个数字字符串 num1 和 num2 ，以及两个整数max_sum和min_sum
class084/Code03_CountOfIntegers.java:// 如果一个整数 x 满足以下条件，我们称它是一个好整数
class084/Code03_CountOfIntegers.java:// num1 <= x <= num2
class084/Code03_CountOfIntegers.java:// min_sum <= digit_sum(x) <= max_sum
class084/Code03_CountOfIntegers.java:// 请你返回好整数的数目
class084/Code03_CountOfIntegers.java:// 答案可能很大请返回答案对10^9 + 7 取余后的结果
class084/Code03_CountOfIntegers.java:// 注意，digit_sum(x)表示x各位数字之和
class084/Code03_CountOfIntegers.java:// 测试链接 : https://leetcode.cn/problems/count-of-integers/
class084/Code04_CountSpecialIntegers.java:// 完全没有重复的数字个数
class084/Code04_CountSpecialIntegers.java:// 给定正整数n，返回在[1, n]范围内每一位都互不相同的正整数个数
class084/Code04_CountSpecialIntegers.java:// 测试链接 : https://leetcode.cn/problems/count-special-integers/
class084/Code04_NumbersWithRepeatedDigits.java:// 至少有1位重复的数字个数
class084/Code04_NumbersWithRepeatedDigits.java:// 给定正整数n，返回在[1, n]范围内至少有1位重复数字的正整数个数
class084/Code04_NumbersWithRepeatedDigits.java:// 测试链接 : https://leetcode.cn/problems/numbers-with-repeated-digits/
算法讲解085【必备】数位dp-下
class085/Code01_WindyNumber.java:// windy数
class085/Code01_WindyNumber.java:// 不含前导零且相邻两个数字之差至少为2的正整数被称为windy数
class085/Code01_WindyNumber.java:// windy想知道[a,b]范围上总共有多少个windy数
class085/Code01_WindyNumber.java:// 测试链接 : https://www.luogu.com.cn/problem/P2657
class085/Code01_WindyNumber.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class085/Code01_WindyNumber.java:// 这是输入输出处理效率很高的写法
class085/Code01_WindyNumber.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class085/Code02_MengNumber.java:// 萌数
class085/Code02_MengNumber.java:// 如果一个数字，存在长度至少为2的回文子串，那么这种数字被称为萌数
class085/Code02_MengNumber.java:// 比如101、110、111、1234321、45568
class085/Code02_MengNumber.java:// 求[l,r]范围上，有多少个萌数
class085/Code02_MengNumber.java:// 由于答案可能很大，所以输出答案对1000000007求余
class085/Code02_MengNumber.java:// 测试链接 : https://www.luogu.com.cn/problem/P3413
class085/Code02_MengNumber.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class085/Code02_MengNumber.java:// 这是输入输出处理效率很高的写法
class085/Code02_MengNumber.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class085/Code03_IntegersWithoutConsecutiveOnes.java:// 不含连续1的非负整数
class085/Code03_IntegersWithoutConsecutiveOnes.java:// 给定一个正整数n，请你统计在[0, n]范围的非负整数中
class085/Code03_IntegersWithoutConsecutiveOnes.java:// 有多少个整数的二进制表示中不存在连续的1
class085/Code03_IntegersWithoutConsecutiveOnes.java:// 测试链接 : https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/
class085/Code04_DigitCount1.java:// 范围内的数字计数
class085/Code04_DigitCount1.java:// 给定两个正整数a和b，求在[a,b]范围上的所有整数中
class085/Code04_DigitCount1.java:// 1 <= a, b
class085/Code04_DigitCount1.java:// 某个数码d出现了多少次
class085/Code04_DigitCount1.java:// 测试链接 : https://leetcode.cn/problems/digit-count-in-range/
class085/Code04_DigitCount2.java:// 范围内的数字计数
class085/Code04_DigitCount2.java:// 给定两个正整数a和b，求在[a,b]范围上的所有整数中
class085/Code04_DigitCount2.java:// 每个数码(digit)各出现了多少次
class085/Code04_DigitCount2.java:// 1 <= a, b
class085/Code04_DigitCount2.java:// 测试链接 : https://www.luogu.com.cn/problem/P2602
class085/Code04_DigitCount2.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class085/Code04_DigitCount2.java:// 这是输入输出处理效率很高的写法
class085/Code04_DigitCount2.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class085/Code04_DigitCount3.java:// 数字1的个数
class085/Code04_DigitCount3.java:// 给定一个整数n
class085/Code04_DigitCount3.java:// 计算所有小于等于n的非负整数中数字1出现的个数
class085/Code04_DigitCount3.java:// 测试链接 : https://leetcode.cn/problems/number-of-digit-one/
算法讲解086【必备】动态规划中得到具体决策方案的技巧
class086/Code01_LCS.java:// 最长公共子序列其中一个结果
class086/Code01_LCS.java:// 给定两个字符串str1和str2
class086/Code01_LCS.java:// 输出两个字符串的最长公共子序列
class086/Code01_LCS.java:// 如果最长公共子序列为空，则输出-1
class086/Code01_LCS.java:// 测试链接 : https://www.nowcoder.com/practice/4727c06b9ee9446cab2e859b4bb86bb8
class086/Code01_LCS.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class086/Code01_LCS.java:// 这是输入输出处理效率很高的写法
class086/Code01_LCS.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class086/Code01_LCS.java:// 讲解067 - 题目3，最长公共子序列长度
class086/Code02_SmallestSufficientTeam.java:// 最小的必要团队
class086/Code02_SmallestSufficientTeam.java:// 作为项目经理，你规划了一份需求的技能清单req_skills
class086/Code02_SmallestSufficientTeam.java:// 并打算从备选人员名单people中选出些人组成必要团队
class086/Code02_SmallestSufficientTeam.java:// 编号为i的备选人员people[i]含有一份该备选人员掌握的技能列表
class086/Code02_SmallestSufficientTeam.java:// 所谓必要团队，就是在这个团队中
class086/Code02_SmallestSufficientTeam.java:// 对于所需求的技能列表req_skills中列出的每项技能，团队中至少有一名成员已经掌握
class086/Code02_SmallestSufficientTeam.java:// 请你返回规模最小的必要团队，团队成员用人员编号表示
class086/Code02_SmallestSufficientTeam.java:// 你可以按 任意顺序 返回答案，题目数据保证答案存在
class086/Code02_SmallestSufficientTeam.java:// 测试链接 : https://leetcode.cn/problems/smallest-sufficient-team/
class086/Code03_LIS.java:// 最长递增子序列字典序最小的结果
class086/Code03_LIS.java:// 给定数组arr，设长度为n
class086/Code03_LIS.java:// 输出arr的最长递增子序列
class086/Code03_LIS.java:// 如果有多个答案，请输出其中字典序最小的
class086/Code03_LIS.java:// 注意这道题的字典序设定（根据提交的结果推论的）：
class086/Code03_LIS.java:// 每个数字看作是单独的字符，比如120认为比36的字典序大
class086/Code03_LIS.java:// 保证从左到右每个数字尽量小
class086/Code03_LIS.java:// 测试链接 : https://www.nowcoder.com/practice/30fb9b3cab9742ecae9acda1c75bf927
class086/Code03_LIS.java:// 测试链接 : https://www.luogu.com.cn/problem/T386911
class086/Code03_LIS.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class086/Code03_LIS.java:// 这是输入输出处理效率很高的写法
class086/Code03_LIS.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class086/Code03_LIS.java:// 讲解072 - 最长递增子序列及其扩展
class086/Code04_Diving1.java:// 潜水的最大时间与方案
class086/Code04_Diving1.java:// 一共有n个工具，每个工具都有自己的重量a、阻力b、提升的停留时间c
class086/Code04_Diving1.java:// 因为背包有限，所以只能背重量不超过m的工具
class086/Code04_Diving1.java:// 因为力气有限，所以只能背阻力不超过v的工具
class086/Code04_Diving1.java:// 希望能在水下停留的时间最久
class086/Code04_Diving1.java:// 返回最久的停留时间和下标字典序最小的选择工具的方案
class086/Code04_Diving1.java:// 注意这道题的字典序设定（根据提交的结果推论的）：
class086/Code04_Diving1.java:// 下标方案整体构成的字符串保证字典序最小
class086/Code04_Diving1.java:// 比如下标方案"1 120"比下标方案"1 2"字典序小
class086/Code04_Diving1.java:// 测试链接 : https://www.luogu.com.cn/problem/P1759
class086/Code04_Diving1.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class086/Code04_Diving1.java:// 这是输入输出处理效率很高的写法
class086/Code04_Diving1.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class086/Code04_Diving1.java:// 讲解069 - 多维费用背包
class086/Code04_Diving1.java:// 不做空间压缩的版本
class086/Code04_Diving1.java:// 无法通过全部测试用例
class086/Code04_Diving1.java:// 这个题必须做空间压缩
class086/Code04_Diving1.java:// 空间压缩的实现在Code04_Diving2
class086/Code04_Diving2.java:// 潜水的最大时间与方案
class086/Code04_Diving2.java:// 一共有n个工具，每个工具都有自己的重量a、阻力b、提升的停留时间c
class086/Code04_Diving2.java:// 因为背包有限，所以只能背重量不超过m的工具
class086/Code04_Diving2.java:// 因为力气有限，所以只能背阻力不超过v的工具
class086/Code04_Diving2.java:// 希望能在水下停留的时间最久
class086/Code04_Diving2.java:// 返回最久的停留时间和下标字典序最小的选择工具的方案
class086/Code04_Diving2.java:// 注意这道题的字典序设定（根据提交的结果推论的）：
class086/Code04_Diving2.java:// 下标方案整体构成的字符串保证字典序最小
class086/Code04_Diving2.java:// 比如下标方案"1 120"比下标方案"1 2"字典序小
class086/Code04_Diving2.java:// 测试链接 : https://www.luogu.com.cn/problem/P1759
class086/Code04_Diving2.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class086/Code04_Diving2.java:// 这是输入输出处理效率很高的写法
class086/Code04_Diving2.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class086/Code04_Diving2.java:// 本文件做了空间压缩优化
class086/Code04_Diving2.java:// 可以通过全部测试用例
算法讲解087【必备】动态规划中根据数据量猜解法的技巧
class087/Code01_BuyMonster.java:// 贿赂怪兽
class087/Code01_BuyMonster.java:// 开始时你的能力是0，你的目标是从0号怪兽开始，通过所有的n只怪兽
class087/Code01_BuyMonster.java:// 如果你当前的能力小于i号怪兽的能力，则必须付出b[i]的钱贿赂这个怪兽
class087/Code01_BuyMonster.java:// 然后怪兽就会加入你，他的能力a[i]直接累加到你的能力上
class087/Code01_BuyMonster.java:// 如果你当前的能力大于等于i号怪兽的能力，你可以选择直接通过，且能力不会下降
class087/Code01_BuyMonster.java:// 但你依然可以选择贿赂这个怪兽，然后怪兽的能力直接累加到你的能力上
class087/Code01_BuyMonster.java:// 返回通过所有的怪兽，需要花的最小钱数
class087/Code01_BuyMonster.java:// 测试链接 : https://www.nowcoder.com/practice/736e12861f9746ab8ae064d4aae2d5a9
class087/Code01_BuyMonster.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class087/Code01_BuyMonster.java:// 这是输入输出处理效率很高的写法
class087/Code01_BuyMonster.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class087/Code02_PickNumbersClosedSum.java:// 选择k个数字使得两集合累加和相差不超过1
class087/Code02_PickNumbersClosedSum.java:// 给定一个正数n，表示1~n这些数字都可以选择
class087/Code02_PickNumbersClosedSum.java:// 给定一个正数k，表示要从1~n中选择k个数字组成集合A，剩下数字组成集合B
class087/Code02_PickNumbersClosedSum.java:// 希望做到集合A和集合B的累加和相差不超过1
class087/Code02_PickNumbersClosedSum.java:// 如果能做到，返回集合A选择了哪些数字，任何一种方案都可以
class087/Code02_PickNumbersClosedSum.java:// 如果不能做到，返回长度为0的数组
class087/Code02_PickNumbersClosedSum.java:// 2 <= n <= 10^6
class087/Code02_PickNumbersClosedSum.java:// 1 <= k <= n
class087/Code02_PickNumbersClosedSum.java:// 来自真实大厂笔试，没有测试链接，用对数器验证
class087/Code03_PermutationLCS.java:// 两个排列的最长公共子序列长度
class087/Code03_PermutationLCS.java:// 给出由1~n这些数字组成的两个排列
class087/Code03_PermutationLCS.java:// 求它们的最长公共子序列长度
class087/Code03_PermutationLCS.java:// n <= 10^5
class087/Code03_PermutationLCS.java:// 测试链接 : https://www.luogu.com.cn/problem/P1439
class087/Code03_PermutationLCS.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class087/Code03_PermutationLCS.java:// 这是输入输出处理效率很高的写法
class087/Code03_PermutationLCS.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class087/Code04_MakeArrayStrictlyIncreasing.java:// 使数组严格递增的最小操作数
class087/Code04_MakeArrayStrictlyIncreasing.java:// 给你两个整数数组 arr1 和 arr2
class087/Code04_MakeArrayStrictlyIncreasing.java:// 返回使 arr1 严格递增所需要的最小操作数（可能为0）
class087/Code04_MakeArrayStrictlyIncreasing.java:// 每一步操作中，你可以分别从 arr1 和 arr2 中各选出一个索引
class087/Code04_MakeArrayStrictlyIncreasing.java:// 分别为 i 和 j，0 <= i < arr1.length 和 0 <= j < arr2.length
class087/Code04_MakeArrayStrictlyIncreasing.java:// 然后进行赋值运算 arr1[i] = arr2[j]
class087/Code04_MakeArrayStrictlyIncreasing.java:// 如果无法让 arr1 严格递增，请返回-1
class087/Code04_MakeArrayStrictlyIncreasing.java:// 1 <= arr1.length, arr2.length <= 2000
class087/Code04_MakeArrayStrictlyIncreasing.java:// 0 <= arr1[i], arr2[i] <= 10^9
class087/Code04_MakeArrayStrictlyIncreasing.java:// 测试链接 : https://leetcode.cn/problems/make-array-strictly-increasing/
算法讲解088【必备】动态规划专题总结与预告
算法讲解089【必备】贪心经典题目专题1
class089/Code01_LargestNumber.java:// 最大数
class089/Code01_LargestNumber.java:// 给定一组非负整数nums
class089/Code01_LargestNumber.java:// 重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数
class089/Code01_LargestNumber.java:// 测试链接 : https://leetcode.cn/problems/largest-number/
class089/Code02_TwoCityScheduling.java:// 两地调度
class089/Code02_TwoCityScheduling.java:// 公司计划面试2n个人，给定一个数组 costs
class089/Code02_TwoCityScheduling.java:// 其中costs[i]=[aCosti, bCosti]
class089/Code02_TwoCityScheduling.java:// 表示第i人飞往a市的费用为aCosti，飞往b市的费用为bCosti
class089/Code02_TwoCityScheduling.java:// 返回将每个人都飞到a、b中某座城市的最低费用
class089/Code02_TwoCityScheduling.java:// 要求每个城市都有n人抵达
class089/Code02_TwoCityScheduling.java:// 测试链接 : https://leetcode.cn/problems/two-city-scheduling/
class089/Code03_MinimumNumberEatOranges.java:// 吃掉N个橘子的最少天数
class089/Code03_MinimumNumberEatOranges.java:// 厨房里总共有 n 个橘子，你决定每一天选择如下方式之一吃这些橘子
class089/Code03_MinimumNumberEatOranges.java:// 1）吃掉一个橘子
class089/Code03_MinimumNumberEatOranges.java:// 2) 如果剩余橘子数 n 能被 2 整除，那么你可以吃掉 n/2 个橘子
class089/Code03_MinimumNumberEatOranges.java:// 3) 如果剩余橘子数 n 能被 3 整除，那么你可以吃掉 2*(n/3) 个橘子
class089/Code03_MinimumNumberEatOranges.java:// 每天你只能从以上 3 种方案中选择一种方案
class089/Code03_MinimumNumberEatOranges.java:// 请你返回吃掉所有 n 个橘子的最少天数
class089/Code03_MinimumNumberEatOranges.java:// 测试链接 : https://leetcode.cn/problems/minimum-number-of-days-to-eat-n-oranges/
class089/Code04_MeetingRoomsII.java:// 会议室II
class089/Code04_MeetingRoomsII.java:// 给你一个会议时间安排的数组 intervals
class089/Code04_MeetingRoomsII.java:// 每个会议时间都会包括开始和结束的时间intervals[i]=[starti, endi]
class089/Code04_MeetingRoomsII.java:// 返回所需会议室的最小数量
class089/Code04_MeetingRoomsII.java:// 测试链接 : https://leetcode.cn/problems/meeting-rooms-ii/
class089/Code05_CourseScheduleIII.java:// 课程表III
class089/Code05_CourseScheduleIII.java:// 这里有n门不同的在线课程，按从1到n编号
class089/Code05_CourseScheduleIII.java:// 给你一个数组courses
class089/Code05_CourseScheduleIII.java:// 其中courses[i]=[durationi, lastDayi]表示第i门课将会持续上durationi天课
class089/Code05_CourseScheduleIII.java:// 并且必须在不晚于lastDayi的时候完成
class089/Code05_CourseScheduleIII.java:// 你的学期从第 1 天开始
class089/Code05_CourseScheduleIII.java:// 且不能同时修读两门及两门以上的课程
class089/Code05_CourseScheduleIII.java:// 返回你最多可以修读的课程数目
class089/Code05_CourseScheduleIII.java:// 测试链接 : https://leetcode.cn/problems/course-schedule-iii/
class089/Code06_MinimumCostToConnectSticks1.java:// 连接棒材的最低费用(leetcode测试)
class089/Code06_MinimumCostToConnectSticks1.java:// 你有一些长度为正整数的棍子
class089/Code06_MinimumCostToConnectSticks1.java:// 这些长度以数组sticks的形式给出
class089/Code06_MinimumCostToConnectSticks1.java:// sticks[i]是第i个木棍的长度
class089/Code06_MinimumCostToConnectSticks1.java:// 你可以通过支付x+y的成本将任意两个长度为x和y的棍子连接成一个棍子
class089/Code06_MinimumCostToConnectSticks1.java:// 你必须连接所有的棍子，直到剩下一个棍子
class089/Code06_MinimumCostToConnectSticks1.java:// 返回以这种方式将所有给定的棍子连接成一个棍子的最小成本
class089/Code06_MinimumCostToConnectSticks1.java:// 测试链接 : https://leetcode.cn/problems/minimum-cost-to-connect-sticks/
class089/Code06_MinimumCostToConnectSticks2.java:// 连接棒材的最低费用(洛谷测试)
class089/Code06_MinimumCostToConnectSticks2.java:// 你有一些长度为正整数的棍子
class089/Code06_MinimumCostToConnectSticks2.java:// 这些长度以数组sticks的形式给出
class089/Code06_MinimumCostToConnectSticks2.java:// sticks[i]是第i个木棍的长度
class089/Code06_MinimumCostToConnectSticks2.java:// 你可以通过支付x+y的成本将任意两个长度为x和y的棍子连接成一个棍子
class089/Code06_MinimumCostToConnectSticks2.java:// 你必须连接所有的棍子，直到剩下一个棍子
class089/Code06_MinimumCostToConnectSticks2.java:// 返回以这种方式将所有给定的棍子连接成一个棍子的最小成本
class089/Code06_MinimumCostToConnectSticks2.java:// 测试链接 : https://www.luogu.com.cn/problem/P1090
class089/Code06_MinimumCostToConnectSticks2.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class089/Code06_MinimumCostToConnectSticks2.java:// 这是输入输出处理效率很高的写法
class089/Code06_MinimumCostToConnectSticks2.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
算法讲解090【必备】贪心经典题目专题2
class090/Code01_CuttingBamboo.java:// 砍竹子II
class090/Code01_CuttingBamboo.java:// 现需要将一根长为正整数bamboo_len的竹子砍为若干段
class090/Code01_CuttingBamboo.java:// 每段长度均为正整数
class090/Code01_CuttingBamboo.java:// 请返回每段竹子长度的最大乘积是多少
class090/Code01_CuttingBamboo.java:// 答案需要对1000000007取模
class090/Code01_CuttingBamboo.java:// 测试链接 : https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/
class090/Code02_MaximumProduct.java:// 分成k份的最大乘积
class090/Code02_MaximumProduct.java:// 一个数字n一定要分成k份，得到的乘积尽量大是多少
class090/Code02_MaximumProduct.java:// 数字n和k，可能非常大，到达10^12规模
class090/Code02_MaximumProduct.java:// 结果可能更大，所以返回结果对1000000007取模
class090/Code02_MaximumProduct.java:// 来自真实大厂笔试，没有在线测试，对数器验证
class090/Code03_MeetingMonopoly1.java:// 会议必须独占时间段的最大会议数量
class090/Code03_MeetingMonopoly1.java:// 给定若干会议的开始、结束时间
class090/Code03_MeetingMonopoly1.java:// 你参加某个会议的期间，不能参加其他会议
class090/Code03_MeetingMonopoly1.java:// 返回你能参加的最大会议数量
class090/Code03_MeetingMonopoly1.java:// 来自真实大厂笔试，没有在线测试，对数器验证
class090/Code03_MeetingMonopoly2.java:// 同学找到了在线测试，看似是题目3，其实不是
class090/Code03_MeetingMonopoly2.java:// 区别在于数据量，如下测试链接中的题目
class090/Code03_MeetingMonopoly2.java:// 会议的数量10^6，会议的开始、结束时间也是10^6
class090/Code03_MeetingMonopoly2.java:// 排序会超时，C++的同学可能不会，但是java的同学会
class090/Code03_MeetingMonopoly2.java:// 而且根据这个数据量，最优解一定不是排序！
class090/Code03_MeetingMonopoly2.java:// 会议开始、结束时间也是10^6规模，所以不排序也可以做，具体看如下代码和注释
class090/Code03_MeetingMonopoly2.java:// 并不是课上讲错了，而是这个数据状况太特殊
class090/Code03_MeetingMonopoly2.java:// 测试链接 : https://www.luogu.com.cn/problem/P1803
class090/Code03_MeetingMonopoly2.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class090/Code03_MeetingMonopoly2.java:// 这是输入输出处理效率很高的写法
class090/Code03_MeetingMonopoly2.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class090/Code04_MeetingOneDay.java:// 会议只占一天的最大会议数量
class090/Code04_MeetingOneDay.java:// 给定若干会议的开始、结束时间
class090/Code04_MeetingOneDay.java:// 任何会议的召开期间，你只需要抽出1天来参加
class090/Code04_MeetingOneDay.java:// 但是你安排的那一天，只能参加这个会议，不能同时参加其他会议
class090/Code04_MeetingOneDay.java:// 返回你能参加的最大会议数量
class090/Code04_MeetingOneDay.java:// 测试链接 : https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended/
class090/Code05_IPO.java:// IPO
class090/Code05_IPO.java:// 给你n个项目，对于每个项目i
class090/Code05_IPO.java:// 它都有一个纯利润profits[i]
class090/Code05_IPO.java:// 和启动该项目需要的最小资本capital[i]
class090/Code05_IPO.java:// 最初你的资本为w，当你完成一个项目时，你将获得纯利润，添加到你的总资本中
class090/Code05_IPO.java:// 总而言之，从给定项目中选择最多k个不同项目的列表
class090/Code05_IPO.java:// 以最大化最终资本，并输出最终可获得的最多资本
class090/Code05_IPO.java:// 测试链接 : https://leetcode.cn/problems/ipo/
class090/Code06_AbsoluteValueAddToArray.java:// 加入差值绝对值直到长度固定
class090/Code06_AbsoluteValueAddToArray.java:// 给定一个非负数组arr，计算任何两个数差值的绝对值
class090/Code06_AbsoluteValueAddToArray.java:// 如果arr中没有，都要加入到arr里，但是只加一份
class090/Code06_AbsoluteValueAddToArray.java:// 然后新的arr继续计算任何两个数差值的绝对值，
class090/Code06_AbsoluteValueAddToArray.java:// 如果arr中没有，都要加入到arr里，但是只加一份
class090/Code06_AbsoluteValueAddToArray.java:// 一直到arr大小固定，返回arr最终的长度
class090/Code06_AbsoluteValueAddToArray.java:// 来自真实大厂笔试，没有在线测试，对数器验证
算法讲解091【必备】贪心经典题目专题3
class091/Code01_ShortestUnsortedContinuousSubarray.java:// 最短无序连续子数组
class091/Code01_ShortestUnsortedContinuousSubarray.java:// 给你一个整数数组nums，你需要找出一个 连续子数组
class091/Code01_ShortestUnsortedContinuousSubarray.java:// 如果对这个子数组进行升序排序，那么整个数组都会变为升序排序
class091/Code01_ShortestUnsortedContinuousSubarray.java:// 请你找出符合题意的最短子数组，并输出它的长度
class091/Code01_ShortestUnsortedContinuousSubarray.java:// 测试链接 : https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/
class091/Code02_SmallestRange.java:// 最小区间
class091/Code02_SmallestRange.java:// 你有k个非递减排列的整数列表
class091/Code02_SmallestRange.java:// 找到一个最小区间，使得k个列表中的每个列表至少有一个数包含在其中
class091/Code02_SmallestRange.java:// 测试链接 : https://leetcode.cn/problems/smallest-range-covering-elements-from-k-lists/
class091/Code03_GroupBuyTickets.java:// 组团买票
class091/Code03_GroupBuyTickets.java:// 景区里一共有m个项目，景区的第i个项目有如下两个参数：
class091/Code03_GroupBuyTickets.java:// game[i] = { Ki, Bi }，Ki、Bi一定是正数
class091/Code03_GroupBuyTickets.java:// Ki代表折扣系数，Bi代表票价
class091/Code03_GroupBuyTickets.java:// 举个例子 : Ki = 2, Bi = 10
class091/Code03_GroupBuyTickets.java:// 如果只有1个人买票，单张门票的价格为 : Bi - Ki * 1 = 8
class091/Code03_GroupBuyTickets.java:// 所以这1个人游玩该项目要花8元
class091/Code03_GroupBuyTickets.java:// 如果有2个人买票，单张门票的价格为 : Bi - Ki * 2 = 6
class091/Code03_GroupBuyTickets.java:// 所以这2个人游玩该项目要花6 * 2 = 12元
class091/Code03_GroupBuyTickets.java:// 如果有5个人买票，单张门票的价格为 : Bi - Ki * 5 = 0
class091/Code03_GroupBuyTickets.java:// 所以这5个人游玩该项目要花5 * 0 = 0元
class091/Code03_GroupBuyTickets.java:// 如果有更多人买票，都认为花0元(因为让项目倒贴钱实在是太操蛋了)
class091/Code03_GroupBuyTickets.java:// 于是可以认为，如果有x个人买票，单张门票的价格为 : Bi - Ki * x
class091/Code03_GroupBuyTickets.java:// x个人游玩这个项目的总花费是 : max { x * (Bi - Ki * x), 0 }
class091/Code03_GroupBuyTickets.java:// 单位一共有n个人，每个人最多可以选1个项目来游玩，也可以不选任何项目
class091/Code03_GroupBuyTickets.java:// 所有员工将在明晚提交选择，然后由你去按照上面的规则，统一花钱购票
class091/Code03_GroupBuyTickets.java:// 你想知道自己需要准备多少钱，就可以应付所有可能的情况，返回这个最保险的钱数
class091/Code03_GroupBuyTickets.java:// 数据量描述 : 
class091/Code03_GroupBuyTickets.java:// 1 <= M、N、Ki、Bi <= 10^5
class091/Code03_GroupBuyTickets.java:// 来自真实大厂笔试，没有在线测试，对数器验证
class091/Code04_SplitMinimumAverageSum.java:// 平均值最小累加和
class091/Code04_SplitMinimumAverageSum.java:// 给定一个数组arr，长度为n
class091/Code04_SplitMinimumAverageSum.java:// 再给定一个数字k，表示一定要将arr划分成k个集合
class091/Code04_SplitMinimumAverageSum.java:// 每个数字只能进一个集合
class091/Code04_SplitMinimumAverageSum.java:// 返回每个集合的平均值都累加起来的最小值
class091/Code04_SplitMinimumAverageSum.java:// 平均值向下取整
class091/Code04_SplitMinimumAverageSum.java:// 1 <= n <= 10^5
class091/Code04_SplitMinimumAverageSum.java:// 0 <= arr[i] <= 10^5
class091/Code04_SplitMinimumAverageSum.java:// 1 <= k <= n
class091/Code04_SplitMinimumAverageSum.java:// 来自真实大厂笔试，没有在线测试，对数器验证
class091/Code05_MinimalBatteryPower.java:// 执行所有任务的最少初始电量
class091/Code05_MinimalBatteryPower.java:// 每一个任务有两个参数，需要耗费的电量、至少多少电量才能开始这个任务
class091/Code05_MinimalBatteryPower.java:// 返回手机至少需要多少的初始电量，才能执行完所有的任务
class091/Code05_MinimalBatteryPower.java:// 来自真实大厂笔试，没有在线测试，对数器验证
class091/Code06_LongestSameZerosOnes.java:// 两个0和1数量相等区间的最大长度
class091/Code06_LongestSameZerosOnes.java:// 给出一个长度为n的01串，现在请你找到两个区间
class091/Code06_LongestSameZerosOnes.java:// 使得这两个区间中，1的个数相等，0的个数也相等
class091/Code06_LongestSameZerosOnes.java:// 这两个区间可以相交，但是不可以完全重叠，即两个区间的左右端点不可以完全一样
class091/Code06_LongestSameZerosOnes.java:// 现在请你找到两个最长的区间，满足以上要求
class091/Code06_LongestSameZerosOnes.java:// 返回区间最大长度
class091/Code06_LongestSameZerosOnes.java:// 来自真实大厂笔试，没有在线测试，对数器验证
算法讲解092【必备】贪心经典题目专题4
class092/Code01_MinimizeDeviation.java:// 数组的最小偏移量
class092/Code01_MinimizeDeviation.java:// 给你一个由n个正整数组成的数组nums
class092/Code01_MinimizeDeviation.java:// 你可以对数组的任意元素执行任意次数的两类操作：
class092/Code01_MinimizeDeviation.java:// 如果元素是偶数，除以2
class092/Code01_MinimizeDeviation.java:// 例如如果数组是[1,2,3,4]
class092/Code01_MinimizeDeviation.java:// 那么你可以对最后一个元素执行此操作，使其变成[1,2,3,2]
class092/Code01_MinimizeDeviation.java:// 如果元素是奇数，乘上2
class092/Code01_MinimizeDeviation.java:// 例如如果数组是[1,2,3,4]
class092/Code01_MinimizeDeviation.java:// 那么你可以对第一个元素执行此操作，使其变成[2,2,3,4]
class092/Code01_MinimizeDeviation.java:// 数组的偏移量是数组中任意两个元素之间的最大差值
class092/Code01_MinimizeDeviation.java:// 返回数组在执行某些操作之后可以拥有的最小偏移量
class092/Code01_MinimizeDeviation.java:// 测试链接 : https://leetcode.cn/problems/minimize-deviation-in-array/
class092/Code02_RabbitsInForest.java:// 森林中的兔子
class092/Code02_RabbitsInForest.java:// 森林中有未知数量的兔子
class092/Code02_RabbitsInForest.java:// 你问兔子们一个问题: "还有多少只兔子与你颜色相同?"
class092/Code02_RabbitsInForest.java:// 你将答案收集到了一个数组answers中
class092/Code02_RabbitsInForest.java:// 你可能没有收集到所有兔子的回答，可能只是一部分兔子的回答
class092/Code02_RabbitsInForest.java:// 其中answers[i]是第i只兔子的答案
class092/Code02_RabbitsInForest.java:// 所有兔子都不会说错，返回森林中兔子的最少数量
class092/Code02_RabbitsInForest.java:// 测试链接 : https://leetcode.cn/problems/rabbits-in-forest/
class092/Code03_MinimumOperationsMakeSimilar.java:// 使数组相似的最少操作次数
class092/Code03_MinimumOperationsMakeSimilar.java:// 给你两个正整数数组 nums 和 target ，两个数组长度相等
class092/Code03_MinimumOperationsMakeSimilar.java:// 在一次操作中，你可以选择两个 不同 的下标 i 和 j
class092/Code03_MinimumOperationsMakeSimilar.java:// 其中 0 <= i, j < nums.length ，并且：
class092/Code03_MinimumOperationsMakeSimilar.java:// 令 nums[i] = nums[i] + 2 且
class092/Code03_MinimumOperationsMakeSimilar.java:// 令 nums[j] = nums[j] - 2
class092/Code03_MinimumOperationsMakeSimilar.java:// 如果两个数组中每个元素出现的频率相等，我们称两个数组是 相似 的
class092/Code03_MinimumOperationsMakeSimilar.java:// 请你返回将 nums 变得与 target 相似的最少操作次数
class092/Code03_MinimumOperationsMakeSimilar.java:// 测试数据保证nums一定能变得与target相似
class092/Code03_MinimumOperationsMakeSimilar.java:// 测试链接 : https://leetcode.cn/problems/minimum-number-of-operations-to-make-arrays-similar/
class092/Code04_Quiz.java:// 知识竞赛
class092/Code04_Quiz.java:// 最近部门要选两个员工去参加一个需要合作的知识竞赛，
class092/Code04_Quiz.java:// 每个员工均有一个推理能力值ai，以及一个阅读能力值bi
class092/Code04_Quiz.java:// 如果选择第i个人和第j个人去参加竞赛，
class092/Code04_Quiz.java:// 两人在推理方面的能力为X = (ai + aj)/2
class092/Code04_Quiz.java:// 两人在阅读方面的能力为Y = (bi + bj)/2
class092/Code04_Quiz.java:// 现在需要最大化他们表现较差一方面的能力
class092/Code04_Quiz.java:// 即让min(X,Y) 尽可能大，问这个值最大是多少
class092/Code04_Quiz.java:// 测试链接 : https://www.nowcoder.com/practice/2a9089ea7e5b474fa8f688eae76bc050
class092/Code04_Quiz.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class092/Code04_Quiz.java:// 这是输入输出处理效率很高的写法
class092/Code04_Quiz.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class092/Code05_DivideArrayIncreasingSequences.java:// 将数组分成几个递增序列
class092/Code05_DivideArrayIncreasingSequences.java:// 给你一个有序的正数数组 nums 和整数 K
class092/Code05_DivideArrayIncreasingSequences.java:// 判断该数组是否可以被分成一个或几个 长度至少 为 K 的 不相交的递增子序列
class092/Code05_DivideArrayIncreasingSequences.java:// 数组中的所有数字，都要被，若干不相交的递增子序列包含
class092/Code05_DivideArrayIncreasingSequences.java:// 测试链接 : https://leetcode.cn/problems/divide-array-into-increasing-sequences/
class092/Code06_MinimumNumberRefuelingStops.java:// 最低加油次数
class092/Code06_MinimumNumberRefuelingStops.java:// 汽车从起点出发驶向目的地，该目的地位于出发位置东面target英里处
class092/Code06_MinimumNumberRefuelingStops.java:// 沿途有加油站，用数组stations表示，其中 stations[i] = [positioni, fueli]
class092/Code06_MinimumNumberRefuelingStops.java:// 表示第i个加油站位于出发位置东面positioni英里处，并且有fueli升汽油
class092/Code06_MinimumNumberRefuelingStops.java:// 假设汽车油箱的容量是无限的，其中最初有startFuel升燃料
class092/Code06_MinimumNumberRefuelingStops.java:// 它每行驶1英里就会用掉1升汽油
class092/Code06_MinimumNumberRefuelingStops.java:// 当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中
class092/Code06_MinimumNumberRefuelingStops.java:// 为了到达目的地，汽车所必要的最低加油次数是多少？
class092/Code06_MinimumNumberRefuelingStops.java:// 如果无法到达目的地，则返回-1
class092/Code06_MinimumNumberRefuelingStops.java:// 注意：如果汽车到达加油站时剩余燃料为0，它仍然可以在那里加油
class092/Code06_MinimumNumberRefuelingStops.java:// 如果汽车到达目的地时剩余燃料为 0，仍然认为它已经到达目的地
class092/Code06_MinimumNumberRefuelingStops.java:// 测试链接 : https://leetcode.cn/problems/minimum-number-of-refueling-stops/
算法讲解093【必备】贪心经典题目专题5
class093/Code01_JumpGameII.java:// 跳跃游戏II
class093/Code01_JumpGameII.java:// 给定一个长度为n的整数数组nums
class093/Code01_JumpGameII.java:// 你初始在0下标，nums[i]表示你可以从i下标往右跳的最大距离
class093/Code01_JumpGameII.java:// 比如，nums[0] = 3
class093/Code01_JumpGameII.java:// 表示你可以从0下标去往：1下标、2下标、3下标
class093/Code01_JumpGameII.java:// 你达到i下标后，可以根据nums[i]的值继续往右跳
class093/Code01_JumpGameII.java:// 返回你到达n-1下标的最少跳跃次数
class093/Code01_JumpGameII.java:// 测试用例可以保证一定能到达
class093/Code01_JumpGameII.java:// 测试链接 : https://leetcode.cn/problems/jump-game-ii/
class093/Code02_MinimumTaps.java:// 灌溉花园的最少水龙头数目
class093/Code02_MinimumTaps.java:// 在x轴上有一个一维的花园，花园长度为n，从点0开始，到点n结束
class093/Code02_MinimumTaps.java:// 花园里总共有 n + 1 个水龙头，分别位于[0, 1, ... n]
class093/Code02_MinimumTaps.java:// 给你一个整数n和一个长度为n+1的整数数组ranges
class093/Code02_MinimumTaps.java:// 其中ranges[i]表示
class093/Code02_MinimumTaps.java:// 如果打开点i处的水龙头，可以灌溉的区域为[i-ranges[i], i+ranges[i]]
class093/Code02_MinimumTaps.java:// 请你返回可以灌溉整个花园的最少水龙头数目
class093/Code02_MinimumTaps.java:// 如果花园始终存在无法灌溉到的地方请你返回-1
class093/Code02_MinimumTaps.java:// 测试链接 : https://leetcode.cn/problems/minimum-number-of-taps-to-open-to-water-a-garden/
class093/Code03_StringTransforms.java:// 字符串转化
class093/Code03_StringTransforms.java:// 给出两个长度相同的字符串str1和str2
class093/Code03_StringTransforms.java:// 请你帮忙判断字符串str1能不能在 零次 或 多次 转化后变成字符串str2
class093/Code03_StringTransforms.java:// 每一次转化时，你可以将str1中出现的所有相同字母变成其他任何小写英文字母
class093/Code03_StringTransforms.java:// 只有在字符串str1能够通过上述方式顺利转化为字符串str2时才能返回true
class093/Code03_StringTransforms.java:// 测试链接 : https://leetcode.cn/problems/string-transforms-into-another-string/
class093/Code04_CrossRiver.java:// 过河问题
class093/Code04_CrossRiver.java:// 一共n人出游，他们走到一条河的西岸，想要过河到东岸
class093/Code04_CrossRiver.java:// 每个人都有一个渡河时间ti，西岸有一条船，一次最多乘坐两人
class093/Code04_CrossRiver.java:// 如果船上有一个人，划到对岸的时间，等于这个人的渡河时间
class093/Code04_CrossRiver.java:// 如果船上有两个人，划到对岸的时间，等于两个人的渡河时间的最大值
class093/Code04_CrossRiver.java:// 返回最少要花费多少时间，才能使所有人都过河
class093/Code04_CrossRiver.java:// 测试链接 : https://www.luogu.com.cn/problem/P1809
class093/Code04_CrossRiver.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class093/Code04_CrossRiver.java:// 这是输入输出处理效率很高的写法
class093/Code04_CrossRiver.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class093/Code05_SuperWashingMachines.java:// 超级洗衣机
class093/Code05_SuperWashingMachines.java:// 假设有n台超级洗衣机放在同一排上
class093/Code05_SuperWashingMachines.java:// 开始的时候，每台洗衣机内可能有一定量的衣服，也可能是空的
class093/Code05_SuperWashingMachines.java:// 在每一步操作中，你可以选择任意 m (1 <= m <= n) 台洗衣机
class093/Code05_SuperWashingMachines.java:// 与此同时将每台洗衣机的一件衣服送到相邻的一台洗衣机
class093/Code05_SuperWashingMachines.java:// 给定一个整数数组machines代表从左至右每台洗衣机中的衣物数量
class093/Code05_SuperWashingMachines.java:// 请给出能让所有洗衣机中剩下的衣物的数量相等的最少的操作步数
class093/Code05_SuperWashingMachines.java:// 如果不能使每台洗衣机中衣物的数量相等则返回-1
class093/Code05_SuperWashingMachines.java:// 测试链接 : https://leetcode.cn/problems/super-washing-machines/
算法讲解094【必备】贪心经典题目专题6
class094/Code01_EliminateMaximumMonsters.java:// 消灭怪物的最大数量
class094/Code01_EliminateMaximumMonsters.java:// 你正在玩一款电子游戏，在游戏中你需要保护城市免受怪物侵袭
class094/Code01_EliminateMaximumMonsters.java:// 给定两个大小为n的整数数组dist、speed
class094/Code01_EliminateMaximumMonsters.java:// 其中dist[i]是第i个怪物与城市的初始距离
class094/Code01_EliminateMaximumMonsters.java:// 其中speed[i]是第i个怪物的速度
class094/Code01_EliminateMaximumMonsters.java:// 你有一种武器，一旦充满电，就可以消灭一个怪物，但是，武器需要1的时间才能充电完成
class094/Code01_EliminateMaximumMonsters.java:// 武器在游戏开始时是充满电的状态，怪物从0时刻开始移动，一旦任何怪物到达城市，就输掉了这场游戏
class094/Code01_EliminateMaximumMonsters.java:// 如果某个怪物恰好在某一分钟开始时到达城市，这也会被视为输掉游戏
class094/Code01_EliminateMaximumMonsters.java:// 返回在你输掉游戏前可以消灭的怪物的最大数量，如果消灭所有怪兽了返回n
class094/Code01_EliminateMaximumMonsters.java:// 测试链接 : https://leetcode.cn/problems/eliminate-maximum-number-of-monsters/
class094/Code02_LargestPalindromicNumber.java:// 最大回文数字
class094/Code02_LargestPalindromicNumber.java:// 给你一个仅由数字（0 - 9）组成的字符串num
class094/Code02_LargestPalindromicNumber.java:// 请你找出能够使用num中数字形成的最大回文整数
class094/Code02_LargestPalindromicNumber.java:// 并以字符串形式返回，该整数不含前导零
class094/Code02_LargestPalindromicNumber.java:// 你无需使用num中的所有数字，但你必须使用至少一个数字，数字可以重新排列
class094/Code02_LargestPalindromicNumber.java:// 测试链接 : https://leetcode.cn/problems/largest-palindromic-number/
class094/Code03_MaximumAveragePassRatio.java:// 最大平均通过率
class094/Code03_MaximumAveragePassRatio.java:// 一所学校里有一些班级，每个班级里有一些学生，现在每个班都会进行一场期末考试
class094/Code03_MaximumAveragePassRatio.java:// 给你一个二维数组classes，其中classes[i]=[passi, totali]
class094/Code03_MaximumAveragePassRatio.java:// 表示你提前知道了第i个班级总共有totali个学生
class094/Code03_MaximumAveragePassRatio.java:// 其中只有 passi 个学生可以通过考试
class094/Code03_MaximumAveragePassRatio.java:// 给你一个整数extraStudents，表示额外有extraStudents个聪明的学生，一定能通过期末考
class094/Code03_MaximumAveragePassRatio.java:// 你需要给这extraStudents个学生每人都安排一个班级，使得所有班级的平均通过率最大
class094/Code03_MaximumAveragePassRatio.java:// 一个班级的 通过率 等于这个班级通过考试的学生人数除以这个班级的总人数
class094/Code03_MaximumAveragePassRatio.java:// 平均通过率 是所有班级的通过率之和除以班级数目
class094/Code03_MaximumAveragePassRatio.java:// 请你返回在安排这extraStudents个学生去对应班级后的最大平均通过率
class094/Code03_MaximumAveragePassRatio.java:// 测试链接 : https://leetcode.cn/problems/maximum-average-pass-ratio/
class094/Code04_MinimumCostToHireWorkers.java:// 雇佣K名工人的最低成本
class094/Code04_MinimumCostToHireWorkers.java:// 有n名工人，给定两个数组quality和wage
class094/Code04_MinimumCostToHireWorkers.java:// 其中quality[i]表示第i名工人的工作质量，其最低期望工资为wage[i]
class094/Code04_MinimumCostToHireWorkers.java:// 现在我们想雇佣k名工人组成一个工资组
class094/Code04_MinimumCostToHireWorkers.java:// 在雇佣一组k名工人时，我们必须按照下述规则向他们支付工资：
class094/Code04_MinimumCostToHireWorkers.java:// 对工资组中的每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资
class094/Code04_MinimumCostToHireWorkers.java:// 工资组中的每名工人至少应当得到他们的最低期望工资
class094/Code04_MinimumCostToHireWorkers.java:// 给定整数k，返回组成满足上述条件的付费群体所需的最小金额
class094/Code04_MinimumCostToHireWorkers.java:// 测试链接 : https://leetcode.cn/problems/minimum-cost-to-hire-k-workers/
class094/Code05_CuttingTree.java:// 砍树
class094/Code05_CuttingTree.java:// 一共有n棵树，每棵树都有两个信息：
class094/Code05_CuttingTree.java:// 第一天这棵树的初始重量、这棵树每天的增长重量
class094/Code05_CuttingTree.java:// 你每天最多能砍1棵树，砍下这棵树的收益为：
class094/Code05_CuttingTree.java:// 这棵树的初始重量 + 这棵树增长到这一天的总增重
class094/Code05_CuttingTree.java:// 从第1天开始，你一共有m天可以砍树，返回m天内你获得的最大收益
class094/Code05_CuttingTree.java:// 测试链接 : https://pintia.cn/problem-sets/91827364500/exam/problems/91827367873
class094/Code05_CuttingTree.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class094/Code05_CuttingTree.java:// 这是输入输出处理效率很高的写法
class094/Code05_CuttingTree.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
算法讲解095【必备】博弈类问题必备内容详解-上
class095/Code01_BashGame.java:// 巴什博弈(Bash Game)
class095/Code01_BashGame.java:// 一共有n颗石子，两个人轮流拿，每次可以拿1~m颗石子
class095/Code01_BashGame.java:// 拿到最后一颗石子的人获胜，根据n、m返回谁赢
class095/Code02_PrimePowerStones.java:// 质数次方版取石子(巴什博弈扩展)
class095/Code02_PrimePowerStones.java:// 一共有n颗石子，两个人轮流拿
class095/Code02_PrimePowerStones.java:// 每一轮当前选手可以拿 p的k次方 颗石子
class095/Code02_PrimePowerStones.java:// 当前选手可以随意决定p和k，但要保证p是质数、k是自然数
class095/Code02_PrimePowerStones.java:// 拿到最后一颗石子的人获胜
class095/Code02_PrimePowerStones.java:// 根据石子数返回谁赢
class095/Code02_PrimePowerStones.java:// 如果先手赢，返回"October wins!"
class095/Code02_PrimePowerStones.java:// 如果后手赢，输出"Roy wins!"
class095/Code02_PrimePowerStones.java:// 测试链接 : https://www.luogu.com.cn/problem/P4018
class095/Code02_PrimePowerStones.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class095/Code02_PrimePowerStones.java:// 这是输入输出处理效率很高的写法
class095/Code02_PrimePowerStones.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class095/Code03_NimGame.java:// 尼姆博弈(Nim Game)
class095/Code03_NimGame.java:// 一共有n堆石头，两人轮流进行游戏
class095/Code03_NimGame.java:// 在每个玩家的回合中，玩家需要选择任何一个非空的石头堆，并从这堆石头中移除任意正数的石头数量
class095/Code03_NimGame.java:// 谁先拿走最后的石头就获胜，返回最终谁会获胜
class095/Code03_NimGame.java:// 测试链接 : https://www.luogu.com.cn/problem/P2197
class095/Code03_NimGame.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class095/Code03_NimGame.java:// 这是输入输出处理效率很高的写法
class095/Code03_NimGame.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class095/Code04_AntiNimGame.java:// 反尼姆博弈(反常游戏)
class095/Code04_AntiNimGame.java:// 一共有n堆石头，两人轮流进行游戏
class095/Code04_AntiNimGame.java:// 在每个玩家的回合中，玩家需要选择任何一个非空的石头堆，并从这堆石头中移除任意正数的石头数量
class095/Code04_AntiNimGame.java:// 谁先拿走最后的石头就失败，返回最终谁会获胜
class095/Code04_AntiNimGame.java:// 先手获胜，打印John
class095/Code04_AntiNimGame.java:// 后手获胜，打印Brother
class095/Code04_AntiNimGame.java:// 测试链接 : https://www.luogu.com.cn/problem/P4279
class095/Code04_AntiNimGame.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class095/Code04_AntiNimGame.java:// 这是输入输出处理效率很高的写法
class095/Code04_AntiNimGame.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class095/Code05_FibonacciGame.java:// 斐波那契博弈(Fibonacci Game + Zeckendorf定理)
class095/Code05_FibonacciGame.java:// 一共有n枚石子，两位玩家定了如下规则进行游戏：
class095/Code05_FibonacciGame.java:// 先手后手轮流取石子，先手在第一轮可以取走任意的石子
class095/Code05_FibonacciGame.java:// 接下来的每一轮当前的玩家最少要取走一个石子，最多取走上一次取的数量的2倍
class095/Code05_FibonacciGame.java:// 当然，玩家取走的数量必须不大于目前场上剩余的石子数量，双方都以最优策略取石子
class095/Code05_FibonacciGame.java:// 你也看出来了，根据规律先手一定会获胜，但是先手想知道
class095/Code05_FibonacciGame.java:// 第一轮自己取走至少几颗石子就可以保证获胜了
class095/Code05_FibonacciGame.java:// 测试链接 : https://www.luogu.com.cn/problem/P6487
class095/Code05_FibonacciGame.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class095/Code05_FibonacciGame.java:// 这是输入输出处理效率很高的写法
class095/Code05_FibonacciGame.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class095/Code06_WythoffGame.java:// 威佐夫博弈(Wythoff Game)
class095/Code06_WythoffGame.java:// 有两堆石子，数量任意，可以不同，游戏开始由两个人轮流取石子
class095/Code06_WythoffGame.java:// 游戏规定，每次有两种不同的取法
class095/Code06_WythoffGame.java:// 1) 在任意的一堆中取走任意多的石子
class095/Code06_WythoffGame.java:// 2) 可以在两堆中同时取走相同数量的石子
class095/Code06_WythoffGame.java:// 最后把石子全部取完者为胜者
class095/Code06_WythoffGame.java:// 现在给出初始的两堆石子的数目，返回先手能不能获胜
class095/Code06_WythoffGame.java:// 测试链接 : https://www.luogu.com.cn/problem/P2252
class095/Code06_WythoffGame.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class095/Code06_WythoffGame.java:// 这是输入输出处理效率很高的写法
class095/Code06_WythoffGame.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
算法讲解096【必备】博弈类问题必备内容详解-下
class096/Code01_BashGameSG.java:// 巴什博弈(SG函数求解过程展示)
class096/Code01_BashGameSG.java:// 一共有n颗石子，两个人轮流拿，每次可以拿1~m颗石子
class096/Code01_BashGameSG.java:// 拿到最后一颗石子的人获胜，根据n、m返回谁赢
class096/Code01_BashGameSG.java:// 对数器验证
class096/Code01_BashGameSG.java://		System.out.println("打印 n = " + n + ", m = " + m + " 的sg表");
class096/Code01_BashGameSG.java://		for (int i = 0; i <= n; i++) {
class096/Code01_BashGameSG.java://			System.out.println("sg(" + i + ") : " + sg[i]);
class096/Code01_BashGameSG.java://		}
class096/Code02_NimGameSG.java:// 尼姆博弈(SG定理简单用法展示)
class096/Code02_NimGameSG.java:// 一共有 n 堆石头，两人轮流进行游戏
class096/Code02_NimGameSG.java:// 在每个玩家的回合中，玩家需要 选择任一 非空 石头堆，从中移除任意 非零 数量的石头
class096/Code02_NimGameSG.java:// 如果不能移除任意的石头，就输掉游戏
class096/Code02_NimGameSG.java:// 返回先手是否一定获胜
class096/Code02_NimGameSG.java:// 对数器验证
class096/Code03_TwoStonesBashGame.java:// 两堆石头的巴什博弈
class096/Code03_TwoStonesBashGame.java:// 有两堆石头，数量分别为a、b
class096/Code03_TwoStonesBashGame.java:// 两个人轮流拿，每次可以选择其中一堆石头，拿1~m颗
class096/Code03_TwoStonesBashGame.java:// 拿到最后一颗石子的人获胜，根据a、b、m返回谁赢
class096/Code03_TwoStonesBashGame.java:// 来自真实大厂笔试，没有在线测试，对数器验证
class096/Code04_ThreeStonesPickFibonacci.java:// 三堆石头拿取斐波那契数博弈
class096/Code04_ThreeStonesPickFibonacci.java:// 有三堆石头，数量分别为a、b、c
class096/Code04_ThreeStonesPickFibonacci.java:// 两个人轮流拿，每次可以选择其中一堆石头，拿取斐波那契数的石头
class096/Code04_ThreeStonesPickFibonacci.java:// 拿到最后一颗石子的人获胜，根据a、b、c返回谁赢
class096/Code04_ThreeStonesPickFibonacci.java:// 来自真实大厂笔试，每堆石子的数量在10^5以内
class096/Code04_ThreeStonesPickFibonacci.java:// 没有在线测试，对数器验证
class096/Code05_EDGame1.java:// 计算两堆石子的SG值
class096/Code05_EDGame1.java:// 桌上有两堆石子，石头数量分别为a、b
class096/Code05_EDGame1.java:// 任取一堆石子，将其移走，然后分割同一组的另一堆石子
class096/Code05_EDGame1.java:// 从中取出若干个石子放在被移走的位置，组成新的一堆
class096/Code05_EDGame1.java:// 操作完成后，组内每堆的石子数必须保证大于0
class096/Code05_EDGame1.java:// 显然，被分割的一堆的石子数至少要为2
class096/Code05_EDGame1.java:// 两个人轮流进行分割操作，如果轮到某人进行操作时，两堆石子数均为1，判此人输掉比赛
class096/Code05_EDGame1.java:// 计算sg[a][b]的值并找到简洁规律
class096/Code05_EDGame1.java:// 本文件仅为题目5打表找规律的代码
class096/Code05_EDGame2.java:// E&D游戏
class096/Code05_EDGame2.java:// 桌子上有2n堆石子，编号为1、2、3...2n
class096/Code05_EDGame2.java:// 其中1、2为一组；3、4为一组；5、6为一组...2n-1、2n为一组
class096/Code05_EDGame2.java:// 每组可以进行分割操作：
class096/Code05_EDGame2.java:// 任取一堆石子，将其移走，然后分割同一组的另一堆石子
class096/Code05_EDGame2.java:// 从中取出若干个石子放在被移走的位置，组成新的一堆
class096/Code05_EDGame2.java:// 操作完成后，组内每堆的石子数必须保证大于0
class096/Code05_EDGame2.java:// 显然，被分割的一堆的石子数至少要为2
class096/Code05_EDGame2.java:// 两个人轮流进行分割操作，如果轮到某人进行操作时，所有堆的石子数均为1，判此人输掉比赛
class096/Code05_EDGame2.java:// 返回先手能不能获胜
class096/Code05_EDGame2.java:// 测试链接 : https://www.luogu.com.cn/problem/P2148
class096/Code05_EDGame2.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class096/Code05_EDGame2.java:// 这是输入输出处理效率很高的写法
class096/Code05_EDGame2.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class096/Code06_SplitGame.java:// 分裂游戏
class096/Code06_SplitGame.java:// 一共有n个瓶子，编号为0 ~ n-1，第i瓶里装有nums[i]个糖豆，每个糖豆认为无差别
class096/Code06_SplitGame.java:// 有两个玩家轮流取糖豆，每一轮的玩家必须选i、j、k三个编号，并且满足i < j <= k
class096/Code06_SplitGame.java:// 当前玩家从i号瓶中拿出一颗糖豆，分裂成两颗糖豆，并且往j、k瓶子中各放入一颗，分裂的糖豆继续无差别
class096/Code06_SplitGame.java:// 要求i号瓶一定要有糖豆，如果j == k，那么相当于从i号瓶中拿出一颗，向另一个瓶子放入了两颗
class096/Code06_SplitGame.java:// 如果轮到某个玩家发现所有糖豆都在n-1号瓶里，导致无法行动，那么该玩家输掉比赛
class096/Code06_SplitGame.java:// 先手希望知道，第一步如何行动可以保证自己获胜，要求返回字典序最小的行动
class096/Code06_SplitGame.java:// 第一步从0号瓶拿出一颗糖豆，并且往2、3号瓶中各放入一颗，可以确保最终自己获胜
class096/Code06_SplitGame.java:// 第一步从0号瓶拿出一颗糖豆，并且往11、13号瓶中各放入一颗，也可以确保自己获胜
class096/Code06_SplitGame.java:// 本题要求每个瓶子的编号看做是一个字符的情况下，最小的字典序，所以返回"0 2 3"
class096/Code06_SplitGame.java:// 如果先手怎么行动都无法获胜，返回"-1 -1 -1"
class096/Code06_SplitGame.java:// 先手还希望知道自己有多少种第一步取糖的行动，可以确保自己获胜，返回方法数
class096/Code06_SplitGame.java:// 测试链接 : https://www.luogu.com.cn/problem/P3185
class096/Code06_SplitGame.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class096/Code06_SplitGame.java:// 这是输入输出处理效率很高的写法
class096/Code06_SplitGame.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
算法讲解097【必备】质数判断、质因子分解、质数筛
class097/Code01_SmallNumberIsPrime.java:// 判断较小的数字是否是质数
class097/Code01_SmallNumberIsPrime.java:// 时间复杂度O(根号n)
class097/Code02_InputLong.java:// 读入long类型数字的注意点
class097/Code02_InputLong.java:// 讲解019的扩展，没有看过讲解019的同学去看一下
class097/Code02_LargeNumberIsPrime1.java:// 判断较大的数字是否是质数(Miller-Rabin测试)
class097/Code02_LargeNumberIsPrime1.java:// 测试链接 : https://www.luogu.com.cn/problem/U148828
class097/Code02_LargeNumberIsPrime1.java:// 如下代码无法通过所有测试用例
class097/Code02_LargeNumberIsPrime1.java:// 本文件可以解决10^9范围内数字的质数检查
class097/Code02_LargeNumberIsPrime1.java:// 时间复杂度O(s * (logn)的三次方)，很快
class097/Code02_LargeNumberIsPrime1.java:// 为什么不能搞定所有long类型的数字检查
class097/Code02_LargeNumberIsPrime1.java:// 原因在于long类型位数不够，乘法同余的时候会溢出，课上已经做了说明
class097/Code02_LargeNumberIsPrime2.java:// 判断较大的数字是否是质数(Miller-Rabin测试)
class097/Code02_LargeNumberIsPrime2.java:// 测试链接 : https://www.luogu.com.cn/problem/U148828
class097/Code02_LargeNumberIsPrime2.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class097/Code02_LargeNumberIsPrime2.java:// 这是输入输出处理效率很高的写法
class097/Code02_LargeNumberIsPrime2.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class097/Code02_LargeNumberIsPrime2.java:// 本文件可以搞定任意范围数字的质数检查，时间复杂度O(s * (logn)的三次方)
class097/Code02_LargeNumberIsPrime2.java:// 为什么不自己写，为什么要用BigInteger中的isProbablePrime方法
class097/Code02_LargeNumberIsPrime2.java:// 原因在于long类型位数不够，乘法同余的时候会溢出，课上已经做了说明
class097/Code02_LargeNumberIsPrime3.java:// 判断较大的数字是否是质数(Miller-Rabin测试)
class097/Code02_LargeNumberIsPrime3.java:// C++同学可以提交如下代码
class097/Code02_LargeNumberIsPrime3.java:// 可以通过所有测试用例，核心在于第11行，整型成了128位
class097/Code02_LargeNumberIsPrime3.java:// 测试链接 : https://www.luogu.com.cn/problem/U148828
class097/Code03_PrimeFactors.java:// 数字n拆分质数因子
class097/Code04_EhrlichAndEuler.java:// 计数质数
class097/Code04_EhrlichAndEuler.java:// 给定整数n，返回小于非负整数n的质数的数量
class097/Code04_EhrlichAndEuler.java:// 测试链接 : https://leetcode.cn/problems/count-primes/
算法讲解098【必备】快速幂、矩阵快速幂与两类问题
class098/Code01_QuickPower.java:// 乘法快速幂模版
class098/Code01_QuickPower.java:// 求a的b次方，对p取模的结果
class098/Code01_QuickPower.java:// 测试链接 : https://www.luogu.com.cn/problem/P1226
class098/Code01_QuickPower.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class098/Code01_QuickPower.java:// 这是输入输出处理效率很高的写法
class098/Code01_QuickPower.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class098/Code02_BigShow.java:// 矩阵乘法
class098/Code02_BigShow.java:// 矩阵快速幂
class098/Code02_BigShow.java:// 矩阵快速幂解决斐波那契第n项的问题
class098/Code02_FibonacciNumber.java:// 求斐波那契数列第n项
class098/Code02_FibonacciNumber.java:// 测试链接 : https://leetcode.cn/problems/fibonacci-number/
class098/Code02_FibonacciNumber.java:// 这个测试的数据量太小，并且不牵扯取模的事情
class098/Code02_FibonacciNumber.java:// 所以矩阵快速幂看不出优势
class098/Code03_ClimbingStairs.java:// 爬楼梯
class098/Code03_ClimbingStairs.java:// 假设你正在爬楼梯，每次你可以爬1或2个台阶
class098/Code03_ClimbingStairs.java:// 你有多少种不同的方法可以爬到n层
class098/Code03_ClimbingStairs.java:// 测试链接 : https://leetcode.cn/problems/climbing-stairs/
class098/Code03_ClimbingStairs.java:// 这个测试的数据量太小，并且不牵扯取模的事情
class098/Code03_ClimbingStairs.java:// 所以矩阵快速幂看不出优势
class098/Code04_TribonacciNumber.java:// 第n个泰波那契数
class098/Code04_TribonacciNumber.java:// t(0) = 0, t(1) = 1, t(2) = 1
class098/Code04_TribonacciNumber.java:// t(i) = t(i-1) + t(i-2) + t(i-3)
class098/Code04_TribonacciNumber.java:// 求t(n)
class098/Code04_TribonacciNumber.java:// 测试链接 : https://leetcode.cn/problems/n-th-tribonacci-number/
class098/Code04_TribonacciNumber.java:// 这个测试的数据量太小，并且不牵扯取模的事情
class098/Code04_TribonacciNumber.java:// 所以矩阵快速幂看不出优势
class098/Code05_DominoTromino.java:// 多米诺和托米诺平铺
class098/Code05_DominoTromino.java:// 有两种形状的瓷砖，一种是2*1的多米诺形，另一种是形如"L"的托米诺形
class098/Code05_DominoTromino.java:// 两种形状都可以旋转，给定整数n，返回可以平铺2*n的面板的方法数量
class098/Code05_DominoTromino.java:// 返回对1000000007取模的值
class098/Code05_DominoTromino.java:// 测试链接 : https://leetcode.cn/problems/domino-and-tromino-tiling/
class098/Code06_CountVowelsPermutation.java:// 统计元音字母序列的数目
class098/Code06_CountVowelsPermutation.java:// 给你一个整数n，请你帮忙统计一下我们可以按下述规则形成多少个长度为n的字符串：
class098/Code06_CountVowelsPermutation.java:// 字符串中的每个字符都应当是小写元音字母（'a', 'e', 'i', 'o', 'u'）
class098/Code06_CountVowelsPermutation.java:// 每个元音 'a' 后面都只能跟着 'e'
class098/Code06_CountVowelsPermutation.java:// 每个元音 'e' 后面只能跟着 'a' 或者是 'i'
class098/Code06_CountVowelsPermutation.java:// 每个元音 'i' 后面 不能 再跟着另一个 'i'
class098/Code06_CountVowelsPermutation.java:// 每个元音 'o' 后面只能跟着 'i' 或者是 'u'
class098/Code06_CountVowelsPermutation.java:// 每个元音 'u' 后面只能跟着 'a'
class098/Code06_CountVowelsPermutation.java:// 由于答案可能会很大，结果对1000000007取模
class098/Code06_CountVowelsPermutation.java:// 测试链接 : https://leetcode.cn/problems/count-vowels-permutation/
class098/Code07_StudentAttendanceRecordII.java:// 学生出勤记录II
class098/Code07_StudentAttendanceRecordII.java:// 可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）
class098/Code07_StudentAttendanceRecordII.java:// 记录中只含下面三种字符：
class098/Code07_StudentAttendanceRecordII.java:// 'A'：Absent，缺勤
class098/Code07_StudentAttendanceRecordII.java:// 'L'：Late，迟到
class098/Code07_StudentAttendanceRecordII.java:// 'P'：Present，到场
class098/Code07_StudentAttendanceRecordII.java:// 如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：
class098/Code07_StudentAttendanceRecordII.java:// 按 总出勤 计，学生缺勤（'A'）严格 少于两天
class098/Code07_StudentAttendanceRecordII.java:// 学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（'L'）记录。
class098/Code07_StudentAttendanceRecordII.java:// 给你一个整数n，表示出勤记录的长度（次数）
class098/Code07_StudentAttendanceRecordII.java:// 请你返回记录长度为n时，可能获得出勤奖励的记录情况数量
class098/Code07_StudentAttendanceRecordII.java:// 答案可能很大，结果对1000000007取模
class098/Code07_StudentAttendanceRecordII.java:// 测试链接 : https://leetcode.cn/problems/student-attendance-record-ii/
算法讲解099【扩展】逆元和除法同余、容斥原理
class099/Code01_InverseSingle.java:// 单个除数求逆元
class099/Code01_InverseSingle.java:// 对数器验证
class099/Code02_InverseSerial.java:// 连续数字逆元的线性递推
class099/Code02_InverseSerial.java:// 给定n、p，求1∼n中所有整数在模p意义下的乘法逆元
class099/Code02_InverseSerial.java:// 1 <= n <= 3 * 10^6
class099/Code02_InverseSerial.java:// n < p < 20000528
class099/Code02_InverseSerial.java:// 输入保证p为质数
class099/Code02_InverseSerial.java:// 测试链接 : https://www.luogu.com.cn/problem/P3811
class099/Code02_InverseSerial.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class099/Code02_InverseSerial.java:// 这是输入输出处理效率很高的写法
class099/Code02_InverseSerial.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class099/Code02_InverseSerial.java:// 如下代码可以通过全部测试用例
class099/Code02_InverseSerial.java:// 但是这个题卡常数比较严重
class099/Code02_InverseSerial.java:// 一般情况下不会如此卡常数
class099/Code02_InverseSerial.java:// 需要使用快读、快写增加IO效率
class099/Code03_InverseFactorial.java:// 连续阶乘逆元的线性递推
class099/Code03_InverseFactorial.java:// 实现组合公式C(n,m)的计算
class099/Code03_InverseFactorial.java:// 最终结果 % 1000000007后返回
class099/Code03_InverseFactorial.java:// 0 <= m <= n <= 1000
class099/Code03_InverseFactorial.java:// 对数器验证
class099/Code03_InverseFactorial.java://		inv[0] = 1;
class099/Code03_InverseFactorial.java://		for (int i = 1; i <= LIMIT; i++) {
class099/Code03_InverseFactorial.java://			inv[i] = power(fac[i], MOD - 2);
class099/Code03_InverseFactorial.java://		}
class099/Code04_NumberOfSubsetGcdK.java:// 最大公约数为1的子序列数量
class099/Code04_NumberOfSubsetGcdK.java:// 给你一个数组，返回有多少个子序列的最大公约数是1
class099/Code04_NumberOfSubsetGcdK.java:// 结果可能很大对1000000007取模
class099/Code04_NumberOfSubsetGcdK.java:// 测试链接 : https://www.luogu.com.cn/problem/CF803F
class099/Code04_NumberOfSubsetGcdK.java:// 测试链接 : https://codeforces.com/problemset/problem/803/F
class099/Code04_NumberOfSubsetGcdK.java:// 1 <= n <= 10^5
class099/Code04_NumberOfSubsetGcdK.java:// 1 <= nums[i] <= 10^5
class099/Code04_NumberOfSubsetGcdK.java:// 扩展问题
class099/Code04_NumberOfSubsetGcdK.java:// 最大公约数为k的子序列数量
class099/Code04_NumberOfSubsetGcdK.java:// 给定一个长度为n的正数数组nums，还有正数k
class099/Code04_NumberOfSubsetGcdK.java:// 返回有多少子序列的最大公约数为k
class099/Code04_NumberOfSubsetGcdK.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class099/Code04_NumberOfSubsetGcdK.java:// 这是输入输出处理效率很高的写法
class099/Code04_NumberOfSubsetGcdK.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class099/Code05_NumberOfBuyWay.java:// 多次查询购买方法
class099/Code05_NumberOfBuyWay.java:// 一共有4种硬币，面值分别为v0、v1、v2、v3，这个永远是确定的
class099/Code05_NumberOfBuyWay.java:// 每次去购物的细节由一个数组arr来表示，每次购物都是一次查询
class099/Code05_NumberOfBuyWay.java:// arr[0] = 携带v0面值的硬币数量
class099/Code05_NumberOfBuyWay.java:// arr[1] = 携带v1面值的硬币数量
class099/Code05_NumberOfBuyWay.java:// arr[2] = 携带v2面值的硬币数量
class099/Code05_NumberOfBuyWay.java:// arr[3] = 携带v3面值的硬币数量
class099/Code05_NumberOfBuyWay.java:// arr[4] = 本次购物一定要花多少钱
class099/Code05_NumberOfBuyWay.java:// 返回每次有多少种花钱的方法
class099/Code05_NumberOfBuyWay.java:// 1 <= v0、v1、v2、v3、arr[i] <= 10^5
class099/Code05_NumberOfBuyWay.java:// 查询数量 <= 1000
class099/Code05_NumberOfBuyWay.java:// 测试链接 : https://www.luogu.com.cn/problem/P1450
class099/Code05_NumberOfBuyWay.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class099/Code05_NumberOfBuyWay.java:// 这是输入输出处理效率很高的写法
class099/Code05_NumberOfBuyWay.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class099/Code06_NumberOfMusicPlaylists.java:// 播放列表的数量
class099/Code06_NumberOfMusicPlaylists.java:// 给定三个参数，n、l、k
class099/Code06_NumberOfMusicPlaylists.java:// 你的音乐播放器里有n首不同的歌
class099/Code06_NumberOfMusicPlaylists.java:// 在旅途中你的旅伴想要听l首歌
class099/Code06_NumberOfMusicPlaylists.java:// 听得歌曲不一定不同，即允许歌曲重复
class099/Code06_NumberOfMusicPlaylists.java:// 请你为她按如下两条规则创建一个播放列表
class099/Code06_NumberOfMusicPlaylists.java:// 1) 每首歌至少播放一次
class099/Code06_NumberOfMusicPlaylists.java:// 2) 一首歌只有在其他k首歌播放完之后才能再次播放
class099/Code06_NumberOfMusicPlaylists.java:// 返回可以满足要求的播放列表的数量
class099/Code06_NumberOfMusicPlaylists.java:// 结果可能很大对1000000007取模
class099/Code06_NumberOfMusicPlaylists.java:// 测试链接 : https://leetcode.cn/problems/number-of-music-playlists/
算法讲解100【扩展】 KMP算法原理和代码详解
class100/Code01_KMP.java:// KMP算法模版
class100/Code01_KMP.java:// 测试链接 : https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/
class100/Code02_SubtreeOfAnotherTree.java:// 另一棵树的子树
class100/Code02_SubtreeOfAnotherTree.java:// 给你两棵二叉树root和subRoot
class100/Code02_SubtreeOfAnotherTree.java:// 检验root中是否包含和subRoot具有相同结构和节点值的子树
class100/Code02_SubtreeOfAnotherTree.java:// 如果存在，返回true
class100/Code02_SubtreeOfAnotherTree.java:// 否则，返回false
class100/Code02_SubtreeOfAnotherTree.java:// 测试链接 : https://leetcode.cn/problems/subtree-of-another-tree/
算法讲解101【扩展】 KMP算法相关题目
class101/Code01_RepeatMinimumLength.java:// 最短循环节的长度
class101/Code01_RepeatMinimumLength.java:// 给你一个字符串s，它一定是由某个循环节不断自我连接形成的
class101/Code01_RepeatMinimumLength.java:// 题目保证至少重复2次，但是最后一个循环节不一定完整
class101/Code01_RepeatMinimumLength.java:// 现在想知道s的最短循环节是多长
class101/Code01_RepeatMinimumLength.java:// 测试链接 : https://www.luogu.com.cn/problem/P4391
class101/Code01_RepeatMinimumLength.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class101/Code01_RepeatMinimumLength.java:// 这是输入输出处理效率很高的写法
class101/Code01_RepeatMinimumLength.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class101/Code02_DeleteAgainAndAgain.java:// 不停删除之后剩下的字符串
class101/Code02_DeleteAgainAndAgain.java:// 给定一个字符串s1，如果其中含有s2字符串，就删除最左出现的那个
class101/Code02_DeleteAgainAndAgain.java:// 删除之后s1剩下的字符重新拼接在一起，再删除最左出现的那个
class101/Code02_DeleteAgainAndAgain.java:// 如此周而复始，返回最终剩下的字符串
class101/Code02_DeleteAgainAndAgain.java:// 测试链接 : https://www.luogu.com.cn/problem/P4824
class101/Code02_DeleteAgainAndAgain.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class101/Code02_DeleteAgainAndAgain.java:// 这是输入输出处理效率很高的写法
class101/Code02_DeleteAgainAndAgain.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class101/Code03_LinkedListInBinaryTree.java:// 二叉树中的链表
class101/Code03_LinkedListInBinaryTree.java:// 给你一棵以root为根的二叉树、一个以head为头的链表
class101/Code03_LinkedListInBinaryTree.java:// 在二叉树中，有很多一直向下的路径
class101/Code03_LinkedListInBinaryTree.java:// 如果某个路径上的数值等于以head为头的整个链表
class101/Code03_LinkedListInBinaryTree.java:// 返回True，否则返回False
class101/Code03_LinkedListInBinaryTree.java:// 测试链接 : https://leetcode.cn/problems/linked-list-in-binary-tree/
class101/Code04_FindAllGoodStrings.java:// 找到所有好字符串
class101/Code04_FindAllGoodStrings.java:// 给你两个长度为n的字符串s1和s2，以及一个字符串evil
class101/Code04_FindAllGoodStrings.java:// 好字符串的定义为 : 长度为n，字典序大于等于s1，字典序小于等于s2，且不包含evil字符串
class101/Code04_FindAllGoodStrings.java:// 返回好字符串的数量
class101/Code04_FindAllGoodStrings.java:// 由于答案很大返回对1000000007取余的结果
class101/Code04_FindAllGoodStrings.java:// 测试链接 : https://leetcode.cn/problems/find-all-good-strings/
算法讲解102【扩展】 AC自动机原理、优化、代码详解
class102/Code01_ACAM.java:// AC自动机模版(优化版)
class102/Code01_ACAM.java:// 给你若干目标字符串，还有一篇文章
class102/Code01_ACAM.java:// 返回每个目标字符串在文章中出现了几次
class102/Code01_ACAM.java:// 测试链接 : https://www.luogu.com.cn/problem/P5357
class102/Code01_ACAM.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class102/Code01_ACAM.java:// 这是输入输出处理效率很高的写法
class102/Code01_ACAM.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class102/Code02_Counting.java:// 数数(利用AC自动机检查命中)
class102/Code02_Counting.java:// 我们称一个正整数x为幸运数字的条件为
class102/Code02_Counting.java:// x的十进制中不包含数字串集合s中任意一个元素作为子串
class102/Code02_Counting.java:// 例如s = { 22, 333, 0233 }
class102/Code02_Counting.java:// 233是幸运数字，2333、20233、3223不是幸运数字
class102/Code02_Counting.java:// 给定n和s，计算不大于n的幸运数字的个数
class102/Code02_Counting.java:// 答案对1000000007取模
class102/Code02_Counting.java:// 测试链接 : https://www.luogu.com.cn/problem/P3311
class102/Code02_Counting.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class102/Code02_Counting.java:// 这是输入输出处理效率很高的写法
class102/Code02_Counting.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
算法讲解103【扩展】 Manacher算法、扩展KMP
class103/Code01_Manacher.java:// Manacher算法模版
class103/Code01_Manacher.java:// 求字符串s中最长回文子串的长度
class103/Code01_Manacher.java:// 测试链接 : https://www.luogu.com.cn/problem/P3805
class103/Code01_Manacher.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class103/Code01_Manacher.java:// 这是输入输出处理效率很高的写法
class103/Code01_Manacher.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class103/Code02_ExpandKMP.java:// 扩展KMP模版，又称Z算法或Z函数
class103/Code02_ExpandKMP.java:// 给定两个字符串a、b，求出两个数组
class103/Code02_ExpandKMP.java:// b与b每一个后缀串的最长公共前缀长度，z数组
class103/Code02_ExpandKMP.java:// b与a每一个后缀串的最长公共前缀长度，e数组
class103/Code02_ExpandKMP.java:// 计算出要求的两个数组后，输出这两个数组的权值即可
class103/Code02_ExpandKMP.java:// 对于一个数组x，i位置的权值定义为 : (i * (x[i] + 1))
class103/Code02_ExpandKMP.java:// 数组权值为所有位置权值的异或和
class103/Code02_ExpandKMP.java:// 测试链接 : https://www.luogu.com.cn/problem/P5410
class103/Code02_ExpandKMP.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class103/Code02_ExpandKMP.java:// 这是输入输出处理效率很高的写法
class103/Code02_ExpandKMP.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class103/Code03_MinimumTimeToInitialStateII.java:// 将单词恢复初始状态所需的最短时间II
class103/Code03_MinimumTimeToInitialStateII.java:// 给你一个下标从0开始的字符串word和一个整数k
class103/Code03_MinimumTimeToInitialStateII.java:// 在每一秒，必须执行以下操作
class103/Code03_MinimumTimeToInitialStateII.java:// 移除word的前k个字符
class103/Code03_MinimumTimeToInitialStateII.java:// 在word的末尾添加k个任意字符
class103/Code03_MinimumTimeToInitialStateII.java:// 添加的字符不必和移除的字符相同
class103/Code03_MinimumTimeToInitialStateII.java:// 返回将word恢复到初始状态所需的最短时间
class103/Code03_MinimumTimeToInitialStateII.java:// 该时间必须大于零
class103/Code03_MinimumTimeToInitialStateII.java:// 测试链接 : https://leetcode.cn/problems/minimum-time-to-revert-word-to-initial-state-ii/
算法讲解104【扩展】 Manacher算法相关题目
class104/Code01_LongestPalindromeSubstring.java:// 最长回文子串
class104/Code01_LongestPalindromeSubstring.java:// 找到字符串s中最长的回文子串并返回
class104/Code01_LongestPalindromeSubstring.java:// 测试链接 : https://leetcode.cn/problems/longest-palindromic-substring/
class104/Code02_NumberOfPalindromeSubstrings.java:// 回文子串数量
class104/Code02_NumberOfPalindromeSubstrings.java:// 返回字符串s的回文子串数量
class104/Code02_NumberOfPalindromeSubstrings.java:// 测试链接 : https://leetcode.cn/problems/palindromic-substrings/
class104/Code03_SplitMaximumPalindromes.java:// 不重叠回文子串的最多数目
class104/Code03_SplitMaximumPalindromes.java:// 给定一个字符串str和一个正数k
class104/Code03_SplitMaximumPalindromes.java:// 你可以随意把str切分成多个子串
class104/Code03_SplitMaximumPalindromes.java:// 目的是找到某一种划分方案，有尽可能多的回文子串
class104/Code03_SplitMaximumPalindromes.java:// 并且每个回文子串都要求长度>=k、且彼此没有重合的部分
class104/Code03_SplitMaximumPalindromes.java:// 返回最多能划分出几个这样的回文子串
class104/Code03_SplitMaximumPalindromes.java:// 测试链接 : https://leetcode.cn/problems/maximum-number-of-non-overlapping-palindrome-substrings/
class104/Code04_TopKOddLengthProduct.java:// 长度前k名的奇数长度回文子串长度乘积
class104/Code04_TopKOddLengthProduct.java:// 给定一个字符串s和数值k，只关心所有奇数长度的回文子串
class104/Code04_TopKOddLengthProduct.java:// 返回其中长度前k名的回文子串的长度乘积是多少
class104/Code04_TopKOddLengthProduct.java:// 如果奇数长度的回文子串个数不够k个，返回-1
class104/Code04_TopKOddLengthProduct.java:// 测试链接 : https://www.luogu.com.cn/problem/P1659
class104/Code04_TopKOddLengthProduct.java:// 答案对19930726取模
class104/Code04_TopKOddLengthProduct.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class104/Code04_TopKOddLengthProduct.java:// 这是输入输出处理效率很高的写法
class104/Code04_TopKOddLengthProduct.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class104/Code05_LongestDoublePalindrome.java:// 最长双回文串长度
class104/Code05_LongestDoublePalindrome.java:// 输入字符串s，求s的最长双回文子串t的长度
class104/Code05_LongestDoublePalindrome.java:// 双回文子串就是可以分成两个回文串的字符串
class104/Code05_LongestDoublePalindrome.java:// 比如"aabb"，可以分成"aa"、"bb"
class104/Code05_LongestDoublePalindrome.java:// 测试链接 : https://www.luogu.com.cn/problem/P4555
class104/Code05_LongestDoublePalindrome.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class104/Code05_LongestDoublePalindrome.java:// 这是输入输出处理效率很高的写法
class104/Code05_LongestDoublePalindrome.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
算法讲解105【扩展】字符串哈希原理、代码、题目详解
class105/Code01_DifferentStrings.java:// 统计有多少个不同的字符串
class105/Code01_DifferentStrings.java:// 测试链接 : https://www.luogu.com.cn/problem/P3370
class105/Code01_DifferentStrings.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class105/Code01_DifferentStrings.java:// 这是输入输出处理效率很高的写法
class105/Code01_DifferentStrings.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class105/Code02_NumberOfUniqueString.java:// 独特子串的数量
class105/Code02_NumberOfUniqueString.java:// 给你一个由数字组成的字符串s
class105/Code02_NumberOfUniqueString.java:// 返回s中独特子字符串数量
class105/Code02_NumberOfUniqueString.java:// 其中的每一个数字出现的频率都相同
class105/Code02_NumberOfUniqueString.java:// 测试链接 : https://leetcode.cn/problems/unique-substrings-with-equal-digit-frequency/
class105/Code03_SubstringHash.java:// 字符串哈希得到子串哈希
class105/Code03_SubstringHash.java:// 利用字符串哈希的便利性替代KMP算法
class105/Code03_SubstringHash.java:// 测试链接 : https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/
class105/Code04_RepeatedStringMatch.java:// 重复叠加字符串匹配
class105/Code04_RepeatedStringMatch.java:// 给定两个字符串a和b，寻找重复叠加字符串a的最小次数，使得字符串b成为叠加后的字符串a的子串
class105/Code04_RepeatedStringMatch.java:// 如果不存在则返回-1
class105/Code04_RepeatedStringMatch.java:// 字符串"abc"重复叠加0次是""
class105/Code04_RepeatedStringMatch.java:// 重复叠加1次是"abc"
class105/Code04_RepeatedStringMatch.java:// 重复叠加2次是"abcabc"
class105/Code04_RepeatedStringMatch.java:// 测试链接 : https://leetcode.cn/problems/repeated-string-match/
class105/Code05_ConcatenationAllWords.java:// 串联所有单词的子串
class105/Code05_ConcatenationAllWords.java:// 给定一个字符串s和一个字符串数组words
class105/Code05_ConcatenationAllWords.java:// words中所有字符串长度相同
class105/Code05_ConcatenationAllWords.java:// s中的串联子串是指一个包含 words中所有字符串以任意顺序排列连接起来的子串
class105/Code05_ConcatenationAllWords.java:// 例如words = { "ab","cd","ef" }
class105/Code05_ConcatenationAllWords.java:// 那么"abcdef"、"abefcd"、"cdabef"、"cdefab"、"efabcd"、"efcdab"都是串联子串。 
class105/Code05_ConcatenationAllWords.java:// "acdbef"不是串联子串，因为他不是任何words排列的连接
class105/Code05_ConcatenationAllWords.java:// 返回所有串联子串在s中的开始索引
class105/Code05_ConcatenationAllWords.java:// 你可以以任意顺序返回答案
class105/Code05_ConcatenationAllWords.java:// 测试链接 : https://leetcode.cn/problems/substring-with-concatenation-of-all-words/
class105/Code06_LikeLotusRoot.java:// 根据匹配定义求匹配子串的数量
class105/Code06_LikeLotusRoot.java:// 给定长为n的字符串s，以及长度为m的字符串p，还有一个正数k
class105/Code06_LikeLotusRoot.java:// s'与s匹配的定义为，s'与s长度相同，且最多有k个位置字符不同
class105/Code06_LikeLotusRoot.java:// 要求查找字符串s中有多少子串与字符串p匹配
class105/Code06_LikeLotusRoot.java:// 测试链接 : https://www.luogu.com.cn/problem/P3763
class105/Code06_LikeLotusRoot.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class105/Code06_LikeLotusRoot.java:// 这是输入输出处理效率很高的写法
class105/Code06_LikeLotusRoot.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
算法讲解106【扩展】哈希函数、哈希表、布隆过滤器、一致性哈希
//		for (String str : strs) {
//			System.out.println(str);
//		}
//		for (String str : set) {
//			System.out.println(str);
//		}
算法讲解107【扩展】大厂面试中经常漫聊的有趣算法问题
class107/Code01_ReservoirSampling.java:// 蓄水池采样
class107/Code01_ReservoirSampling.java:// 假设有一个不停吐出球的机器，每次吐出1号球、2号球、3号球...
class107/Code01_ReservoirSampling.java:// 有一个袋子只能装下10个球，每次机器吐出的球，要么放入袋子，要么永远扔掉
class107/Code01_ReservoirSampling.java:// 如何做到机器吐出每一个球之后，所有吐出的球都等概率被放进袋子里
class107/Code07_PrisonersEscapeGame.java:// 囚徒生存问题
class107/Code07_PrisonersEscapeGame.java:// 有100个犯人被关在监狱，犯人编号0~99，监狱长准备了100个盒子，盒子编号0~99
class107/Code07_PrisonersEscapeGame.java:// 这100个盒子排成一排，放在一个房间里面，盒子编号从左往右有序排列
class107/Code07_PrisonersEscapeGame.java:// 最开始时，每个犯人的编号放在每个盒子里，两种编号一一对应，监狱长构思了一个处决犯人的计划
class107/Code07_PrisonersEscapeGame.java:// 监狱长打开了很多盒子，并交换了盒子里犯人的编号
class107/Code07_PrisonersEscapeGame.java:// 交换行为完全随机，但依然保持每个盒子都有一个犯人编号
class107/Code07_PrisonersEscapeGame.java:// 监狱长规定，每个犯人单独进入房间，可以打开50个盒子，寻找自己的编号
class107/Code07_PrisonersEscapeGame.java:// 该犯人全程无法和其他犯人进行任何交流，并且不能交换盒子中的编号，只能打开查看
class107/Code07_PrisonersEscapeGame.java:// 寻找过程结束后把所有盒子关上，走出房间，然后下一个犯人再进入房间，重复上述过程
class107/Code07_PrisonersEscapeGame.java:// 监狱长规定，每个犯人在尝试50次的过程中，都需要找到自己的编号
class107/Code07_PrisonersEscapeGame.java:// 如果有任何一个犯人没有做到这一点，100个犯人全部处决
class107/Code07_PrisonersEscapeGame.java:// 所有犯人在一起交谈的时机只能发生在游戏开始之前，游戏一旦开始直到最后一个人结束都无法交流
class107/Code07_PrisonersEscapeGame.java:// 请尽量制定一个让所有犯人存活概率最大的策略
class107/Code07_PrisonersEscapeGame.java:// 来自论文<The Cell Probe Complexity of Succinct Data Structures>
class107/Code07_PrisonersEscapeGame.java:// 作者Anna Gal和Peter Bro Miltersen写于2007年
class107/Code07_PrisonersEscapeGame.java:// 如今该题变成了流行题，还有大量科普视频
算法讲解108【扩展】树状数组原理、扩展、代码详解
class108/Code01_IndexTreeSingleAddIntervalQuery.java:// 树状数组单点增加、范围查询模版
class108/Code01_IndexTreeSingleAddIntervalQuery.java:// 测试链接 : https://www.luogu.com.cn/problem/P3374
class108/Code01_IndexTreeSingleAddIntervalQuery.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class108/Code01_IndexTreeSingleAddIntervalQuery.java:// 这是输入输出处理效率很高的写法
class108/Code01_IndexTreeSingleAddIntervalQuery.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class108/Code02_IndexTreeIntervalAddSingleQuery.java:// 树状数组范围增加、单点查询模版
class108/Code02_IndexTreeIntervalAddSingleQuery.java:// 测试链接 : https://www.luogu.com.cn/problem/P3368
class108/Code02_IndexTreeIntervalAddSingleQuery.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class108/Code02_IndexTreeIntervalAddSingleQuery.java:// 这是输入输出处理效率很高的写法
class108/Code02_IndexTreeIntervalAddSingleQuery.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class108/Code03_IndexTreeIntervalAddIntervalQuery.java:// 树状数组范围增加、范围查询模版
class108/Code03_IndexTreeIntervalAddIntervalQuery.java:// 测试链接 : https://www.luogu.com.cn/problem/P3372
class108/Code03_IndexTreeIntervalAddIntervalQuery.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class108/Code03_IndexTreeIntervalAddIntervalQuery.java:// 这是输入输出处理效率很高的写法
class108/Code03_IndexTreeIntervalAddIntervalQuery.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class108/Code04_TwoDimensionSingleAddIntervalQuery.java:// 二维数组上单点增加、范围查询，使用树状数组的模版
class108/Code04_TwoDimensionSingleAddIntervalQuery.java:// 测试链接 : https://leetcode.cn/problems/range-sum-query-2d-mutable/
class108/Code05_TwoDimensionIntervalAddIntervalQuery1.java:// 二维数组上范围增加、范围查询，使用树状数组的模版(java)
class108/Code05_TwoDimensionIntervalAddIntervalQuery1.java:// 测试链接 : https://www.luogu.com.cn/problem/P4514
class108/Code05_TwoDimensionIntervalAddIntervalQuery1.java:// 如下实现是正确的，但是洛谷平台对空间卡的很严，只有使用C++能全部通过
class108/Code05_TwoDimensionIntervalAddIntervalQuery1.java:// java的版本就是无法完全通过的，空间会超过限制，主要是IO空间占用大
class108/Code05_TwoDimensionIntervalAddIntervalQuery1.java:// 这是洛谷平台没有照顾各种语言的实现所导致的
class108/Code05_TwoDimensionIntervalAddIntervalQuery1.java:// 在真正笔试、比赛时，一定是兼顾各种语言的，该实现是一定正确的
class108/Code05_TwoDimensionIntervalAddIntervalQuery1.java:// C++版本就是Code05_TwoDimensionIntervalAddIntervalQuery2文件
class108/Code05_TwoDimensionIntervalAddIntervalQuery1.java:// C++版本和java版本逻辑完全一样，但只有C++版本可以通过所有测试用例
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java:// 二维数组上范围增加、范围查询，使用树状数组的模版(C++)
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java:// 测试链接 : https://www.luogu.com.cn/problem/P4514
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java:// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java:// 提交如下代码，可以通过所有测试用例
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://#include <cstdio>
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://using namespace std;
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://const int MAXN = 2050;
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://const int MAXM = 2050;
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://int info1[MAXN][MAXM], info2[MAXN][MAXM], info3[MAXN][MAXM], info4[MAXN][MAXM];
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://int n, m;
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://int lowbit(int i) {
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://    return i & -i;
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://}
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://void add(int x, int y, int v) {
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://    int v1 = v;
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://    int v2 = x * v;
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://    int v3 = y * v;
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://    int v4 = x * y * v;
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://    for (int i = x; i <= n; i += lowbit(i)) {
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://        for (int j = y; j <= m; j += lowbit(j)) {
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://            info1[i][j] += v1;
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://            info2[i][j] += v2;
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://            info3[i][j] += v3;
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://            info4[i][j] += v4;
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://        }
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://    }
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://}
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://int sum(int x, int y) {
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://    int ans = 0;
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://    for (int i = x; i > 0; i -= lowbit(i)) {
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://        for (int j = y; j > 0; j -= lowbit(j)) {
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://            ans += (x + 1) * (y + 1) * info1[i][j] - (y + 1) * info2[i][j] - (x + 1) * info3[i][j] + info4[i][j];
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://        }
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://    }
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://    return ans;
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://}
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://void add(int a, int b, int c, int d, int v) {
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://    add(a, b, v);
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://    add(c + 1, d + 1, v);
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://    add(a, d + 1, -v);
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://    add(c + 1, b, -v);
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://}
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://int range(int a, int b, int c, int d) {
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://    return sum(c, d) - sum(a - 1, d) - sum(c, b - 1) + sum(a - 1, b - 1);
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://}
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://int main() {
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://    char op;
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://    int a, b, c, d, v;
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://    scanf("%s", &op);
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://    scanf("%d%d", &n, &m);
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://    while (scanf("%s", &op) != EOF) {
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://        if (op == 'X') {
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://            scanf("%d%d", &n, &m);
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://        } else if (op == 'L') {
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://            scanf("%d%d%d%d%d", &a, &b, &c, &d, &v);
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://            add(a, b, c, d, v);
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://        } else {
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://            scanf("%d%d%d%d", &a, &b, &c, &d);
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://            printf("%d\n", range(a, b, c, d));
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://        }
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://    }
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://    return 0;
class108/Code05_TwoDimensionIntervalAddIntervalQuery2.java://}
算法讲解109【扩展】树状数组相关题目
class109/Code01_NumberOfReversePair1.java:// 逆序对数量(归并分治)
class109/Code01_NumberOfReversePair1.java:// 给定一个长度为n的数组arr
class109/Code01_NumberOfReversePair1.java:// 如果 i < j 且 arr[i] > arr[j]
class109/Code01_NumberOfReversePair1.java:// 那么(i,j)就是一个逆序对
class109/Code01_NumberOfReversePair1.java:// 求arr中逆序对的数量
class109/Code01_NumberOfReversePair1.java:// 1 <= n <= 5 * 10^5
class109/Code01_NumberOfReversePair1.java:// 1 <= arr[i] <= 10^9
class109/Code01_NumberOfReversePair1.java:// 测试链接 : https://www.luogu.com.cn/problem/P1908
class109/Code01_NumberOfReversePair1.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class109/Code01_NumberOfReversePair1.java:// 这是输入输出处理效率很高的写法
class109/Code01_NumberOfReversePair1.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class109/Code01_NumberOfReversePair2.java:// 逆序对数量(值域树状数组)
class109/Code01_NumberOfReversePair2.java:// 给定一个长度为n的数组arr
class109/Code01_NumberOfReversePair2.java:// 如果 i < j 且 arr[i] > arr[j]
class109/Code01_NumberOfReversePair2.java:// 那么(i,j)就是一个逆序对
class109/Code01_NumberOfReversePair2.java:// 求arr中逆序对的数量
class109/Code01_NumberOfReversePair2.java:// 1 <= n <= 5 * 10^5
class109/Code01_NumberOfReversePair2.java:// 1 <= arr[i] <= 10^9
class109/Code01_NumberOfReversePair2.java:// 测试链接 : https://www.luogu.com.cn/problem/P1908
class109/Code01_NumberOfReversePair2.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class109/Code01_NumberOfReversePair2.java:// 这是输入输出处理效率很高的写法
class109/Code01_NumberOfReversePair2.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class109/Code02_IncreasingTriples.java:// 升序三元组数量
class109/Code02_IncreasingTriples.java:// 给定一个数组arr，如果i < j < k且arr[i] < arr[j] < arr[k]
class109/Code02_IncreasingTriples.java:// 那么称(i, j, k)为一个升序三元组
class109/Code02_IncreasingTriples.java:// 返回arr中升序三元组的数量
class109/Code02_IncreasingTriples.java:// 测试链接 : https://www.luogu.com.cn/problem/P1637
class109/Code02_IncreasingTriples.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class109/Code02_IncreasingTriples.java:// 这是输入输出处理效率很高的写法
class109/Code02_IncreasingTriples.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class109/Code03_NumberOfLIS.java:// 最长递增子序列的个数
class109/Code03_NumberOfLIS.java:// 给定一个未排序的整数数组nums，返回最长递增子序列的个数
class109/Code03_NumberOfLIS.java:// 测试链接 : https://leetcode.cn/problems/number-of-longest-increasing-subsequence/
class109/Code03_NumberOfLIS.java:// 本题在讲解072，最长递增子序列问题与扩展，就做出过预告
class109/Code03_NumberOfLIS.java:// 具体可以看讲解072视频最后的部分
class109/Code03_NumberOfLIS.java:// 用树状数组实现时间复杂度O(n * logn)
class109/Code04_DifferentColors.java:// HH的项链
class109/Code04_DifferentColors.java:// 一共有n个位置，每个位置颜色给定，i位置的颜色是arr[i]
class109/Code04_DifferentColors.java:// 一共有m个查询，question[i] = {li, ri}
class109/Code04_DifferentColors.java:// 表示第i条查询想查arr[li..ri]范围上一共有多少种不同颜色
class109/Code04_DifferentColors.java:// 返回每条查询的答案
class109/Code04_DifferentColors.java:// 1 <= n、m、arr[i] <= 10^6
class109/Code04_DifferentColors.java:// 1 <= li <= ri <= n
class109/Code04_DifferentColors.java:// 测试链接 : https://www.luogu.com.cn/problem/P1972
class109/Code04_DifferentColors.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class109/Code04_DifferentColors.java:// 这是输入输出处理效率很高的写法
class109/Code04_DifferentColors.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class109/Code05_MinimumNumberOfMovesToMakePalindrome.java:// 得到回文串的最少操作次数
class109/Code05_MinimumNumberOfMovesToMakePalindrome.java:// 给你一个只包含小写英文字母的字符串s
class109/Code05_MinimumNumberOfMovesToMakePalindrome.java:// 每一次操作可以选择s中两个相邻的字符进行交换
class109/Code05_MinimumNumberOfMovesToMakePalindrome.java:// 返回将s变成回文串的最少操作次数
class109/Code05_MinimumNumberOfMovesToMakePalindrome.java:// 输入数据会确保s一定能变成一个回文串
class109/Code05_MinimumNumberOfMovesToMakePalindrome.java:// 测试链接 : https://leetcode.cn/problems/minimum-number-of-moves-to-make-palindrome/
算法讲解110【扩展】线段树专题1-线段树原理和代码详解
class110/Code01_SegmentTreeAddQuerySum.java:// 线段树支持范围增加、范围查询
class110/Code01_SegmentTreeAddQuerySum.java:// 维护累加和
class110/Code01_SegmentTreeAddQuerySum.java:// 测试链接 : https://www.luogu.com.cn/problem/P3372
class110/Code01_SegmentTreeAddQuerySum.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class110/Code01_SegmentTreeAddQuerySum.java:// 这是输入输出处理效率很高的写法
class110/Code01_SegmentTreeAddQuerySum.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class110/Code02_SegmentTreeUpdateQuerySum.java:// 线段树支持范围重置、范围查询
class110/Code02_SegmentTreeUpdateQuerySum.java:// 维护累加和
class110/Code02_SegmentTreeUpdateQuerySum.java:// 对数器验证
class110/Code02_SegmentTreeUpdateQuerySum.java:// 当你写线段树出错了，就需要用对数器的方式来排查
class110/Code02_SegmentTreeUpdateQuerySum.java:// 所以本题选择对数器验证，来展示一下怎么写测试
class110/Code03_SegmentTreeAddQueryMax.java:// 线段树支持范围增加、范围查询
class110/Code03_SegmentTreeAddQueryMax.java:// 维护最大值
class110/Code03_SegmentTreeAddQueryMax.java:// 对数器验证
class110/Code03_SegmentTreeAddQueryMax.java:// 当你写线段树出错了，就需要用对数器的方式来排查
class110/Code03_SegmentTreeAddQueryMax.java:// 所以本题选择对数器验证，来展示一下怎么写测试
class110/Code04_SegmentTreeUpdateQueryMax.java:// 线段树支持范围重置、范围查询
class110/Code04_SegmentTreeUpdateQueryMax.java:// 维护最大值
class110/Code04_SegmentTreeUpdateQueryMax.java:// 对数器验证
class110/Code04_SegmentTreeUpdateQueryMax.java:// 当你写线段树出错了，就需要用对数器的方式来排查
class110/Code04_SegmentTreeUpdateQueryMax.java:// 所以本题选择对数器验证，来展示一下怎么写测试
class110/Code05_SegmentTreeUpdateAddQuerySum.java:// 线段树同时支持范围重置、范围增加、范围查询
class110/Code05_SegmentTreeUpdateAddQuerySum.java:// 维护累加和
class110/Code05_SegmentTreeUpdateAddQuerySum.java:// 对数器验证
class110/Code05_SegmentTreeUpdateAddQuerySum.java:// 当你写线段树出错了，就需要用对数器的方式来排查
class110/Code05_SegmentTreeUpdateAddQuerySum.java:// 所以本题选择对数器验证，来展示一下怎么写测试
class110/Code06_SegmentTreeUpdateAddQueryMax.java:// 线段树同时支持范围重置、范围增加、范围查询
class110/Code06_SegmentTreeUpdateAddQueryMax.java:// 维护最大值
class110/Code06_SegmentTreeUpdateAddQueryMax.java:// 测试链接 : https://www.luogu.com.cn/problem/P1253
class110/Code06_SegmentTreeUpdateAddQueryMax.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class110/Code06_SegmentTreeUpdateAddQueryMax.java:// 这是输入输出处理效率很高的写法
class110/Code06_SegmentTreeUpdateAddQueryMax.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class110/HowManySpace.java:// 线段树范围为1 ~ n时，需要几倍空间才够用？
算法讲解111【扩展】线段树专题2-线段树的离散化、二分搜索、特别修改
class111/Code01_FallingSquares.java:// 掉落的方块
class111/Code01_FallingSquares.java:// 有一个二维平面，x轴是最底的边界
class111/Code01_FallingSquares.java:// 给定二维整数数组pos，pos[i] = [ lefti, leni ]
class111/Code01_FallingSquares.java:// 表示第i个方块边长为leni，左侧边缘在x = lefti位置，所在高度非常高
class111/Code01_FallingSquares.java:// 所有方块都是正方形，依次从高处垂直掉落，也就是左边界顺着x = lefti往下
class111/Code01_FallingSquares.java:// 如果掉落的方块碰到已经掉落正方形的顶边或者x轴就停止掉落
class111/Code01_FallingSquares.java:// 如果方块掉落时仅仅是擦过已经掉落正方形的左侧边或右侧边，并不会停止掉落
class111/Code01_FallingSquares.java:// 一旦停止，它就会固定在那里，无法再移动，俄罗斯方块游戏和本题意思一样
class111/Code01_FallingSquares.java:// 返回一个整数数组ans ，其中ans[i]表示在第i块方块掉落后整体的最大高度
class111/Code01_FallingSquares.java:// 1 <= pos数组长度 <= 1000，1 <= lefti <= 10^8，1 <= leni <= 10^6
class111/Code01_FallingSquares.java:// 测试链接 : https://leetcode.cn/problems/falling-squares
class111/Code02_VasesAndFlowers.java:// 瓶子里的花朵
class111/Code02_VasesAndFlowers.java:// 给定n个瓶子，编号从0~n-1，一开始所有瓶子都是空的
class111/Code02_VasesAndFlowers.java:// 每个瓶子最多插入一朵花，实现以下两种类型的操作
class111/Code02_VasesAndFlowers.java:// 操作 1 from flower : 一共有flower朵花，从from位置开始依次插入花朵，已经有花的瓶子跳过
class111/Code02_VasesAndFlowers.java://                     如果一直到最后的瓶子，花也没有用完，就丢弃剩下的花朵
class111/Code02_VasesAndFlowers.java://                     返回这次操作插入的首个空瓶的位置 和 最后空瓶的位置
class111/Code02_VasesAndFlowers.java://                     如果从from开始所有瓶子都有花，打印"Can not put any one."
class111/Code02_VasesAndFlowers.java:// 操作 2 left right  : 从left位置开始到right位置的瓶子，变回空瓶，返回清理花朵的数量
class111/Code02_VasesAndFlowers.java:// 测试链接 : https://acm.hdu.edu.cn/showproblem.php?pid=4614
class111/Code02_VasesAndFlowers.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class111/Code02_VasesAndFlowers.java:// 这是输入输出处理效率很高的写法
class111/Code02_VasesAndFlowers.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class111/Code03_SquareRoot.java:// 范围上开平方并求累加和
class111/Code03_SquareRoot.java:// 给定一个长度为n的数组arr，实现以下两种类型的操作
class111/Code03_SquareRoot.java:// 操作 0 l r : 把arr[l..r]范围上的每个数开平方，结果向下取整
class111/Code03_SquareRoot.java:// 操作 1 l r : 查询arr[l..r]范围上所有数字的累加和
class111/Code03_SquareRoot.java:// 两种操作一共发生m次，数据中有可能l>r，遇到这种情况请交换l和r
class111/Code03_SquareRoot.java:// 1 <= n, m <= 10^5，1 <= arr[i] <= 10^12
class111/Code03_SquareRoot.java:// 测试链接 : https://www.luogu.com.cn/problem/P4145
class111/Code03_SquareRoot.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class111/Code03_SquareRoot.java:// 这是输入输出处理效率很高的写法
class111/Code03_SquareRoot.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class111/Code04_QueryModUpdate.java:// 包含取模操作的线段树
class111/Code04_QueryModUpdate.java:// 给定一个长度为n的数组arr，实现如下三种操作，一共调用m次
class111/Code04_QueryModUpdate.java:// 操作 1 l r : 查询arr[l..r]的累加和
class111/Code04_QueryModUpdate.java:// 操作 2 l r x : 把arr[l..r]上每个数字对x取模
class111/Code04_QueryModUpdate.java:// 操作 3 k x : 把arr[k]上的数字设置为x
class111/Code04_QueryModUpdate.java:// 1 <= n, m <= 10^5，操作1得到的结果，有可能超过int范围
class111/Code04_QueryModUpdate.java:// 测试链接 : https://www.luogu.com.cn/problem/CF438D
class111/Code04_QueryModUpdate.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class111/Code04_QueryModUpdate.java:// 这是输入输出处理效率很高的写法
class111/Code04_QueryModUpdate.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class111/Code05_Posters1.java:// 贴海报
class111/Code05_Posters1.java:// 有一面墙，有固定高度，长度为n，有m张海报，所有海报的高度都和墙的高度相同
class111/Code05_Posters1.java:// 从第1张海报开始，一张一张往墙上贴，直到n张海报贴完
class111/Code05_Posters1.java:// 每张海报都给出张贴位置(xi, yi)，表示第i张海报从墙的左边界xi一直延伸到右边界yi
class111/Code05_Posters1.java:// 有可能发生后面的海报把前面的海报完全覆盖，导致看不到的情况
class111/Code05_Posters1.java:// 当所有海报贴完，返回能看到海报的数量，哪怕只漏出一点的海报都算
class111/Code05_Posters1.java:// 1 <= n、xi、yi <= 10^7，1 <= m <= 10^3
class111/Code05_Posters1.java:// 测试链接 : https://www.luogu.com.cn/problem/P3740
class111/Code05_Posters1.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class111/Code05_Posters1.java:// 这是输入输出处理效率很高的写法
class111/Code05_Posters1.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class111/Code05_Posters2.java:// 贴海报(数据加强版)
class111/Code05_Posters2.java:// 有一面墙，有固定高度，无限的宽度，有n张海报，所有海报的高度都和墙的高度相同
class111/Code05_Posters2.java:// 从第1张海报开始，一张一张往墙上贴，直到n张海报贴完
class111/Code05_Posters2.java:// 每张海报都给出张贴位置(xi, yi)，表示第i张海报从墙的左边界xi一直延伸到右边界yi
class111/Code05_Posters2.java:// 有可能发生后面的海报把前面的海报完全覆盖，导致看不到的情况
class111/Code05_Posters2.java:// 当所有海报贴完，返回能看到海报的数量，哪怕只漏出一点的海报都算
class111/Code05_Posters2.java:// 1 <= n <= 10^5，1 <= xi、yi <= 10^7
class111/Code05_Posters2.java:// 测试链接 : http://poj.org/problem?id=2528
class111/Code05_Posters2.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class111/Code05_Posters2.java:// 这是输入输出处理效率很高的写法
class111/Code05_Posters2.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
算法讲解112【扩展】线段树专题3-线段树维护更多类型的信息
class112/Code01_Switch.java:// 开关
class112/Code01_Switch.java:// 现有n盏灯排成一排，从左到右依次编号为1~n，一开始所有的灯都是关着的
class112/Code01_Switch.java:// 操作分两种
class112/Code01_Switch.java:// 操作 0 l r : 改变l~r范围上所有灯的状态，开着的灯关上、关着的灯打开
class112/Code01_Switch.java:// 操作 1 l r : 查询l~r范围上有多少灯是打开的
class112/Code01_Switch.java:// 测试链接 : https://www.luogu.com.cn/problem/P3870
class112/Code01_Switch.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class112/Code01_Switch.java:// 这是输入输出处理效率很高的写法
class112/Code01_Switch.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class112/Code02_Bombs.java:// 贪婪大陆
class112/Code02_Bombs.java:// 一共有n个格子，编号1~n，开始时格子上没有地雷，实现两种操作，一共调用m次
class112/Code02_Bombs.java:// 操作 1 l r : 在l~r范围的格子上放置一种新型地雷，每次地雷都是新款
class112/Code02_Bombs.java:// 操作 2 l r : 查询l~r范围的格子上一共放置过多少款不同的地雷
class112/Code02_Bombs.java:// 操作1并不是范围上替换地雷，而是范围上新增新型地雷，注意如下的例子
class112/Code02_Bombs.java:// 执行 1 3 6，表示3~6范围上新加一种地雷，假设地雷类型是A
class112/Code02_Bombs.java:// 执行 1 3 4，表示3~4范围上又新加一种地雷，和上次的地雷不同，假设地雷类型是B
class112/Code02_Bombs.java:// 格子3有两种地雷(A、B)、格子4有两种地雷(A、B)、格子5有一种地雷(A)、格子6有一种地雷(A)
class112/Code02_Bombs.java:// 执行 2 4 5，返回2；执行 2 5 6，会返回1
class112/Code02_Bombs.java:// 测试链接 : https://www.luogu.com.cn/problem/P2184
class112/Code02_Bombs.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class112/Code02_Bombs.java:// 这是输入输出处理效率很高的写法
class112/Code02_Bombs.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class112/Code03_BoringSequence.java:// 无聊的数列
class112/Code03_BoringSequence.java:// 给定一个长度为n的数组arr，实现如下两种操作
class112/Code03_BoringSequence.java:// 操作 1 l r k d : arr[l..r]范围上的数依次加上等差数列，首项k，公差d
class112/Code03_BoringSequence.java:// 操作 2 p       : 查询arr[p]的值
class112/Code03_BoringSequence.java:// 测试链接 : https://www.luogu.com.cn/problem/P1438
class112/Code03_BoringSequence.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class112/Code03_BoringSequence.java:// 这是输入输出处理效率很高的写法
class112/Code03_BoringSequence.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class112/Code04_DoubleString.java:// 读取科学计数法表达的double数字
class112/Code04_DoubleString.java:// 如果输入的字符串代表double数字的科学计数法形式
class112/Code04_DoubleString.java:// 用StreamTokenizer读取会出错
class112/Code04_DoubleString.java:// 用StringTokenizer读取正确但比较费内存
class112/Code04_DoubleString.java:// 参考链接 : https://oi-wiki.org/lang/java-pro/
class112/Code04_MeanVariance1.java:// 平均数和方差
class112/Code04_MeanVariance1.java:// 给定一个长度为n的数组arr，操作分为三种类型，一共调用m次
class112/Code04_MeanVariance1.java:// 操作 1 l r : arr数组中[l, r]范围上每个数字加上k，k为double类型
class112/Code04_MeanVariance1.java:// 操作 2 l r : 查询arr数组中[l, r]范围上所有数字的平均数，返回double类型
class112/Code04_MeanVariance1.java:// 操作 3 l r : 查询arr数组中[l, r]范围上所有数字的方差，返回double类型
class112/Code04_MeanVariance1.java:// 测试链接 : https://www.luogu.com.cn/problem/P1471
class112/Code04_MeanVariance1.java:// 如下实现是正确的，但是洛谷平台对空间卡的很严，只有使用C++能全部通过
class112/Code04_MeanVariance1.java:// C++版本就是本节代码中的Code04_MeanVariance2文件
class112/Code04_MeanVariance1.java:// C++版本和java版本逻辑完全一样，但只有C++版本可以通过所有测试用例
class112/Code04_MeanVariance1.java:// java的版本就是无法完全通过，空间会超过限制，主要是IO空间占用大
class112/Code04_MeanVariance1.java:// 这是洛谷平台没有照顾各种语言的实现所导致的
class112/Code04_MeanVariance1.java:// 在真正笔试、比赛时，一定是兼顾各种语言的，该实现是一定正确的
class112/Code04_MeanVariance2.java:// 平均数和方差
class112/Code04_MeanVariance2.java:// 给定一个长度为n的数组arr，操作分为三种类型，一共调用m次
class112/Code04_MeanVariance2.java:// 操作 1 l r : arr数组中[l, r]范围上每个数字加上k，k为double类型
class112/Code04_MeanVariance2.java:// 操作 2 l r : 查询arr数组中[l, r]范围上所有数字的平均数，返回double类型
class112/Code04_MeanVariance2.java:// 操作 3 l r : 查询arr数组中[l, r]范围上所有数字的方差，返回double类型
class112/Code04_MeanVariance2.java:// 测试链接 : https://www.luogu.com.cn/problem/P1471
class112/Code04_MeanVariance2.java:// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
class112/Code04_MeanVariance2.java:// 提交如下代码，可以通过所有测试用例
class112/Code04_MeanVariance2.java://#include <cstdio>
class112/Code04_MeanVariance2.java://using namespace std;
class112/Code04_MeanVariance2.java://
class112/Code04_MeanVariance2.java://const int MAXN = 100001;
class112/Code04_MeanVariance2.java://
class112/Code04_MeanVariance2.java://double arr[MAXN];
class112/Code04_MeanVariance2.java://double sum1[MAXN << 2];
class112/Code04_MeanVariance2.java://double sum2[MAXN << 2];
class112/Code04_MeanVariance2.java://double addv[MAXN << 2];
class112/Code04_MeanVariance2.java://
class112/Code04_MeanVariance2.java://void up(int i) {
class112/Code04_MeanVariance2.java://    sum1[i] = sum1[i << 1] + sum1[i << 1 | 1];
class112/Code04_MeanVariance2.java://    sum2[i] = sum2[i << 1] + sum2[i << 1 | 1];
class112/Code04_MeanVariance2.java://}
class112/Code04_MeanVariance2.java://
class112/Code04_MeanVariance2.java://void lazy(int i, double v, int n) {
class112/Code04_MeanVariance2.java://    sum2[i] += sum1[i] * v * 2 + v * v * n;
class112/Code04_MeanVariance2.java://    sum1[i] += v * n;
class112/Code04_MeanVariance2.java://    addv[i] += v;
class112/Code04_MeanVariance2.java://}
class112/Code04_MeanVariance2.java://
class112/Code04_MeanVariance2.java://void down(int i, int ln, int rn) {
class112/Code04_MeanVariance2.java://    if (addv[i] != 0) {
class112/Code04_MeanVariance2.java://        lazy(i << 1, addv[i], ln);
class112/Code04_MeanVariance2.java://        lazy(i << 1 | 1, addv[i], rn);
class112/Code04_MeanVariance2.java://        addv[i] = 0;
class112/Code04_MeanVariance2.java://    }
class112/Code04_MeanVariance2.java://}
class112/Code04_MeanVariance2.java://
class112/Code04_MeanVariance2.java://void build(int l, int r, int i) {
class112/Code04_MeanVariance2.java://    if (l == r) {
class112/Code04_MeanVariance2.java://        sum1[i] = arr[l];
class112/Code04_MeanVariance2.java://        sum2[i] = arr[l] * arr[l];
class112/Code04_MeanVariance2.java://    } else {
class112/Code04_MeanVariance2.java://        int mid = (l + r) >> 1;
class112/Code04_MeanVariance2.java://        build(l, mid, i << 1);
class112/Code04_MeanVariance2.java://        build(mid + 1, r, i << 1 | 1);
class112/Code04_MeanVariance2.java://        up(i);
class112/Code04_MeanVariance2.java://    }
class112/Code04_MeanVariance2.java://    addv[i] = 0;
class112/Code04_MeanVariance2.java://}
class112/Code04_MeanVariance2.java://
class112/Code04_MeanVariance2.java://void add(int jobl, int jobr, double jobv, int l, int r, int i) {
class112/Code04_MeanVariance2.java://    if (jobl <= l && r <= jobr) {
class112/Code04_MeanVariance2.java://        lazy(i, jobv, r - l + 1);
class112/Code04_MeanVariance2.java://    } else {
class112/Code04_MeanVariance2.java://        int mid = (l + r) >> 1;
class112/Code04_MeanVariance2.java://        down(i, mid - l + 1, r - mid);
class112/Code04_MeanVariance2.java://        if (jobl <= mid) {
class112/Code04_MeanVariance2.java://            add(jobl, jobr, jobv, l, mid, i << 1);
class112/Code04_MeanVariance2.java://        }
class112/Code04_MeanVariance2.java://        if (jobr > mid) {
class112/Code04_MeanVariance2.java://            add(jobl, jobr, jobv, mid + 1, r, i << 1 | 1);
class112/Code04_MeanVariance2.java://        }
class112/Code04_MeanVariance2.java://        up(i);
class112/Code04_MeanVariance2.java://    }
class112/Code04_MeanVariance2.java://}
class112/Code04_MeanVariance2.java://
class112/Code04_MeanVariance2.java://double query(double *sum, int jobl, int jobr, int l, int r, int i) {
class112/Code04_MeanVariance2.java://    if (jobl <= l && r <= jobr) {
class112/Code04_MeanVariance2.java://        return sum[i];
class112/Code04_MeanVariance2.java://    }
class112/Code04_MeanVariance2.java://    int mid = (l + r) >> 1;
class112/Code04_MeanVariance2.java://    down(i, mid - l + 1, r - mid);
class112/Code04_MeanVariance2.java://    double ans = 0;
class112/Code04_MeanVariance2.java://    if (jobl <= mid) {
class112/Code04_MeanVariance2.java://        ans += query(sum, jobl, jobr, l, mid, i << 1);
class112/Code04_MeanVariance2.java://    }
class112/Code04_MeanVariance2.java://    if (jobr > mid) {
class112/Code04_MeanVariance2.java://        ans += query(sum, jobl, jobr, mid + 1, r, i << 1 | 1);
class112/Code04_MeanVariance2.java://    }
class112/Code04_MeanVariance2.java://    return ans;
class112/Code04_MeanVariance2.java://}
class112/Code04_MeanVariance2.java://
class112/Code04_MeanVariance2.java://int main() {
class112/Code04_MeanVariance2.java://    int n, m;
class112/Code04_MeanVariance2.java://    scanf("%d %d", &n, &m);
class112/Code04_MeanVariance2.java://    for (int i = 1; i <= n; i++) {
class112/Code04_MeanVariance2.java://        scanf("%lf", &arr[i]);
class112/Code04_MeanVariance2.java://    }
class112/Code04_MeanVariance2.java://    build(1, n, 1);
class112/Code04_MeanVariance2.java://    for (int i = 1; i <= m; i++) {
class112/Code04_MeanVariance2.java://        int op, jobl, jobr;
class112/Code04_MeanVariance2.java://        scanf("%d", &op);
class112/Code04_MeanVariance2.java://        if (op == 1) {
class112/Code04_MeanVariance2.java://            double jobv;
class112/Code04_MeanVariance2.java://            scanf("%d %d %lf", &jobl, &jobr, &jobv);
class112/Code04_MeanVariance2.java://            add(jobl, jobr, jobv, 1, n, 1);
class112/Code04_MeanVariance2.java://        } else if (op == 2) {
class112/Code04_MeanVariance2.java://            scanf("%d %d", &jobl, &jobr);
class112/Code04_MeanVariance2.java://            double ans = query(sum1, jobl, jobr, 1, n, 1) / (jobr - jobl + 1);
class112/Code04_MeanVariance2.java://            printf("%.4f\n", ans);
class112/Code04_MeanVariance2.java://        } else {
class112/Code04_MeanVariance2.java://            scanf("%d %d", &jobl, &jobr);
class112/Code04_MeanVariance2.java://            double a = query(sum1, jobl, jobr, 1, n, 1);
class112/Code04_MeanVariance2.java://            double b = query(sum2, jobl, jobr, 1, n, 1);
class112/Code04_MeanVariance2.java://            double size = jobr - jobl + 1;
class112/Code04_MeanVariance2.java://            double ans = b / size - (a / size) * (a / size);
class112/Code04_MeanVariance2.java://            printf("%.4f\n", ans);
class112/Code04_MeanVariance2.java://        }
class112/Code04_MeanVariance2.java://    }
class112/Code04_MeanVariance2.java://    return 0;
class112/Code04_MeanVariance2.java://}
class112/ExtraQuestion.java:// 赠送一道课上没有讲的附加练习题
class112/ExtraQuestion.java:// 色板游戏
class112/ExtraQuestion.java:// 一共有L个色板，编号1~L，一开始所有色板都是1号颜色
class112/ExtraQuestion.java:// 一共有T种颜色，编号1~T，可以往色板上涂色
class112/ExtraQuestion.java:// 一共有O次操作，操作类型有如下两种
class112/ExtraQuestion.java:// 操作 C A B C : A~B范围的色板都涂上C颜色 
class112/ExtraQuestion.java:// 操作 P A B   : 查询A~B范围的色板一共有几种颜色
class112/ExtraQuestion.java:// L <= 10^5, T <= 30, O <= 10^5
class112/ExtraQuestion.java:// 测试链接 : https://www.luogu.com.cn/problem/P1558
class112/ExtraQuestion.java:// 解法 : 
class112/ExtraQuestion.java:// 数据很特殊，颜色种类不超过30
class112/ExtraQuestion.java:// 可以用位信息来表示线段树范围上的颜色状况
class112/ExtraQuestion.java:// 那么，父范围的颜色状况 = 左范围的颜色状况 | 右范围的颜色状况
class112/ExtraQuestion.java:// 除此之外没啥难点了，提交时把类名改成"Main"，可以直接通过
算法讲解113【扩展】线段树专题4-线段树解决区间合并的问题
class113/Code01_SequenceOperation.java:// 序列操作
class113/Code01_SequenceOperation.java:// 给定一个长度为n的数组arr，内部只有01两种值，下标从0开始
class113/Code01_SequenceOperation.java:// 对于这个序列有五种变换操作和询问操作
class113/Code01_SequenceOperation.java:// 操作 0 l r : 把l~r范围上所有数字全改成0
class113/Code01_SequenceOperation.java:// 操作 1 l r : 把l~r范围上所有数字全改成1
class113/Code01_SequenceOperation.java:// 操作 2 l r : 把l~r范围上所有数字全取反
class113/Code01_SequenceOperation.java:// 操作 3 l r : 询问l~r范围上有多少个1
class113/Code01_SequenceOperation.java:// 操作 4 l r : 询问l~r范围上连续1的最长子串长度
class113/Code01_SequenceOperation.java:// 测试链接 : https://www.luogu.com.cn/problem/P2572
class113/Code01_SequenceOperation.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class113/Code01_SequenceOperation.java:// 这是输入输出处理效率很高的写法
class113/Code01_SequenceOperation.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class113/Code02_LongestAlternateSubstring.java:// 最长LR交替子串
class113/Code02_LongestAlternateSubstring.java:// 给定一个长度为n的字符串，一开始字符串中全是'L'字符
class113/Code02_LongestAlternateSubstring.java:// 有q次修改，每次指定一个位置i
class113/Code02_LongestAlternateSubstring.java:// 如果i位置是'L'字符那么改成'R'字符
class113/Code02_LongestAlternateSubstring.java:// 如果i位置是'R'字符那么改成'L'字符
class113/Code02_LongestAlternateSubstring.java:// 如果一个子串是两种字符不停交替出现的样子，也就是LRLR... 或者RLRL...
class113/Code02_LongestAlternateSubstring.java:// 那么说这个子串是有效子串
class113/Code02_LongestAlternateSubstring.java:// 每次修改后，都打印当前整个字符串中最长交替子串的长度
class113/Code02_LongestAlternateSubstring.java:// 测试链接 : https://www.luogu.com.cn/problem/P6492
class113/Code02_LongestAlternateSubstring.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class113/Code02_LongestAlternateSubstring.java:// 这是输入输出处理效率很高的写法
class113/Code02_LongestAlternateSubstring.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class113/Code03_TunnelWarfare.java:// 地道相连的房子
class113/Code03_TunnelWarfare.java:// 有n个房子排成一排，编号1~n，一开始每相邻的两个房子之间都有地道
class113/Code03_TunnelWarfare.java:// 实现如下三个操作
class113/Code03_TunnelWarfare.java:// 操作 D x : 把x号房子摧毁，该房子附近的地道也一并摧毁
class113/Code03_TunnelWarfare.java:// 操作 R   : 恢复上次摧毁的房子，该房子附近的地道一并恢复
class113/Code03_TunnelWarfare.java:// 操作 Q x : 查询x号房子能到达的房子数量，包括x号房子自身
class113/Code03_TunnelWarfare.java:// 测试链接 : https://www.luogu.com.cn/problem/P1503
class113/Code03_TunnelWarfare.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class113/Code03_TunnelWarfare.java:// 这是输入输出处理效率很高的写法
class113/Code03_TunnelWarfare.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class113/Code04_Hotel.java:// 旅馆
class113/Code04_Hotel.java:// 一共有n个房间，编号1~n，一开始都是空房
class113/Code04_Hotel.java:// 实现如下两种操作，会一共调用m次
class113/Code04_Hotel.java:// 操作 1 x   : 找到至少有连续x个空房间的区域，返回最左编号
class113/Code04_Hotel.java://              如果有多个满足条件的区域，返回其中最左区域的最左编号
class113/Code04_Hotel.java://              如果找不到打印0，并且不办理入住
class113/Code04_Hotel.java://              如果找到了打印最左编号，并且从最左编号开始办理x个人的入住
class113/Code04_Hotel.java:// 操作 2 x y : 从x号房间开始往下数y个房间，一律清空
class113/Code04_Hotel.java:// 操作1有打印操作，操作2没有
class113/Code04_Hotel.java:// 1 <= n 、m <= 50000
class113/Code04_Hotel.java:// 测试链接 : https://www.luogu.com.cn/problem/P2894
class113/Code04_Hotel.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class113/Code04_Hotel.java:// 这是输入输出处理效率很高的写法
class113/Code04_Hotel.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
算法讲解114【扩展】线段树专题5-开点线段树、区间最值和历史最值
class114/Code01_DynamicSegmentTree.java:// 动态开点线段树
class114/Code01_DynamicSegmentTree.java:// 一共有n个位置，编号从1~n，一开始所有位置的值为0
class114/Code01_DynamicSegmentTree.java:// 实现如下两个操作，一共会调用m次
class114/Code01_DynamicSegmentTree.java:// 操作 1 l r v : 把l~r范围的每个数增加v
class114/Code01_DynamicSegmentTree.java:// 操作 2 l r   : 返回l~r范围的累加和
class114/Code01_DynamicSegmentTree.java:// 1 <= n <= 10^9
class114/Code01_DynamicSegmentTree.java:// 1 <= m <= 10^3
class114/Code01_DynamicSegmentTree.java:// 测试链接 : https://www.luogu.com.cn/problem/P2781
class114/Code01_DynamicSegmentTree.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class114/Code01_DynamicSegmentTree.java:// 这是输入输出处理效率很高的写法
class114/Code01_DynamicSegmentTree.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class114/Code02_CountIntervals.java:// 统计区间中的整数数目
class114/Code02_CountIntervals.java:// 实现CountIntervals类的如下三个方法
class114/Code02_CountIntervals.java:// 1) CountIntervals() : 初始化
class114/Code02_CountIntervals.java:// 2) void add(int l, int r) : 把[l, r]范围上的数字都设置成1
class114/Code02_CountIntervals.java:// 3) int count() : 返回整个区间有多少个1
class114/Code02_CountIntervals.java:// CountIntervals类需要支持1 ~ 10^9范围
class114/Code02_CountIntervals.java:// 调用add和count方法总共10^5次
class114/Code02_CountIntervals.java:// 测试链接 : https://leetcode.cn/problems/count-integers-in-intervals/
class114/Code03_SegmentTreeSetminQueryMaxSum1.java:// 线段树的区间最值操作
class114/Code03_SegmentTreeSetminQueryMaxSum1.java:// 给定一个长度为n的数组arr，实现支持以下三种操作的结构
class114/Code03_SegmentTreeSetminQueryMaxSum1.java:// 操作 0 l r x : 把arr[l..r]范围的每个数v，更新成min(v, x)
class114/Code03_SegmentTreeSetminQueryMaxSum1.java:// 操作 1 l r   : 查询arr[l..r]范围上的最大值
class114/Code03_SegmentTreeSetminQueryMaxSum1.java:// 操作 2 l r   : 查询arr[l..r]范围上的累加和
class114/Code03_SegmentTreeSetminQueryMaxSum1.java:// 三种操作一共调用m次，做到时间复杂度O(n * log n + m * log n)
class114/Code03_SegmentTreeSetminQueryMaxSum1.java:// 对数器验证
class114/Code03_SegmentTreeSetminQueryMaxSum2.java:// 线段树的区间最值操作(hdu测试)
class114/Code03_SegmentTreeSetminQueryMaxSum2.java:// 给定一个长度为n的数组arr，实现支持以下三种操作的结构
class114/Code03_SegmentTreeSetminQueryMaxSum2.java:// 操作 0 l r x : 把arr[l..r]范围的每个数v，更新成min(v, x)
class114/Code03_SegmentTreeSetminQueryMaxSum2.java:// 操作 1 l r   : 查询arr[l..r]范围上的最大值
class114/Code03_SegmentTreeSetminQueryMaxSum2.java:// 操作 2 l r   : 查询arr[l..r]范围上的累加和
class114/Code03_SegmentTreeSetminQueryMaxSum2.java:// 三种操作一共调用m次，做到时间复杂度O(n * log n + m * log n)
class114/Code03_SegmentTreeSetminQueryMaxSum2.java:// 测试链接 : https://acm.hdu.edu.cn/showproblem.php?pid=5306
class114/Code03_SegmentTreeSetminQueryMaxSum2.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class114/Code03_SegmentTreeSetminQueryMaxSum2.java:// 这是输入输出处理效率很高的写法
class114/Code03_SegmentTreeSetminQueryMaxSum2.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class114/Code04_SegmentTreeAddSetminQueryMaxSum.java:// 线段树范围增加操作 + 区间最值操作
class114/Code04_SegmentTreeAddSetminQueryMaxSum.java:// 给定一个长度为n的数组arr，实现支持以下四种操作的结构
class114/Code04_SegmentTreeAddSetminQueryMaxSum.java:// 操作 0 l r x : 把arr[l..r]范围的每个数v，增加x
class114/Code04_SegmentTreeAddSetminQueryMaxSum.java:// 操作 1 l r x : 把arr[l..r]范围的每个数v，更新成min(v, x)
class114/Code04_SegmentTreeAddSetminQueryMaxSum.java:// 操作 2 l r   : 查询arr[l..r]范围上的最大值
class114/Code04_SegmentTreeAddSetminQueryMaxSum.java:// 操作 3 l r   : 查询arr[l..r]范围上的累加和
class114/Code04_SegmentTreeAddSetminQueryMaxSum.java:// 对数器验证
class114/Code05_MaximumMinimumHistory.java:// 区间最值和历史最值
class114/Code05_MaximumMinimumHistory.java:// 给定两个长度都为n的数组A和B，一开始两个数组完全一样
class114/Code05_MaximumMinimumHistory.java:// 任何操作做完，都更新B数组，B[i] = max(B[i],A[i])
class114/Code05_MaximumMinimumHistory.java:// 实现以下五种操作，一共会调用m次
class114/Code05_MaximumMinimumHistory.java:// 操作 1 l r v : A[l..r]范围上每个数加上v
class114/Code05_MaximumMinimumHistory.java:// 操作 2 l r v : A[l..r]范围上每个数A[i]变成min(A[i],v)
class114/Code05_MaximumMinimumHistory.java:// 操作 3 l r   : 返回A[l..r]范围上的累加和
class114/Code05_MaximumMinimumHistory.java:// 操作 4 l r   : 返回A[l..r]范围上的最大值
class114/Code05_MaximumMinimumHistory.java:// 操作 5 l r   : 返回B[l..r]范围上的最大值
class114/Code05_MaximumMinimumHistory.java:// 1 <= n、m <= 5 * 10^5
class114/Code05_MaximumMinimumHistory.java:// 测试链接 : https://www.luogu.com.cn/problem/P6242
class114/Code05_MaximumMinimumHistory.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class114/Code05_MaximumMinimumHistory.java:// 这是输入输出处理效率很高的写法
class114/Code05_MaximumMinimumHistory.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
算法讲解115【扩展】线段树专题6-线段树与扫描线结合的题目
class115/Code01_MinimumIntervalQuery1.java:// 包含每个查询的最小区间
class115/Code01_MinimumIntervalQuery1.java:// 给你一个二维整数数组intervals，其中intervals[i] = [l, r]
class115/Code01_MinimumIntervalQuery1.java:// 表示第i个区间开始于l，结束于r，区间的长度是r-l+1
class115/Code01_MinimumIntervalQuery1.java:// 给你一个整数数组queries，queries[i]表示要查询的位置
class115/Code01_MinimumIntervalQuery1.java:// 答案是所有包含queries[i]的区间中，最小长度的区间是多长
class115/Code01_MinimumIntervalQuery1.java:// 返回数组对应查询的所有答案，如果不存在这样的区间那么答案是-1
class115/Code01_MinimumIntervalQuery1.java:// 测试链接 : https://leetcode.cn/problems/minimum-interval-to-include-each-query/
class115/Code01_MinimumIntervalQuery2.java:// 包含每个查询的最小区间
class115/Code01_MinimumIntervalQuery2.java:// 给你一个二维整数数组intervals，其中intervals[i] = [l, r]
class115/Code01_MinimumIntervalQuery2.java:// 表示第i个区间开始于l，结束于r，区间的长度是r-l+1
class115/Code01_MinimumIntervalQuery2.java:// 给你一个整数数组queries，queries[i]表示要查询的位置
class115/Code01_MinimumIntervalQuery2.java:// 答案是所有包含queries[i]的区间中，最小长度的区间是多长
class115/Code01_MinimumIntervalQuery2.java:// 返回数组对应查询的所有答案，如果不存在这样的区间那么答案是-1
class115/Code01_MinimumIntervalQuery2.java:// 测试链接 : https://leetcode.cn/problems/minimum-interval-to-include-each-query/
class115/Code02_SkylineLeetcode1.java:// 天际线问题(Leetcode测试)
class115/Code02_SkylineLeetcode1.java:// 测试链接 : https://leetcode.cn/problems/the-skyline-problem/
class115/Code02_SkylineLeetcode2.java:// 天际线问题(Leetcode测试)
class115/Code02_SkylineLeetcode2.java:// 测试链接 : https://leetcode.cn/problems/the-skyline-problem/
class115/Code02_SkylineLuogu.java:// 天际线问题(洛谷测试)
class115/Code02_SkylineLuogu.java:// 测试链接 : https://www.luogu.com.cn/problem/P1904
class115/Code02_SkylineLuogu.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class115/Code02_SkylineLuogu.java:// 这是输入输出处理效率很高的写法
class115/Code02_SkylineLuogu.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class115/Code02_SkylineLuogu.java:// 堆结构由自己实现
class115/Code03_AreaSum.java:// 矩形面积并
class115/Code03_AreaSum.java:// 测试链接 : https://www.luogu.com.cn/problem/P5490
class115/Code03_AreaSum.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class115/Code03_AreaSum.java:// 这是输入输出处理效率很高的写法
class115/Code03_AreaSum.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class115/Code04_PerimeterSum1.java:// 矩形周长并(洛谷测试)
class115/Code04_PerimeterSum1.java:// 测试链接 : https://www.luogu.com.cn/problem/P1856
class115/Code04_PerimeterSum1.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class115/Code04_PerimeterSum1.java:// 这是输入输出处理效率很高的写法
class115/Code04_PerimeterSum1.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class115/Code04_PerimeterSum2.java:// 矩形周长并(poj测试)
class115/Code04_PerimeterSum2.java:// 测试链接 : http://poj.org/problem?id=1177
class115/Code04_PerimeterSum2.java:// poj上的java版本较老，不支持lamda表达式定义比较器
class115/Code04_PerimeterSum2.java:// 所以需要自己定义比较器，除此之外没有区别
class115/Code04_PerimeterSum2.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class115/Code04_PerimeterSum2.java:// 这是输入输出处理效率很高的写法
class115/Code04_PerimeterSum2.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
算法讲解116【扩展】摩尔投票大加强，线段树里捉海王
class116/Code01_WaterKing.java:// 出现次数大于n/2的数
class116/Code01_WaterKing.java:// 给定一个大小为n的数组nums
class116/Code01_WaterKing.java:// 水王数是指在数组中出现次数大于n/2的数
class116/Code01_WaterKing.java:// 返回其中的水王数，如果数组不存在水王数返回-1
class116/Code01_WaterKing.java:// 测试链接 : https://leetcode.cn/problems/majority-element/
class116/Code04_SplitSameWaterKing.java:// 划分左右使其水王数相同
class116/Code04_SplitSameWaterKing.java:// 给定一个大小为n的数组nums
class116/Code04_SplitSameWaterKing.java:// 水王数是指在数组中出现次数大于n/2的数
class116/Code04_SplitSameWaterKing.java:// 返回其中的一个划分点下标，使得左侧水王数等于右侧水王数
class116/Code04_SplitSameWaterKing.java:// 如果数组不存在这样的划分返回-1
class116/Code04_SplitSameWaterKing.java:// 测试链接 : https://leetcode.cn/problems/minimum-index-of-a-valid-split/
class116/Code05_MoreThanNK.java:// 出现次数大于n/k的数
class116/Code05_MoreThanNK.java:// 给定一个大小为n的数组nums，给定一个较小的正数k
class116/Code05_MoreThanNK.java:// 水王数是指在数组中出现次数大于n/k的数
class116/Code05_MoreThanNK.java:// 返回所有的水王数，如果没有水王数返回空列表
class116/Code05_MoreThanNK.java:// 测试链接 : https://leetcode.cn/problems/majority-element-ii/
class116/Code06_FindSeaKing.java:// 子数组里的海王数
class116/Code06_FindSeaKing.java:// 子数组的海王数首先必须是子数组上出现次数最多的数(水王数)，并且要求出现次数>=t，t是参数
class116/Code06_FindSeaKing.java:// 设计一个数据结构并实现如下两个方法
class116/Code06_FindSeaKing.java:// 1) MajorityChecker(int[] arr) : 用数组arr对MajorityChecker初始化
class116/Code06_FindSeaKing.java:// 2) int query(int l, int r, int t) : 返回arr[l...r]上的海王数，不存在返回-1
class116/Code06_FindSeaKing.java:// 测试链接 : https://leetcode.cn/problems/online-majority-element-in-subarray/
算法讲解117【扩展】倍增算法和ST表
class117/Code01_FlagPlan.java:// 国旗计划
class117/Code01_FlagPlan.java:// 给定点的数量m，点的编号1~m，所有点围成一个环
class117/Code01_FlagPlan.java:// i号点一定顺时针到达i+1号点，最终m号点顺指针回到1号点
class117/Code01_FlagPlan.java:// 给定n条线段，每条线段(a, b)，表示线段从点a顺时针到点b
class117/Code01_FlagPlan.java:// 输入数据保证所有线段可以把整个环覆盖
class117/Code01_FlagPlan.java:// 输入数据保证每条线段不会完全在另一条线段的内部
class117/Code01_FlagPlan.java:// 也就是线段之间可能有重合但一定互不包含
class117/Code01_FlagPlan.java:// 返回一个长度为n的结果数组ans，ans[x]表示一定选x号线段的情况下
class117/Code01_FlagPlan.java:// 至少选几条线段能覆盖整个环
class117/Code01_FlagPlan.java:// 测试链接 : https://www.luogu.com.cn/problem/P4155
class117/Code01_FlagPlan.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class117/Code01_FlagPlan.java:// 这是输入输出处理效率很高的写法
class117/Code01_FlagPlan.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class117/Code02_SparseTableMaximumMinimum.java:// ST表查询最大值和最小值
class117/Code02_SparseTableMaximumMinimum.java:// 给定一个长度为n的数组arr，一共有m次查询
class117/Code02_SparseTableMaximumMinimum.java:// 每次查询arr[l~r]上的最大值和最小值
class117/Code02_SparseTableMaximumMinimum.java:// 每次查询只需要打印最大值-最小值的结果
class117/Code02_SparseTableMaximumMinimum.java:// 测试链接 : https://www.luogu.com.cn/problem/P2880
class117/Code02_SparseTableMaximumMinimum.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class117/Code02_SparseTableMaximumMinimum.java:// 这是输入输出处理效率很高的写法
class117/Code02_SparseTableMaximumMinimum.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class117/Code03_SparseTableGCD.java:// ST表查询最大公约数
class117/Code03_SparseTableGCD.java:// 给定一个长度为n的数组arr，一共有m次查询
class117/Code03_SparseTableGCD.java:// 每次查询arr[l~r]上所有数的最大公约数
class117/Code03_SparseTableGCD.java:// 测试链接 : https://www.luogu.com.cn/problem/P1890
class117/Code03_SparseTableGCD.java:// 请同学们务必参考如下代码中关于输入、输出的处理
class117/Code03_SparseTableGCD.java:// 这是输入输出处理效率很高的写法
class117/Code03_SparseTableGCD.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class117/Code04_FrequentValues1.java:// 出现次数最多的数有几个
class117/Code04_FrequentValues1.java:// 给定一个长度为n的数组arr，该数组一定是有序的
class117/Code04_FrequentValues1.java:// 一共有m次查询，每次查询arr[l~r]上出现次数最多的数有几个
class117/Code04_FrequentValues1.java:// 对数器验证
class117/Code04_FrequentValues2.java:// 出现次数最多的数有几个
class117/Code04_FrequentValues2.java:// 给定一个长度为n的数组arr，该数组一定是有序的
class117/Code04_FrequentValues2.java:// 一共有m次查询，每次查询arr[l~r]上出现次数最多的数有几个
class117/Code04_FrequentValues2.java:// 题目查看 : https://www.luogu.com.cn/problem/UVA11235
class117/Code04_FrequentValues2.java:// 题目提交 : https://vjudge.net/problem/UVA-11235
class117/Code04_FrequentValues2.java:// 洛谷上提交会发生远程连接错误，需要绑定一个UVA账号再提交
class117/Code04_FrequentValues2.java:// 也可以注册一个vjudge账号来提交，不过如果UVA链接不上就需要等
class117/Code04_FrequentValues2.java:// 其实用对数器验证即可，我肯定是提交通过测试了的
class117/Code04_FrequentValues2.java:// 提交以下的code，提交时请把类名改成"Main"
class117/TwoSmallQuestions.java://		while ((1 << power) <= x) {
class117/TwoSmallQuestions.java://			power++;
class117/TwoSmallQuestions.java://		}
class117/TwoSmallQuestions.java://		power--;
算法讲解118【扩展】树上问题专题1-树上倍增和LCA-上
class118/Code01_KthAncestor.java:// 树节点的第K个祖先
class118/Code01_KthAncestor.java:// 树上有n个节点，编号0 ~ n-1，树的结构用parent数组代表
class118/Code01_KthAncestor.java:// 其中parent[i]是节点i的父节点，树的根节点是编号为0
class118/Code01_KthAncestor.java:// 树节点i的第k个祖先节点，是从节点i开始往上跳k步所来到的节点
class118/Code01_KthAncestor.java:// 实现TreeAncestor类
class118/Code01_KthAncestor.java:// TreeAncestor(int n, int[] parent) : 初始化
class118/Code01_KthAncestor.java:// getKthAncestor(int i, int k) : 返回节点i的第k个祖先节点，不存在返回-1
class118/Code01_KthAncestor.java:// 测试链接 : https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/
class118/Code02_Multiply1.java:// 树上倍增解法
class118/Code02_Multiply1.java:// 测试链接 : https://www.luogu.com.cn/problem/P3379
class118/Code02_Multiply1.java:// 提交以下的code，提交时请把类名改成"Main"
class118/Code02_Multiply1.java:// C++这么写能通过，java会因为递归层数太多而爆栈
class118/Code02_Multiply1.java:// java能通过的写法参考本节课Code02_Multiply2文件
class118/Code02_Multiply2.java:// 树上倍增解法迭代版
class118/Code02_Multiply2.java:// 测试链接 : https://www.luogu.com.cn/problem/P3379
class118/Code02_Multiply2.java:// 所有递归函数一律改成等义的迭代版
class118/Code02_Multiply2.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class118/Code03_Tarjan1.java:// tarjan算法解法
class118/Code03_Tarjan1.java:// 测试链接 : https://www.luogu.com.cn/problem/P3379
class118/Code03_Tarjan1.java:// 提交以下的code，提交时请把类名改成"Main"
class118/Code03_Tarjan1.java:// C++这么写能通过，java会因为递归层数太多而爆栈
class118/Code03_Tarjan1.java:// java能通过的写法参考本节课Code03_Tarjan2文件
class118/Code03_Tarjan2.java:// tarjan算法解法迭代版
class118/Code03_Tarjan2.java:// 测试链接 : https://www.luogu.com.cn/problem/P3379
class118/Code03_Tarjan2.java:// 所有递归函数一律改成等义的迭代版
class118/Code03_Tarjan2.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class118/Code03_Tarjan2.java://				father[v] = u;
算法讲解119【扩展】树上问题专题2-树上倍增和LCA-下
class119/Code01_EmergencyAssembly1.java:// 紧急集合
class119/Code01_EmergencyAssembly1.java:// 一共有n个节点，编号1 ~ n，一定有n-1条边连接形成一颗树
class119/Code01_EmergencyAssembly1.java:// 从一个点到另一个点的路径上有几条边，就需要耗费几个金币
class119/Code01_EmergencyAssembly1.java:// 每条查询(a, b, c)表示有三个人分别站在a、b、c点上
class119/Code01_EmergencyAssembly1.java:// 他们想集合在树上的某个点，并且想花费的金币总数最少
class119/Code01_EmergencyAssembly1.java:// 一共有m条查询，打印m个答案
class119/Code01_EmergencyAssembly1.java:// 1 <= n <= 5 * 10^5
class119/Code01_EmergencyAssembly1.java:// 1 <= m <= 5 * 10^5
class119/Code01_EmergencyAssembly1.java:// 测试链接 : https://www.luogu.com.cn/problem/P4281
class119/Code01_EmergencyAssembly1.java:// 如下实现是正确的，但是洛谷平台对空间卡的很严，只有使用C++能全部通过
class119/Code01_EmergencyAssembly1.java:// C++版本就是本节代码中的Code01_EmergencyAssembly2文件
class119/Code01_EmergencyAssembly1.java:// C++版本和java版本逻辑完全一样，但只有C++版本可以通过所有测试用例
class119/Code01_EmergencyAssembly1.java:// 这是洛谷平台没有照顾各种语言的实现所导致的
class119/Code01_EmergencyAssembly1.java:// 在真正笔试、比赛时，一定是兼顾各种语言的，该实现是一定正确的
class119/Code01_EmergencyAssembly1.java:// 提交以下的code，提交时请把类名改成"Main"
class119/Code01_EmergencyAssembly2.java:// 紧急集合
class119/Code01_EmergencyAssembly2.java:// 一共有n个节点，编号1 ~ n，一定有n-1条边连接形成一颗树
class119/Code01_EmergencyAssembly2.java:// 从一个点到另一个点的路径上有几条边，就需要耗费几个金币
class119/Code01_EmergencyAssembly2.java:// 每条查询(a, b, c)表示有三个人分别站在a、b、c点上
class119/Code01_EmergencyAssembly2.java:// 他们想集合在树上的某个点，并且想花费的金币总数最少
class119/Code01_EmergencyAssembly2.java:// 一共有m条查询，打印m个答案
class119/Code01_EmergencyAssembly2.java:// 1 <= n <= 5 * 10^5
class119/Code01_EmergencyAssembly2.java:// 1 <= m <= 5 * 10^5
class119/Code01_EmergencyAssembly2.java:// 测试链接 : https://www.luogu.com.cn/problem/P4281
class119/Code01_EmergencyAssembly2.java:// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
class119/Code01_EmergencyAssembly2.java:// 提交如下代码，可以通过所有测试用例
class119/Code01_EmergencyAssembly2.java://#include <iostream>
class119/Code01_EmergencyAssembly2.java://#include <algorithm>
class119/Code01_EmergencyAssembly2.java://#include <cmath>
class119/Code01_EmergencyAssembly2.java://#include <cstdio>
class119/Code01_EmergencyAssembly2.java://
class119/Code01_EmergencyAssembly2.java://using namespace std;
class119/Code01_EmergencyAssembly2.java://
class119/Code01_EmergencyAssembly2.java://const int MAXN = 500001;
class119/Code01_EmergencyAssembly2.java://const int LIMIT = 19;
class119/Code01_EmergencyAssembly2.java://
class119/Code01_EmergencyAssembly2.java://int power;
class119/Code01_EmergencyAssembly2.java://int head[MAXN];
class119/Code01_EmergencyAssembly2.java://int edgeNext[MAXN << 1];
class119/Code01_EmergencyAssembly2.java://int edgeTo[MAXN << 1];
class119/Code01_EmergencyAssembly2.java://int cnt;
class119/Code01_EmergencyAssembly2.java://int deep[MAXN];
class119/Code01_EmergencyAssembly2.java://int stjump[MAXN][LIMIT];
class119/Code01_EmergencyAssembly2.java://int togather;
class119/Code01_EmergencyAssembly2.java://long long cost;
class119/Code01_EmergencyAssembly2.java://
class119/Code01_EmergencyAssembly2.java://int log2(int n) {
class119/Code01_EmergencyAssembly2.java://    int ans = 0;
class119/Code01_EmergencyAssembly2.java://    while ((1 << ans) <= (n >> 1)) {
class119/Code01_EmergencyAssembly2.java://        ans++;
class119/Code01_EmergencyAssembly2.java://    }
class119/Code01_EmergencyAssembly2.java://    return ans;
class119/Code01_EmergencyAssembly2.java://}
class119/Code01_EmergencyAssembly2.java://
class119/Code01_EmergencyAssembly2.java://void build(int n) {
class119/Code01_EmergencyAssembly2.java://    power = log2(n);
class119/Code01_EmergencyAssembly2.java://    cnt = 1;
class119/Code01_EmergencyAssembly2.java://    fill(head, head + n + 1, 0);
class119/Code01_EmergencyAssembly2.java://}
class119/Code01_EmergencyAssembly2.java://
class119/Code01_EmergencyAssembly2.java://void addEdge(int u, int v) {
class119/Code01_EmergencyAssembly2.java://	edgeNext[cnt] = head[u];
class119/Code01_EmergencyAssembly2.java://	edgeTo[cnt] = v;
class119/Code01_EmergencyAssembly2.java://    head[u] = cnt++;
class119/Code01_EmergencyAssembly2.java://}
class119/Code01_EmergencyAssembly2.java://
class119/Code01_EmergencyAssembly2.java://void dfs(int u, int f) {
class119/Code01_EmergencyAssembly2.java://    deep[u] = deep[f] + 1;
class119/Code01_EmergencyAssembly2.java://    stjump[u][0] = f;
class119/Code01_EmergencyAssembly2.java://    for (int p = 1; p <= power; p++) {
class119/Code01_EmergencyAssembly2.java://        stjump[u][p] = stjump[stjump[u][p - 1]][p - 1];
class119/Code01_EmergencyAssembly2.java://    }
class119/Code01_EmergencyAssembly2.java://    for (int e = head[u]; e != 0; e = edgeNext[e]) {
class119/Code01_EmergencyAssembly2.java://        if (edgeTo[e] != f) {
class119/Code01_EmergencyAssembly2.java://            dfs(edgeTo[e], u);
class119/Code01_EmergencyAssembly2.java://        }
class119/Code01_EmergencyAssembly2.java://    }
class119/Code01_EmergencyAssembly2.java://}
class119/Code01_EmergencyAssembly2.java://
class119/Code01_EmergencyAssembly2.java://int lca(int a, int b) {
class119/Code01_EmergencyAssembly2.java://    if (deep[a] < deep[b]) swap(a, b);
class119/Code01_EmergencyAssembly2.java://    for (int p = power; p >= 0; p--) {
class119/Code01_EmergencyAssembly2.java://        if (deep[stjump[a][p]] >= deep[b]) {
class119/Code01_EmergencyAssembly2.java://            a = stjump[a][p];
class119/Code01_EmergencyAssembly2.java://        }
class119/Code01_EmergencyAssembly2.java://    }
class119/Code01_EmergencyAssembly2.java://    if (a == b) return a;
class119/Code01_EmergencyAssembly2.java://    for (int p = power; p >= 0; p--) {
class119/Code01_EmergencyAssembly2.java://        if (stjump[a][p] != stjump[b][p]) {
class119/Code01_EmergencyAssembly2.java://            a = stjump[a][p];
class119/Code01_EmergencyAssembly2.java://            b = stjump[b][p];
class119/Code01_EmergencyAssembly2.java://        }
class119/Code01_EmergencyAssembly2.java://    }
class119/Code01_EmergencyAssembly2.java://    return stjump[a][0];
class119/Code01_EmergencyAssembly2.java://}
class119/Code01_EmergencyAssembly2.java://
class119/Code01_EmergencyAssembly2.java://void compute(int a, int b, int c) {
class119/Code01_EmergencyAssembly2.java://	int h1 = lca(a, b), h2 = lca(a, c), h3 = lca(b, c);
class119/Code01_EmergencyAssembly2.java://	int high = h1 != h2 ? (deep[h1] < deep[h2] ? h1 : h2) : h1;
class119/Code01_EmergencyAssembly2.java://	int low = h1 != h2 ? (deep[h1] > deep[h2] ? h1 : h2) : h3;
class119/Code01_EmergencyAssembly2.java://	togather = low;
class119/Code01_EmergencyAssembly2.java://	cost = (long) deep[a] + deep[b] + deep[c] - deep[high] * 2 - deep[low];
class119/Code01_EmergencyAssembly2.java://}
class119/Code01_EmergencyAssembly2.java://
class119/Code01_EmergencyAssembly2.java://int main() {
class119/Code01_EmergencyAssembly2.java://    int n, m;
class119/Code01_EmergencyAssembly2.java://    scanf("%d %d", &n, &m);
class119/Code01_EmergencyAssembly2.java://    build(n);
class119/Code01_EmergencyAssembly2.java://    for (int i = 1, u, v; i < n; i++) {
class119/Code01_EmergencyAssembly2.java://        scanf("%d %d", &u, &v);
class119/Code01_EmergencyAssembly2.java://        addEdge(u, v);
class119/Code01_EmergencyAssembly2.java://        addEdge(v, u);
class119/Code01_EmergencyAssembly2.java://    }
class119/Code01_EmergencyAssembly2.java://    dfs(1, 0);
class119/Code01_EmergencyAssembly2.java://    for (int i = 1, a, b, c; i <= m; i++) {
class119/Code01_EmergencyAssembly2.java://        scanf("%d %d %d", &a, &b, &c);
class119/Code01_EmergencyAssembly2.java://        compute(a, b, c);
class119/Code01_EmergencyAssembly2.java://        printf("%d %lld\n", togather, cost);
class119/Code01_EmergencyAssembly2.java://    }
class119/Code01_EmergencyAssembly2.java://    return 0;
class119/Code01_EmergencyAssembly2.java://}
class119/Code02_Trucking.java:// 货车运输
class119/Code02_Trucking.java:// 一共有n座城市，编号1 ~ n
class119/Code02_Trucking.java:// 一共有m条双向道路，每条道路(u, v, w)表示有一条限重为w，从u到v的双向道路
class119/Code02_Trucking.java:// 从一点到另一点的路途中，汽车载重不能超过每一条道路的限重
class119/Code02_Trucking.java:// 每条查询(a, b)表示从a到b的路线中，汽车允许的最大载重是多少
class119/Code02_Trucking.java:// 如果从a到b无法到达，那么认为答案是-1
class119/Code02_Trucking.java:// 一共有q条查询，返回答案数组
class119/Code02_Trucking.java:// 1 <= n <= 10^4
class119/Code02_Trucking.java:// 1 <= m <= 5 * 10^4
class119/Code02_Trucking.java:// 1 <= q <= 3 * 10^4
class119/Code02_Trucking.java:// 0 <= w <= 10^5
class119/Code02_Trucking.java:// 1 <= u, v, a, b <= n
class119/Code02_Trucking.java:// 测试链接 : https://www.luogu.com.cn/problem/P1967
class119/Code02_Trucking.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class119/Code03_QueryPathMinimumChangesToSame.java:// 边权相等的最小修改次数
class119/Code03_QueryPathMinimumChangesToSame.java:// 一棵树有n个节点，编号0 ~ n-1，每条边(u,v,w)表示从u到v有一条权重为w的边
class119/Code03_QueryPathMinimumChangesToSame.java:// 一共有m条查询，每条查询(a,b)表示，a到b的最短路径中把所有边变成一种值需要修改几条边
class119/Code03_QueryPathMinimumChangesToSame.java:// 返回每条查询的查询结果
class119/Code03_QueryPathMinimumChangesToSame.java:// 1 <= n <= 10^4
class119/Code03_QueryPathMinimumChangesToSame.java:// 1 <= m <= 2 * 10^4
class119/Code03_QueryPathMinimumChangesToSame.java:// 0 <= u、v、a、b < n
class119/Code03_QueryPathMinimumChangesToSame.java:// 1 <= w <= 26
class119/Code03_QueryPathMinimumChangesToSame.java:// 测试链接 : https://leetcode.cn/problems/minimum-edge-weight-equilibrium-queries-in-a-tree/
class119/Code04_PassingBallMaximizeValue.java:// 在传球游戏中最大化函数值
class119/Code04_PassingBallMaximizeValue.java:// 给定一个长度为n的数组receiver和一个整数k
class119/Code04_PassingBallMaximizeValue.java:// 总共有n名玩家，编号0 ~ n-1，这些玩家在玩一个传球游戏
class119/Code04_PassingBallMaximizeValue.java:// receiver[i]表示编号为i的玩家会传球给下一个人的编号
class119/Code04_PassingBallMaximizeValue.java:// 玩家可以传球给自己，也就是说receiver[i]可能等于i
class119/Code04_PassingBallMaximizeValue.java:// 你需要选择一名开始玩家，然后开始传球，球会被传恰好k次
class119/Code04_PassingBallMaximizeValue.java:// 如果选择编号为x的玩家作为开始玩家
class119/Code04_PassingBallMaximizeValue.java:// 函数f(x)表示从x玩家开始，k次传球内所有接触过球的玩家编号之和
class119/Code04_PassingBallMaximizeValue.java:// 如果某位玩家多次触球，则累加多次
class119/Code04_PassingBallMaximizeValue.java:// f(x) = x + receiver[x] + receiver[receiver[x]] + ... 
class119/Code04_PassingBallMaximizeValue.java:// 你的任务时选择开始玩家x，目的是最大化f(x)，返回函数的最大值
class119/Code04_PassingBallMaximizeValue.java:// 测试链接 : https://leetcode.cn/problems/maximize-value-of-function-in-a-ball-passing-game/
class119/Code05_PathPalindrome.java:// 检查树上两节点间的路径是否是回文
class119/Code05_PathPalindrome.java:// 一颗树上有n个节点，编号1~n
class119/Code05_PathPalindrome.java:// 给定长度为n的数组parent, parent[i]表示节点i的父节点编号
class119/Code05_PathPalindrome.java:// 给定长度为n的数组s, s[i]表示节点i上是什么字符
class119/Code05_PathPalindrome.java:// 从节点a到节点b经过节点最少的路，叫做a和b的路径
class119/Code05_PathPalindrome.java:// 一共有m条查询，每条查询(a,b)，a和b的路径字符串是否是回文
class119/Code05_PathPalindrome.java:// 是回文打印"YES"，不是回文打印"NO"
class119/Code05_PathPalindrome.java:// 1 <= n <= 10^5
class119/Code05_PathPalindrome.java:// 1 <= m <= 10^5
class119/Code05_PathPalindrome.java:// parent[1] = 0，即整棵树的头节点一定是1号节点
class119/Code05_PathPalindrome.java:// 每个节点上的字符一定是小写字母a~z
class119/Code05_PathPalindrome.java:// 测试链接 : https://ac.nowcoder.com/acm/contest/78807/G
class119/Code05_PathPalindrome.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
算法讲解120【扩展】树上问题专题3-树的重心
class120/Code01_BalancingAct.java:// 平衡行为
class120/Code01_BalancingAct.java:// 一共有n个节点，编号1~n，有n-1条边形成一棵树
class120/Code01_BalancingAct.java:// 返回重心点，返回重心点最大子树的节点数
class120/Code01_BalancingAct.java:// 树的重心第一种求解方式
class120/Code01_BalancingAct.java:// 以某个节点为根时，最大子树的节点数最少，那么这个节点是重心
class120/Code01_BalancingAct.java:// 测试链接 : http://poj.org/problem?id=1655
class120/Code01_BalancingAct.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class120/Code02_Godfather.java:// 教父
class120/Code02_Godfather.java:// 一共有n个节点，编号1~n，有n-1条边形成一棵树
class120/Code02_Godfather.java:// 返回所有重心点
class120/Code02_Godfather.java:// 树的重心第二种求解方式
class120/Code02_Godfather.java:// 以某个节点为根时，每颗子树的节点数不超过总节点数的一半，那么这个节点是重心
class120/Code02_Godfather.java:// 测试链接 : http://poj.org/problem?id=3107
class120/Code02_Godfather.java:// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
class120/Code03_GreatCowGathering1.java:// 牛群聚集(递归版)
class120/Code03_GreatCowGathering1.java:// 一共有n个节点，编号1~n，每个点有牛的数量
class120/Code03_GreatCowGathering1.java:// 一共有n-1条边把所有点联通起来形成一棵树，每条边有权值
class120/Code03_GreatCowGathering1.java:// 想把所有的牛汇聚在一点，希望走过的总距离最小
class120/Code03_GreatCowGathering1.java:// 返回总距离最小是多少
class120/Code03_GreatCowGathering1.java:// 利用重心的性质：
class120/Code03_GreatCowGathering1.java:// 树上的边权如果都>=0，不管边权怎么分布，所有节点都走向重心的总距离和最小
class120/Code03_GreatCowGathering1.java:// 测试链接 : https://www.luogu.com.cn/problem/P2986
class120/Code03_GreatCowGathering1.java:// 提交以下的code，提交时请把类名改成"Main"
class120/Code03_GreatCowGathering1.java:// C++这么写能通过，java会因为递归层数太多而爆栈
class120/Code03_GreatCowGathering1.java:// java能通过的写法参考本节课Code03_GreatCowGathering2文件
class120/Code03_GreatCowGathering2.java:// 牛群聚集(迭代版)
class120/Code03_GreatCowGathering2.java:// 一共有n个节点，编号1~n，每个点有牛的数量
class120/Code03_GreatCowGathering2.java:// 一共有n-1条边把所有点联通起来形成一棵树，每条边有权值
class120/Code03_GreatCowGathering2.java:// 想把所有的牛汇聚在一点，希望走过的总距离最小
class120/Code03_GreatCowGathering2.java:// 返回总距离最小是多少
class120/Code03_GreatCowGathering2.java:// 利用重心的性质：
class120/Code03_GreatCowGathering2.java:// 树上的边权如果都>=0，不管边权怎么分布，所有节点都走向重心的总距离和最小
class120/Code03_GreatCowGathering2.java:// 测试链接 : https://www.luogu.com.cn/problem/P2986
class120/Code03_GreatCowGathering2.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class120/Code04_LinkCutCentroids.java:// 删增边使其重心唯一
class120/Code04_LinkCutCentroids.java:// 一共有n个节点，编号1~n，有n-1条边形成一棵树
class120/Code04_LinkCutCentroids.java:// 现在希望重心是唯一的节点，调整的方式是先删除一条边、然后增加一条边
class120/Code04_LinkCutCentroids.java:// 如果树上只有一个重心，需要删掉连接重心的任意一条边，再把这条边加上(否则无法通过已经实测)
class120/Code04_LinkCutCentroids.java:// 如果树上有两个重心，调整的方式是先删除一条边、然后增加一条边，使重心是唯一的
class120/Code04_LinkCutCentroids.java:// 如果方案有多种，打印其中一种即可
class120/Code04_LinkCutCentroids.java:// 比如先删除节点3和节点4之间的边，再增加节点4和节点7之间的边，那么打印:
class120/Code04_LinkCutCentroids.java:// "3 4"
class120/Code04_LinkCutCentroids.java:// "4 7"
class120/Code04_LinkCutCentroids.java:// 测试链接 : https://www.luogu.com.cn/problem/CF1406C
class120/Code04_LinkCutCentroids.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
算法讲解121【扩展】树上问题专题4-树的直径
class121/Code01_Diameter1.java:// 树的直径模版(两遍dfs)
class121/Code01_Diameter1.java:// 给定一棵树，边权可能为负，求直径长度
class121/Code01_Diameter1.java:// 测试链接 : https://www.luogu.com.cn/problem/U81904
class121/Code01_Diameter1.java:// 提交以下的code，提交时请把类名改成"Main"
class121/Code01_Diameter1.java:// 会有无法通过的用例，因为树上有负边
class121/Code01_Diameter2.java:// 树的直径模版(树型dp)
class121/Code01_Diameter2.java:// 给定一棵树，边权可能为负，求直径长度
class121/Code01_Diameter2.java:// 测试链接 : https://www.luogu.com.cn/problem/U81904
class121/Code01_Diameter2.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有的用例
class121/Code01_Diameter3.java:// 树的直径模版(树型dp版逻辑小化简)
class121/Code01_Diameter3.java:// 给定一棵树，边权可能为负，求直径长度
class121/Code01_Diameter3.java:// 测试链接 : https://www.luogu.com.cn/problem/U81904
class121/Code01_Diameter3.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有的用例
class121/Code02_DiameterAndCommonEdges1.java:// 所有直径的公共部分(递归版)
class121/Code02_DiameterAndCommonEdges1.java:// 给定一棵树，边权都为正
class121/Code02_DiameterAndCommonEdges1.java:// 打印直径长度、所有直径的公共部分有几条边
class121/Code02_DiameterAndCommonEdges1.java:// 测试链接 : https://www.luogu.com.cn/problem/P3304
class121/Code02_DiameterAndCommonEdges1.java:// 提交以下的code，提交时请把类名改成"Main"
class121/Code02_DiameterAndCommonEdges1.java:// C++这么写能通过，java会因为递归层数太多而爆栈
class121/Code02_DiameterAndCommonEdges1.java:// java能通过的写法参考本节课Code02_DiameterAndCommonEdges2文件
class121/Code02_DiameterAndCommonEdges2.java:// 所有直径的公共部分(迭代版)
class121/Code02_DiameterAndCommonEdges2.java:// 给定一棵树，边权都为正
class121/Code02_DiameterAndCommonEdges2.java:// 打印直径长度、所有直径的公共部分有几条边
class121/Code02_DiameterAndCommonEdges2.java:// 测试链接 : https://www.luogu.com.cn/problem/P3304
class121/Code02_DiameterAndCommonEdges2.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class121/Code03_BuildPark.java:// 造公园
class121/Code03_BuildPark.java:// 一共n个节点，编号1~n，有m条边连接，边权都是1
class121/Code03_BuildPark.java:// 所有节点可能形成多个联通区，每个联通区保证是树结构
class121/Code03_BuildPark.java:// 有两种类型的操作
class121/Code03_BuildPark.java:// 操作 1 x   : 返回x到离它最远的点的距离
class121/Code03_BuildPark.java:// 操作 2 x y : 如果x和y已经联通，那么忽略
class121/Code03_BuildPark.java://              如果不联通，那么执行联通操作，把x和y各自的区域联通起来
class121/Code03_BuildPark.java://              并且要保证联通成的大区域的直径长度最小
class121/Code03_BuildPark.java:// 测试链接 : https://www.luogu.com.cn/problem/P2195
class121/Code03_BuildPark.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class121/Code04_Patrol.java:// 巡逻
class121/Code04_Patrol.java:// 一共n个节点，编号1~n，结构是一棵树，每条边都是双向的
class121/Code04_Patrol.java:// 警察局在1号点，警车每天从1号点出发，一定要走过树上所有的边，最后回到1号点
class121/Code04_Patrol.java:// 现在为了减少经过边的数量，你可以新建k条边，把树上任意两点直接相连
class121/Code04_Patrol.java:// 并且每天警车必须经过新建的道路正好一次
class121/Code04_Patrol.java:// 计算出最佳的新建道路的方案，返回巡逻走边数量的最小值
class121/Code04_Patrol.java:// 测试链接 : https://www.luogu.com.cn/problem/P3629
class121/Code04_Patrol.java:// 1 <= n <= 10^5
class121/Code04_Patrol.java:// 1 <= k <= 2
class121/Code04_Patrol.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class121/Code05_FireFighting1.java:// 消防(递归版)
class121/Code05_FireFighting1.java:// 一共n个节点，编号1~n，有n-1条边连接成一棵树，每条边上有非负权值
class121/Code05_FireFighting1.java:// 给定一个非负整数s，表示可以在树上选择一条长度不超过s的路径
class121/Code05_FireFighting1.java:// 然后在这条路径的点上建立消防站，每个居民可以去往这条路径上的任何消防站
class121/Code05_FireFighting1.java:// 目标：哪怕最远的居民走到消防站的距离也要尽量少
class121/Code05_FireFighting1.java:// 返回最远居民走到消防站的最短距离
class121/Code05_FireFighting1.java:// 测试链接 : https://www.luogu.com.cn/problem/P2491
class121/Code05_FireFighting1.java:// 提交以下的code，提交时请把类名改成"Main"
class121/Code05_FireFighting1.java:// C++这么写能通过，java会因为递归层数太多而爆栈
class121/Code05_FireFighting1.java:// java能通过的写法参考本节课Code05_FireFighting2文件
class121/Code05_FireFighting2.java:// 消防(迭代版)
class121/Code05_FireFighting2.java:// 一共n个节点，编号1~n，有n-1条边连接成一棵树，每条边上有非负权值
class121/Code05_FireFighting2.java:// 给定一个非负整数s，表示可以在树上选择一条长度不超过s的路径
class121/Code05_FireFighting2.java:// 然后在这条路径的点上建立消防站，每个居民可以去往这条路径上的任何消防站
class121/Code05_FireFighting2.java:// 目标：哪怕最远的居民走到消防站的距离也要尽量少
class121/Code05_FireFighting2.java:// 返回最远居民走到消防站的最短距离
class121/Code05_FireFighting2.java:// 测试链接 : https://www.luogu.com.cn/problem/P2491
class121/Code05_FireFighting2.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
算法讲解122【扩展】树上问题专题5-树上差分
class122/Code01_MaxFlow1.java:// 树上点差分模版(递归版)
class122/Code01_MaxFlow1.java:// 有n个节点形成一棵树，一开始所有点权都是0
class122/Code01_MaxFlow1.java:// 给定很多操作，每个操作(a,b)表示从a到b路径上所有点的点权增加1
class122/Code01_MaxFlow1.java:// 所有操作完成后，返回树上的最大点权
class122/Code01_MaxFlow1.java:// 测试链接 : https://www.luogu.com.cn/problem/P3128
class122/Code01_MaxFlow1.java:// 提交以下的code，提交时请把类名改成"Main"
class122/Code01_MaxFlow1.java:// C++这么写能通过，java会因为递归层数太多而爆栈
class122/Code01_MaxFlow1.java:// java能通过的写法参考本节课Code01_MaxFlow2文件
class122/Code01_MaxFlow2.java:// 树上点差分模版(迭代版)
class122/Code01_MaxFlow2.java:// 有n个节点形成一棵树，一开始所有点权都是0
class122/Code01_MaxFlow2.java:// 给定很多操作，每个操作(a,b)表示从a到b路径上所有点的点权增加1
class122/Code01_MaxFlow2.java:// 所有操作完成后，返回树上的最大点权
class122/Code01_MaxFlow2.java:// 测试链接 : https://www.luogu.com.cn/problem/P3128
class122/Code01_MaxFlow2.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class122/Code02_SquirrelHome1.java:// 松鼠的新家(递归版)
class122/Code02_SquirrelHome1.java:// 有n个节点形成一棵树
class122/Code02_SquirrelHome1.java:// 给定一个由点编号组成的数组，表示松鼠依次要去往的地点
class122/Code02_SquirrelHome1.java:// 松鼠每走到一个节点都必须拿一个糖果，否则松鼠就停止前进
class122/Code02_SquirrelHome1.java:// 松鼠来到最后一个地点时不需要吃糖果
class122/Code02_SquirrelHome1.java:// 打印每个节点上至少准备多少糖果才能让松鼠依次走完数组里的节点
class122/Code02_SquirrelHome1.java:// 测试链接 : https://www.luogu.com.cn/problem/P3258
class122/Code02_SquirrelHome1.java:// 提交以下的code，提交时请把类名改成"Main"
class122/Code02_SquirrelHome1.java:// C++这么写能通过，java会因为递归层数太多而爆栈
class122/Code02_SquirrelHome1.java:// java能通过的写法参考本节课Code02_SquirrelHome2文件
class122/Code02_SquirrelHome2.java:// 松鼠的新家(迭代版)
class122/Code02_SquirrelHome2.java:// 有n个节点形成一棵树
class122/Code02_SquirrelHome2.java:// 给定一个由点编号组成的数组，表示松鼠依次要去往的地点
class122/Code02_SquirrelHome2.java:// 松鼠每走到一个节点都必须拿一个糖果，否则松鼠就停止前进
class122/Code02_SquirrelHome2.java:// 松鼠来到最后一个地点时不需要吃糖果
class122/Code02_SquirrelHome2.java:// 打印每个节点上至少准备多少糖果才能让松鼠依次走完数组里的节点
class122/Code02_SquirrelHome2.java:// 测试链接 : https://www.luogu.com.cn/problem/P3258
class122/Code02_SquirrelHome2.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class122/Code03_MinimizePriceOfTrips1.java:// 最小化旅行的价格总和(倍增方法求lca)
class122/Code03_MinimizePriceOfTrips1.java:// 有n个节点形成一棵树，每个节点上有点权，再给定很多路径
class122/Code03_MinimizePriceOfTrips1.java:// 每条路径有开始点和结束点，路径代价就是从开始点到结束点的点权和
class122/Code03_MinimizePriceOfTrips1.java:// 所有路径的代价总和就是旅行的价格总和
class122/Code03_MinimizePriceOfTrips1.java:// 你可以选择把某些点的点权减少一半，来降低旅行的价格总和
class122/Code03_MinimizePriceOfTrips1.java:// 但是要求选择的点不能相邻
class122/Code03_MinimizePriceOfTrips1.java:// 返回旅行的价格总和最少能是多少
class122/Code03_MinimizePriceOfTrips1.java:// 测试链接 : https://leetcode.cn/problems/minimize-the-total-price-of-the-trips/
class122/Code03_MinimizePriceOfTrips2.java:// 最小化旅行的价格总和(tarjan方法求lca)
class122/Code03_MinimizePriceOfTrips2.java:// 有n个节点形成一棵树，每个节点上有点权，再给定很多路径
class122/Code03_MinimizePriceOfTrips2.java:// 每条路径有开始点和结束点，路径代价就是从开始点到结束点的点权和
class122/Code03_MinimizePriceOfTrips2.java:// 所有路径的代价总和就是旅行的价格总和
class122/Code03_MinimizePriceOfTrips2.java:// 你可以选择把某些点的点权减少一半，来降低旅行的价格总和
class122/Code03_MinimizePriceOfTrips2.java:// 但是要求选择的点不能相邻
class122/Code03_MinimizePriceOfTrips2.java:// 返回旅行的价格总和最少能是多少
class122/Code03_MinimizePriceOfTrips2.java:// 测试链接 : https://leetcode.cn/problems/minimize-the-total-price-of-the-trips/
class122/Code04_Network.java:// 边差分实战
class122/Code04_Network.java:// 使图不联通的方法数
class122/Code04_Network.java:// 有n个节点，给定n-1条老边使其连接成一棵树，再给定m条新边额外加在树上
class122/Code04_Network.java:// 你可以切断两条边让这个图不联通，切断的两条边必须是一条老边和一条新边
class122/Code04_Network.java:// 返回方法数
class122/Code04_Network.java:// 测试链接 : http://poj.org/problem?id=3417
class122/Code04_Network.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class122/Code05_TransportPlan1.java:// 运输计划(递归版)
class122/Code05_TransportPlan1.java:// 有n个节点，给定n-1条边使其连接成一棵树，每条边有正数边权
class122/Code05_TransportPlan1.java:// 给定很多运输计划，每个运输计划(a,b)表示从a去往b
class122/Code05_TransportPlan1.java:// 每个运输计划的代价就是沿途边权和，运输计划之间完全互不干扰
class122/Code05_TransportPlan1.java:// 你只能选择一条边，将其边权变成0
class122/Code05_TransportPlan1.java:// 你的目的是让所有运输计划代价的最大值尽量小
class122/Code05_TransportPlan1.java:// 返回所有运输计划代价的最大值最小能是多少
class122/Code05_TransportPlan1.java:// 测试链接 : https://www.luogu.com.cn/problem/P2680
class122/Code05_TransportPlan1.java:// 提交以下的code，提交时请把类名改成"Main"
class122/Code05_TransportPlan1.java:// C++这么写能通过，java会因为递归层数太多而爆栈
class122/Code05_TransportPlan1.java:// java能通过的写法参考本节课Code05_TransportPlan2文件
class122/Code05_TransportPlan2.java:// 运输计划(迭代版)
class122/Code05_TransportPlan2.java:// 有n个节点，给定n-1条边使其连接成一棵树，每条边有正数边权
class122/Code05_TransportPlan2.java:// 给定很多运输计划，每个运输计划(a,b)表示从a去往b
class122/Code05_TransportPlan2.java:// 每个运输计划的代价就是沿途边权和，运输计划之间完全互不干扰
class122/Code05_TransportPlan2.java:// 你只能选择一条边，将其边权变成0
class122/Code05_TransportPlan2.java:// 你的目的是让所有运输计划代价的最大值尽量小
class122/Code05_TransportPlan2.java:// 返回所有运输计划代价的最大值最小能是多少
class122/Code05_TransportPlan2.java:// 测试链接 : https://www.luogu.com.cn/problem/P2680
class122/Code05_TransportPlan2.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
算法讲解123【扩展】树上问题专题6-换根dp
class123/Code01_MaximizeSumOfDeeps1.java:// 最大深度和(递归版)
class123/Code01_MaximizeSumOfDeeps1.java:// 给定一棵n个点的树，找到一个节点，使得以这个节点为根时，到达所有节点的深度之和最大
class123/Code01_MaximizeSumOfDeeps1.java:// 如果有多个节点满足要求，返回节点编号最小的
class123/Code01_MaximizeSumOfDeeps1.java:// 测试链接 : https://www.luogu.com.cn/problem/P3478
class123/Code01_MaximizeSumOfDeeps1.java:// 提交以下的code，提交时请把类名改成"Main"
class123/Code01_MaximizeSumOfDeeps1.java:// C++这么写能通过，java会因为递归层数太多而爆栈
class123/Code01_MaximizeSumOfDeeps1.java:// java能通过的写法参考本节课Code01_MaximizeSumOfDeeps2文件
class123/Code01_MaximizeSumOfDeeps2.java:// 最大深度和(迭代版)
class123/Code01_MaximizeSumOfDeeps2.java:// 给定一棵n个点的树，找到一个节点，使得以这个节点为根时，到达所有节点的深度之和最大
class123/Code01_MaximizeSumOfDeeps2.java:// 如果有多个节点满足要求，返回节点编号最小的
class123/Code01_MaximizeSumOfDeeps2.java:// 测试链接 : https://www.luogu.com.cn/problem/P3478
class123/Code01_MaximizeSumOfDeeps2.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class123/Code02_TreePainting.java:// 染色的最大收益
class123/Code02_TreePainting.java:// 给定一棵n个点的树，初始时所有节点全是白点
class123/Code02_TreePainting.java:// 第一次操作，你可以选择任意点染黑
class123/Code02_TreePainting.java:// 以后每次操作，必须选择已经染黑的点的相邻点继续染黑，一直到所有的点都被染完
class123/Code02_TreePainting.java:// 每次都获得，当前被染色点的白色联通块大小，作为收益
class123/Code02_TreePainting.java:// 返回可获得的最大收益和
class123/Code02_TreePainting.java:// 测试链接 : https://www.luogu.com.cn/problem/CF1187E
class123/Code02_TreePainting.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class123/Code03_ChooseCapital.java:// 翻转道路数量最少的首都
class123/Code03_ChooseCapital.java:// 给定一棵n个点的树，但是给定的每条边都是有向的
class123/Code03_ChooseCapital.java:// 需要选择某个城市为首都，要求首都一定可以去往任何一个城市
class123/Code03_ChooseCapital.java:// 这样一来，可能需要翻转一些边的方向才能做到，现在想翻转道路的数量尽量少
class123/Code03_ChooseCapital.java:// 打印最少翻转几条道路就可以拥有首都
class123/Code03_ChooseCapital.java:// 如果有若干点做首都时，翻转道路的数量都是最少的，那么打印这些点
class123/Code03_ChooseCapital.java:// 测试链接 : https://www.luogu.com.cn/problem/CF219D
class123/Code03_ChooseCapital.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class123/Code04_MaximizeFlow1.java:// 选择节点做根使流量和最大(递归版)
class123/Code04_MaximizeFlow1.java:// 给定一棵n个点的树，边的边权代表流量限制
class123/Code04_MaximizeFlow1.java:// 从边上流过的流量，不能超过流量限制
class123/Code04_MaximizeFlow1.java:// 现在想知道以某个节点做根时，流到所有叶节点的流量，最大是多少
class123/Code04_MaximizeFlow1.java:// 测试链接 : http://poj.org/problem?id=3585
class123/Code04_MaximizeFlow1.java:// 提交以下的code，提交时请把类名改成"Main"
class123/Code04_MaximizeFlow1.java:// C++这么写能通过，java会因为递归层数太多而爆栈
class123/Code04_MaximizeFlow1.java:// java能通过的写法参考本节课Code04_MaximizeFlow2文件
class123/Code04_MaximizeFlow2.java:// 选择节点做根使流量和最大(迭代版)
class123/Code04_MaximizeFlow2.java:// 给定一棵n个点的树，边的边权代表流量限制
class123/Code04_MaximizeFlow2.java:// 从边上流过的流量，不能超过流量限制
class123/Code04_MaximizeFlow2.java:// 现在想知道以某个节点做根时，流到所有叶节点的流量，最大是多少
class123/Code04_MaximizeFlow2.java:// 测试链接 : http://poj.org/problem?id=3585
class123/Code04_MaximizeFlow2.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class123/Code05_SumOfNearby1.java:// 每个节点距离k以内的权值和(递归版)
class123/Code05_SumOfNearby1.java:// 给定一棵n个点的树，每个点有点权
class123/Code05_SumOfNearby1.java:// 到达每个节点的距离不超过k的节点就有若干个
class123/Code05_SumOfNearby1.java:// 把这些节点权值加起来，就是该点不超过距离k的点权和
class123/Code05_SumOfNearby1.java:// 打印每个节点不超过距离k的点权和
class123/Code05_SumOfNearby1.java:// 注意k并不大
class123/Code05_SumOfNearby1.java:// 测试链接 : https://www.luogu.com.cn/problem/P3047
class123/Code05_SumOfNearby1.java:// 提交以下的code，提交时请把类名改成"Main"
class123/Code05_SumOfNearby1.java:// C++这么写能通过，java会因为递归层数太多而爆栈
class123/Code05_SumOfNearby1.java:// java能通过的写法参考本节课Code05_SumOfNearby2文件
class123/Code05_SumOfNearby2.java:// 每个节点距离k以内的权值和(迭代版)
class123/Code05_SumOfNearby2.java:// 给定一棵n个点的树，每个点有点权
class123/Code05_SumOfNearby2.java:// 到达每个节点的距离不超过k的节点就有若干个
class123/Code05_SumOfNearby2.java:// 把这些节点权值加起来，就是该点不超过距离k的点权和
class123/Code05_SumOfNearby2.java:// 打印每个节点不超过距离k的点权和
class123/Code05_SumOfNearby2.java:// 注意k并不大
class123/Code05_SumOfNearby2.java:// 测试链接 : https://www.luogu.com.cn/problem/P3047
class123/Code05_SumOfNearby2.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class123/Code06_Centroids.java:// 哪些点可以改造成重心
class123/Code06_Centroids.java:// 给定一棵n个点的树，你可以随便删掉一条边，然后随便加上一条边
class123/Code06_Centroids.java:// 通过这种方式可以让很多点变成重心
class123/Code06_Centroids.java:// 打印所有能变成重心的点
class123/Code06_Centroids.java:// 测试链接 : https://www.luogu.com.cn/problem/CF708C
class123/Code06_Centroids.java:// 测试链接 : https://codeforces.com/problemset/problem/708/C
class123/Code06_Centroids.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class123/Code07_Kamp.java:// 聚会后送每个人回家最短用时
class123/Code07_Kamp.java:// 给定一棵n个点的树，边权代表走过边需要花费的时间
class123/Code07_Kamp.java:// 给定k个人分别在树上的哪些节点
class123/Code07_Kamp.java:// 这k个人选择了一个聚会点，所有的人都去往聚会点进行聚会
class123/Code07_Kamp.java:// 聚会结束后，所有人都会上一辆车，车会把每个人送回家
class123/Code07_Kamp.java:// 送完最后一个乘客，车不需要回到聚会点
class123/Code07_Kamp.java:// 如果聚会点在i，请问从聚会地点出发直到送最后一个人回家，最短用时多少
class123/Code07_Kamp.java:// i = 1 ~ n，打印所有的答案
class123/Code07_Kamp.java:// 测试链接 : https://www.luogu.com.cn/problem/P6419
class123/Code07_Kamp.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
算法讲解124【扩展】Morris遍历
class124/Code01_MorrisPreorderInorder.java:// Morris遍历实现先序和中序遍历
class124/Code01_MorrisPreorderInorder.java:// 测试链接 : https://leetcode.cn/problems/binary-tree-preorder-traversal/
class124/Code01_MorrisPreorderInorder.java:// 测试链接 : https://leetcode.cn/problems/binary-tree-inorder-traversal/
class124/Code02_MorrisPostorder.java:// Morris遍历实现后序遍历
class124/Code02_MorrisPostorder.java:// 测试链接 : https://leetcode.cn/problems/binary-tree-postorder-traversal/
class124/Code03_MorrisCheckBST.java:// Morris遍历判断搜索二叉树
class124/Code03_MorrisCheckBST.java:// 测试链接 : https://leetcode.cn/problems/validate-binary-search-tree/
class124/Code04_MorrisMinimumDepth.java:// Morris遍历求二叉树最小高度
class124/Code04_MorrisMinimumDepth.java:// 测试链接 : https://leetcode.cn/problems/minimum-depth-of-binary-tree/
class124/Code05_MorrisLCS.java:// Morris遍历求两个节点的最低公共祖先
class124/Code05_MorrisLCS.java:// 测试链接 : https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/
算法讲解125【扩展】轮廓线dp
class125/Code01_CornFields1.java:// 种草的方法数(普通状压dp)
class125/Code01_CornFields1.java:// 给定一个n*m的二维网格grid
class125/Code01_CornFields1.java:// 网格里只有0、1两种值，0表示该田地不能种草，1表示该田地可以种草
class125/Code01_CornFields1.java:// 种草的时候，任何两个种了草的田地不能相邻，相邻包括上、下、左、右四个方向
class125/Code01_CornFields1.java:// 你可以随意决定种多少草，只要不破坏上面的规则即可
class125/Code01_CornFields1.java:// 返回种草的方法数，答案对100000000取模
class125/Code01_CornFields1.java:// 1 <= n, m <= 12
class125/Code01_CornFields1.java:// 测试链接 : https://www.luogu.com.cn/problem/P1879
class125/Code01_CornFields1.java:// 提交以下的code，提交时请把类名改成"Main"
class125/Code01_CornFields1.java:// 普通状压dp的版本无法通过所有测试用例
class125/Code01_CornFields1.java:// 有些测试样本会超时，这是dfs过程很费时导致的
class125/Code01_CornFields2.java:// 种草的方法数(轮廓线dp)
class125/Code01_CornFields2.java:// 给定一个n*m的二维网格grid
class125/Code01_CornFields2.java:// 网格里只有0、1两种值，0表示该田地不能种草，1表示该田地可以种草
class125/Code01_CornFields2.java:// 种草的时候，任何两个种了草的田地不能相邻，相邻包括上、下、左、右四个方向
class125/Code01_CornFields2.java:// 你可以随意决定种多少草，只要不破坏上面的规则即可
class125/Code01_CornFields2.java:// 返回种草的方法数，答案对100000000取模
class125/Code01_CornFields2.java:// 1 <= n, m <= 12
class125/Code01_CornFields2.java:// 测试链接 : https://www.luogu.com.cn/problem/P1879
class125/Code01_CornFields2.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class125/Code01_CornFields3.java:// 种草的方法数(轮廓线dp+空间压缩)
class125/Code01_CornFields3.java:// 给定一个n*m的二维网格grid
class125/Code01_CornFields3.java:// 网格里只有0、1两种值，0表示该田地不能种草，1表示该田地可以种草
class125/Code01_CornFields3.java:// 种草的时候，任何两个种了草的田地不能相邻，相邻包括上、下、左、右四个方向
class125/Code01_CornFields3.java:// 你可以随意决定种多少草，只要不破坏上面的规则即可
class125/Code01_CornFields3.java:// 返回种草的方法数，答案对100000000取模
class125/Code01_CornFields3.java:// 1 <= n, m <= 12
class125/Code01_CornFields3.java:// 测试链接 : https://www.luogu.com.cn/problem/P1879
class125/Code01_CornFields3.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class125/Code02_PavingTile1.java:// 贴瓷砖的方法数(轮廓线dp)
class125/Code02_PavingTile1.java:// 给定两个参数n和m，表示n行m列的空白区域
class125/Code02_PavingTile1.java:// 有无限多的1*2规格的瓷砖，目标是严丝合缝的铺满所有的空白区域
class125/Code02_PavingTile1.java:// 返回有多少种铺满的方法
class125/Code02_PavingTile1.java:// 1 <= n, m <= 11
class125/Code02_PavingTile1.java:// 测试链接 : http://poj.org/problem?id=2411
class125/Code02_PavingTile1.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class125/Code02_PavingTile2.java:// 贴瓷砖的方法数(轮廓线dp+空间压缩)
class125/Code02_PavingTile2.java:// 给定两个参数n和m，表示n行m列的空白区域
class125/Code02_PavingTile2.java:// 有无限多的1*2规格的瓷砖，目标是严丝合缝的铺满所有的空白区域
class125/Code02_PavingTile2.java:// 返回有多少种铺满的方法
class125/Code02_PavingTile2.java:// 1 <= n, m <= 11
class125/Code02_PavingTile2.java:// 测试链接 : http://poj.org/problem?id=2411
class125/Code02_PavingTile2.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class125/Code03_AdjacentDifferent1.java:// 相邻不同色的染色方法数(轮廓线dp)
class125/Code03_AdjacentDifferent1.java:// 给定两个参数n和m，表示n行m列的空白区域，一开始所有格子都没有颜色
class125/Code03_AdjacentDifferent1.java:// 给定参数k，表示有k种颜色，颜色编号0~k-1
class125/Code03_AdjacentDifferent1.java:// 你需要给每个格子染色，但是相邻的格子颜色不能相同
class125/Code03_AdjacentDifferent1.java:// 相邻包括上、下、左、右四个方向
class125/Code03_AdjacentDifferent1.java:// 并且给定了第0行和第n-1行的颜色状况，输入保证一定有效
class125/Code03_AdjacentDifferent1.java:// 那么你只能在1~n-2行上染色，返回染色的方法数，答案对376544743取模
class125/Code03_AdjacentDifferent1.java:// 2 <= k <= 4
class125/Code03_AdjacentDifferent1.java:// k = 2时，1 <= n <= 10^7，1 <= m <= 10^5
class125/Code03_AdjacentDifferent1.java:// 3 <= k <= 4时，1 <= n <= 100，1 <= m <= 8
class125/Code03_AdjacentDifferent1.java:// 测试链接 : https://www.luogu.com.cn/problem/P2435
class125/Code03_AdjacentDifferent1.java:// 提交以下的code，提交时请把类名改成"Main"
class125/Code03_AdjacentDifferent1.java:// 空间会不达标，在线测试无法全部通过，但逻辑正确
class125/Code03_AdjacentDifferent1.java:// 我运行了所有可能的情况，结果是正确的
class125/Code03_AdjacentDifferent2.java:// 相邻不同色的染色方法数(轮廓线dp+空间压缩)
class125/Code03_AdjacentDifferent2.java:// 给定两个参数n和m，表示n行m列的空白区域，一开始所有格子都没有颜色
class125/Code03_AdjacentDifferent2.java:// 给定参数k，表示有k种颜色，颜色编号0~k-1
class125/Code03_AdjacentDifferent2.java:// 你需要给每个格子染色，但是相邻的格子颜色不能相同
class125/Code03_AdjacentDifferent2.java:// 相邻包括上、下、左、右四个方向
class125/Code03_AdjacentDifferent2.java:// 并且给定了第0行和第n-1行的颜色状况，输入保证一定有效
class125/Code03_AdjacentDifferent2.java:// 那么你只能在1~n-2行上染色，返回染色的方法数，答案对376544743取模
class125/Code03_AdjacentDifferent2.java:// 2 <= k <= 4
class125/Code03_AdjacentDifferent2.java:// k = 2时，1 <= n <= 10^7，1 <= m <= 10^5
class125/Code03_AdjacentDifferent2.java:// 3 <= k <= 4时，1 <= n <= 100，1 <= m <= 8
class125/Code03_AdjacentDifferent2.java:// 测试链接 : https://www.luogu.com.cn/problem/P2435
class125/Code03_AdjacentDifferent2.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class125/Code03_AdjacentDifferent2.java:// 空间压缩的版本才能通过
class125/Code04_KingsFighting1.java:// 摆放国王的方法数(轮廓线dp)
class125/Code04_KingsFighting1.java:// 给定两个参数n和k，表示n*n的区域内要摆放k个国王
class125/Code04_KingsFighting1.java:// 国王可以攻击临近的8个方向，所以摆放时不能让任何两个国王打架
class125/Code04_KingsFighting1.java:// 返回摆放的方法数
class125/Code04_KingsFighting1.java:// 1 <= n <= 9
class125/Code04_KingsFighting1.java:// 1 <= k <= n*n
class125/Code04_KingsFighting1.java:// 测试链接 : https://www.luogu.com.cn/problem/P1896
class125/Code04_KingsFighting1.java:// 提交以下的code，提交时请把类名改成"Main"，有可能全部通过
class125/Code04_KingsFighting1.java:// 不过更推荐写出空间压缩的版本
class125/Code04_KingsFighting2.java:// 摆放国王的方法数(轮廓线dp+空间压缩)
class125/Code04_KingsFighting2.java:// 给定两个参数n和k，表示n*n的区域内要摆放k个国王
class125/Code04_KingsFighting2.java:// 国王可以攻击临近的8个方向，所以摆放时不能让任何两个国王打架
class125/Code04_KingsFighting2.java:// 返回摆放的方法数
class125/Code04_KingsFighting2.java:// 1 <= n <= 9
class125/Code04_KingsFighting2.java:// 1 <= k <= n*n
class125/Code04_KingsFighting2.java:// 测试链接 : https://www.luogu.com.cn/problem/P1896
class125/Code04_KingsFighting2.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class125/Code04_KingsFighting2.java:// 空间压缩的版本一定稳定通过
算法讲解126【扩展】三进制状压dp
class126/Code01_GridHappiness.java:// 最大化网格幸福感
class126/Code01_GridHappiness.java:// 给定四个整数m、n、in、ex，表示m*n的网格，以及in个内向的人，ex个外向的人
class126/Code01_GridHappiness.java:// 你来决定网格中应当居住多少人，并为每个人分配一个网格单元，不必让所有人都生活在网格中
class126/Code01_GridHappiness.java:// 每个人的幸福感计算如下：
class126/Code01_GridHappiness.java:// 内向的人开始时有120幸福感，但每存在一个邻居，他都会失去30幸福感
class126/Code01_GridHappiness.java:// 外向的人开始时有40幸福感，但每存在一个邻居，他都会得到20幸福感
class126/Code01_GridHappiness.java:// 邻居只包含上、下、左、右四个方向
class126/Code01_GridHappiness.java:// 网格幸福感是每个人幸福感的总和，返回最大可能的网格幸福感
class126/Code01_GridHappiness.java:// 1 <= m、n <= 5
class126/Code01_GridHappiness.java:// 1 <= in、ex <= 6
class126/Code01_GridHappiness.java:// 测试链接 : https://leetcode.cn/problems/maximize-grid-happiness/
class126/Code01_GridHappiness.java:// 有兴趣的同学可以自己改一下空间压缩的版本
class126/Code02_GridPainting.java:// 用三种不同颜色为网格涂色
class126/Code02_GridPainting.java:// 给你两个整数m和n，表示m*n的网格，其中每个单元格最开始是白色
class126/Code02_GridPainting.java:// 请你用红、绿、蓝三种颜色为每个单元格涂色，所有单元格都需要被涂色
class126/Code02_GridPainting.java:// 要求相邻单元格的颜色一定要不同
class126/Code02_GridPainting.java:// 返回网格涂色的方法数，答案对1000000007取余
class126/Code02_GridPainting.java:// 1 <= m <= 5
class126/Code02_GridPainting.java:// 1 <= n <= 1000
class126/Code02_GridPainting.java:// 测试链接 : https://leetcode.cn/problems/painting-a-grid-with-three-different-colors/
class126/Code02_GridPainting.java:// 有兴趣的同学可以自己改一下空间压缩的版本
class126/Code03_TspTwice.java:// 节点最多经过两次的tsp问题
class126/Code03_TspTwice.java:// 给定有n个地点，用m条边无向边连接，每条边有权值
class126/Code03_TspTwice.java:// 你可以任选一点出发，目标是经过所有的点，最终不必回到出发点
class126/Code03_TspTwice.java:// 并且每个点最多可以到达两次
class126/Code03_TspTwice.java:// 返回总路程最小是多少
class126/Code03_TspTwice.java:// 1 <= n <= 10
class126/Code03_TspTwice.java:// 1 <= m <= 100
class126/Code03_TspTwice.java:// 测试链接 : https://acm.hdu.edu.cn/showproblem.php?pid=3001
class126/Code03_TspTwice.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
算法讲解127【扩展】动态规划优化专题1-优化尝试和状态设计-上
class127/Code01_CherryPickup.java:// 摘樱桃
class127/Code01_CherryPickup.java:// 给定一个n*n的正方形矩阵grid，每个格子值只有三种-1、0、1
class127/Code01_CherryPickup.java:// -1表示格子不能走、0表示格子可以走但是没有樱桃、1表示格子可以走且有一颗樱桃
class127/Code01_CherryPickup.java:// 你的目标是从左上角走到右下角，每一步只能 向下 或者 向右
class127/Code01_CherryPickup.java:// 然后从右下角走回左上角，每一步只能 向上 或者 向左
class127/Code01_CherryPickup.java:// 这个过程中，想尽量多的获得樱桃，但是有樱桃的格子，只能捡一次
class127/Code01_CherryPickup.java:// 返回最多能获得多少樱桃，如果不存在通路返回0
class127/Code01_CherryPickup.java:// 测试链接 : https://leetcode.cn/problems/cherry-pickup/
class127/Code01_CherryPickup.java:// 这里只讲述核心思路
class127/Code01_CherryPickup.java:// 有兴趣同学自己改出严格位置依赖的动态规划
class127/Code01_CherryPickup.java:// 有兴趣同学自己改出空间压缩版本的动态规划
class127/Code01_CherryPickup.java:// 之前的课大量涉及，这里不再赘述
class127/Code02_FrogToSchool.java:// 上学需要的最少跳跃能力
class127/Code02_FrogToSchool.java:// 青蛙住在一条河边，家在0位置, 每天到河对岸的上学，学校在n位置
class127/Code02_FrogToSchool.java:// 河里的石头排成了一条直线，青蛙每次跳跃必须落在一块石头或者岸上
class127/Code02_FrogToSchool.java:// 给定一个长度为n-1的数组arr，表示1~n-1位置每块石头的高度数值
class127/Code02_FrogToSchool.java:// 每次青蛙从一块石头起跳，这块石头的高度就会下降1
class127/Code02_FrogToSchool.java:// 当石头的高度下降到0时，青蛙不能再跳到这块石头上，跳跃后使石头高度下降到0是允许的
class127/Code02_FrogToSchool.java:// 青蛙一共需要去学校上x天课, 所以它需要往返x次，青蛙具有跳跃能力y, 它可以跳跃不超过y的距离
class127/Code02_FrogToSchool.java:// 请问青蛙的跳跃能力至少是多少，才能用这些石头往返x次
class127/Code02_FrogToSchool.java:// 1 <= n <= 10^5
class127/Code02_FrogToSchool.java:// 1 <= arr[i] <= 10^4
class127/Code02_FrogToSchool.java:// 1 <= x <= 10^9
class127/Code02_FrogToSchool.java:// 测试链接 : https://www.luogu.com.cn/problem/P8775
class127/Code02_FrogToSchool.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class127/Code03_MultiplyPositiveNegative.java:// 相乘为正或负的子数组数量
class127/Code03_MultiplyPositiveNegative.java:// 给定一个长度为n的数组arr，其中所有值都不是0
class127/Code03_MultiplyPositiveNegative.java:// 返回有多少个子数组相乘的结果是正
class127/Code03_MultiplyPositiveNegative.java:// 返回有多少个子数组相乘的结果是负
class127/Code03_MultiplyPositiveNegative.java:// 1 <= n <= 10^6
class127/Code03_MultiplyPositiveNegative.java:// -10^9 <= arr[i] <= +10^9，arr[i]一定不是0
class127/Code03_MultiplyPositiveNegative.java:// 来自真实大厂笔试，对数器验证
class127/Code04_LongestAddNotZero.java:// 相邻与结果不为0的最长子序列
class127/Code04_LongestAddNotZero.java:// 给定一个长度为n的数组arr，你可以随意选择数字组成子序列
class127/Code04_LongestAddNotZero.java:// 但是要求任意相邻的两个数&的结果不能是0，这样的子序列才是合法的
class127/Code04_LongestAddNotZero.java:// 返回最长合法子序列的长度
class127/Code04_LongestAddNotZero.java:// 1 <= n <= 10^5
class127/Code04_LongestAddNotZero.java:// 0 <= arr[i] <= 10^9
class127/Code04_LongestAddNotZero.java:// 测试链接 : https://www.luogu.com.cn/problem/P4310
class127/Code04_LongestAddNotZero.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class127/Code05_WaysOfArrangePlates.java:// 摆盘子的方法
class127/Code05_WaysOfArrangePlates.java:// 一共有n个盘子k种菜，所有盘子排成一排，每个盘子只能放一种菜
class127/Code05_WaysOfArrangePlates.java:// 要求最多连续两个盘子菜品一样，更长的重复出现是不允许的
class127/Code05_WaysOfArrangePlates.java:// 返回摆盘的方法数，答案可能很大，对1000000007取余
class127/Code05_WaysOfArrangePlates.java:// 1 <= n <= 1000
class127/Code05_WaysOfArrangePlates.java:// 1 <= k <= 1000
class127/Code05_WaysOfArrangePlates.java:// 来自真实大厂笔试，对数器验证
class127/Code06_FrogCrossRiver.java:// 过河踩过的最少石子数
class127/Code06_FrogCrossRiver.java:// 在河上有一座独木桥，一只青蛙想沿着独木桥从河的一侧跳到另一侧
class127/Code06_FrogCrossRiver.java:// 在桥上有一些石子，青蛙很讨厌踩在这些石子上
class127/Code06_FrogCrossRiver.java:// 我们可以把独木桥上青蛙可能到达的点看成数轴上的一串整点0...n
class127/Code06_FrogCrossRiver.java:// 其中n是桥的长度，坐标为0的点表示桥的起点，坐标为n的点表示桥的终点
class127/Code06_FrogCrossRiver.java:// 青蛙从桥的起点开始，不停的向终点方向跳跃，一次跳跃的距离是[s,t]之间的任意正整数
class127/Code06_FrogCrossRiver.java:// 当青蛙跳到或跳过坐标为n的点时，就算青蛙已经跳出了独木桥
class127/Code06_FrogCrossRiver.java:// 题目给出独木桥的长度n，青蛙跳跃的距离范围s、t，题目还给定m个桥上石子的位置
class127/Code06_FrogCrossRiver.java:// 你的任务是确定青蛙要想过河，最少需要踩到的石子数
class127/Code06_FrogCrossRiver.java:// 1 <= n <= 10^7
class127/Code06_FrogCrossRiver.java:// 1 <= s <= t <= 10
class127/Code06_FrogCrossRiver.java:// 1 <= m <= 100
class127/Code06_FrogCrossRiver.java:// 测试链接 : https://www.luogu.com.cn/problem/P1052
class127/Code06_FrogCrossRiver.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
算法讲解128【扩展】动态规划优化专题2-优化尝试和状态设计-下
class128/Code01_ApplesPlates.java:// 苹果和盘子
class128/Code01_ApplesPlates.java:// 有m个苹果，认为苹果之间无差别，有n个盘子，认为盘子之间无差别
class128/Code01_ApplesPlates.java:// 比如5个苹果如果放进3个盘子，那么(1, 3, 1) (1, 1, 3) (3, 1, 1)认为是同一种方法
class128/Code01_ApplesPlates.java:// 允许有些盘子是空的，返回有多少种放置方法
class128/Code01_ApplesPlates.java:// 测试链接 : https://www.nowcoder.com/practice/bfd8234bb5e84be0b493656e390bdebf
class128/Code01_ApplesPlates.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class128/Code01_SplitNumber.java:// 数的划分方法
class128/Code01_SplitNumber.java:// 将整数m分成n份，且每份不能为空，任意两个方案不相同(不考虑顺序)
class128/Code01_SplitNumber.java:// 比如，m=7、n=3，那么(1, 1, 5) (1, 5, 1) (5, 1, 1)认为是同一种方法
class128/Code01_SplitNumber.java:// 返回有多少种不同的划分方法
class128/Code01_SplitNumber.java:// 测试链接 : https://www.luogu.com.cn/problem/P1025
class128/Code01_SplitNumber.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class128/Code02_BestDeploy.java:// 最好的部署
class128/Code02_BestDeploy.java:// 一共有n台机器，编号1 ~ n，所有机器排成一排
class128/Code02_BestDeploy.java:// 你只能一台一台的部署机器，你可以决定部署的顺序，最终所有机器都要部署
class128/Code02_BestDeploy.java:// 给定三个数组no[]、one[]、both[]
class128/Code02_BestDeploy.java:// no[i] : 如果i号机器部署时，相邻没有机器部署，此时能获得的收益
class128/Code02_BestDeploy.java:// one[i] : 如果i号机器部署时，相邻有一台机器部署，此时能获得的收益
class128/Code02_BestDeploy.java:// both[i] : 如果i号机器部署时，相邻有两台机器部署，此时能获得的收益
class128/Code02_BestDeploy.java:// 第1号机器、第n号机器当然不会有两台相邻的机器
class128/Code02_BestDeploy.java:// 返回部署的最大收益
class128/Code02_BestDeploy.java:// 1 <= n <= 10^5
class128/Code02_BestDeploy.java:// 0 <= no[i]、one[i]、both[i]
class128/Code02_BestDeploy.java:// 来自真实大厂笔试，对数器验证
class128/Code03_AddLimitLcs.java:// 增加限制的最长公共子序列问题
class128/Code03_AddLimitLcs.java:// 给定两个字符串s1和s2，s1长度为n，s2长度为m
class128/Code03_AddLimitLcs.java:// 返回s1和s2的最长公共子序列长度
class128/Code03_AddLimitLcs.java:// 注意：
class128/Code03_AddLimitLcs.java:// 两个字符串都只由小写字母组成
class128/Code03_AddLimitLcs.java:// 1 <= n <= 10^6
class128/Code03_AddLimitLcs.java:// 1 <= m <= 10^3
class128/Code03_AddLimitLcs.java:// 状态设计优化的经典题，对数器验证
class128/Code04_EggDrop.java:// 大楼扔鸡蛋问题
class128/Code04_EggDrop.java:// 一共有k枚相同的鸡蛋，一共有n层楼
class128/Code04_EggDrop.java:// 已知一定存在楼层f(0<=f<=n)，从>f的楼层扔鸡蛋一定会碎，从<=f的楼层扔鸡蛋，扔几次都不会碎
class128/Code04_EggDrop.java:// 鸡蛋一旦碎了就不能再使用，只能选择另外的鸡蛋
class128/Code04_EggDrop.java:// 现在想确定f的值，返回最少扔几次鸡蛋，可以确保测出该值
class128/Code04_EggDrop.java:// 1 <= k <= 100
class128/Code04_EggDrop.java:// 1 <= n <= 10^4
class128/Code04_EggDrop.java:// 测试链接 : https://leetcode.cn/problems/super-egg-drop/
class128/Code05_MaximizeMedian.java:// 相邻必选的子序列最大中位数
class128/Code05_MaximizeMedian.java:// 给定一个长度为n的数组arr
class128/Code05_MaximizeMedian.java:// 合法子序列定义为，任意相邻的两个数至少要有一个被挑选所组成的子序列
class128/Code05_MaximizeMedian.java:// 求所有合法子序列中，最大中位数是多少
class128/Code05_MaximizeMedian.java:// 中位数的定义为上中位数
class128/Code05_MaximizeMedian.java:// [1, 2, 3, 4]的上中位数是2
class128/Code05_MaximizeMedian.java:// [1, 2, 3, 4, 5]的上中位数是3
class128/Code05_MaximizeMedian.java:// 2 <=  n <= 10^5
class128/Code05_MaximizeMedian.java:// 1 <= arr[i] <= 10^9
class128/Code05_MaximizeMedian.java:// 来自真实大厂笔试，对数器验证
class128/Code06_MarblesInBags.java:// 将珠子放进背包中
class128/Code06_MarblesInBags.java:// 给定一个长度为n的数组weights，背包一共有k个
class128/Code06_MarblesInBags.java:// 其中weights[i]是第i个珠子的重量
class128/Code06_MarblesInBags.java:// 请你按照如下规则将所有的珠子放进k个背包
class128/Code06_MarblesInBags.java:// 1，没有背包是空的
class128/Code06_MarblesInBags.java:// 2，如果第i个珠子和第j个珠子在同一个背包里，那么i到j所有珠子都要在这个背包里
class128/Code06_MarblesInBags.java:// 一个背包如果包含i到j的所有珠子，这个背包的价格是weights[i]+weights[j]
class128/Code06_MarblesInBags.java:// 一个珠子分配方案的分数，是所有k个背包的价格之和
class128/Code06_MarblesInBags.java:// 请返回所有分配方案中，最大分数与最小分数的差值为多少
class128/Code06_MarblesInBags.java:// 1 <= n, k <= 10^5
class128/Code06_MarblesInBags.java:// 测试链接 : https://leetcode.cn/problems/put-marbles-in-bags/
算法讲解129【扩展】动态规划优化专题3-倍增优化
class129/Code01_MaximumNumberOfEvents.java:// 参加会议II
class129/Code01_MaximumNumberOfEvents.java:// 给定n个会议，每个会议有开始时间、结束时间、收益三个值
class129/Code01_MaximumNumberOfEvents.java:// 参加会议就能得到收益，但是同一时间只能参加一个会议
class129/Code01_MaximumNumberOfEvents.java:// 一共能参加k个会议，如果选择参加某个会议，那么必须完整的参加完这个会议
class129/Code01_MaximumNumberOfEvents.java:// 会议结束日期是包含在会议内的，一个会议的结束时间等于另一个会议的开始时间，不能两个会议都参加
class129/Code01_MaximumNumberOfEvents.java:// 返回能得到的会议价值最大和
class129/Code01_MaximumNumberOfEvents.java:// 1 <= n * k <= 10^6
class129/Code01_MaximumNumberOfEvents.java:// 1 <= 开始时间、结束时间 <= 10^9
class129/Code01_MaximumNumberOfEvents.java:// 1 <= 收益 <= 10^6
class129/Code01_MaximumNumberOfEvents.java:// 测试链接 : https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended-ii/
class129/Code02_RanAway.java:// 跑路
class129/Code02_RanAway.java:// 一共有n个节点，编号1~n，一共有m条有向边，每条边1公里
class129/Code02_RanAway.java:// 有一个空间跑路器，每秒你都可以直接移动2^k公里，每秒钟可以随意决定k的值
class129/Code02_RanAway.java:// 题目保证1到n之间一定可以到达，返回1到n最少用几秒
class129/Code02_RanAway.java:// 2 <= n <= 50
class129/Code02_RanAway.java:// m <= 10^4
class129/Code02_RanAway.java:// k <= 64
class129/Code02_RanAway.java:// 测试链接 : https://www.luogu.com.cn/problem/P1613
class129/Code02_RanAway.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class129/Code03_CountRepetitions.java:// 统计重复个数
class129/Code03_CountRepetitions.java:// 如果字符串x删除一些字符，可以得到字符串y，那么就说y可以从x中获得
class129/Code03_CountRepetitions.java:// 给定s1和a，代表s1拼接a次，记为字符串x
class129/Code03_CountRepetitions.java:// 给定s2和b，代表s2拼接b次，记为字符串y
class129/Code03_CountRepetitions.java:// 现在把y拼接m次之后，得到的字符串依然可能从x中获得，返回尽可能大的m
class129/Code03_CountRepetitions.java:// s1、s2只由小写字母组成
class129/Code03_CountRepetitions.java:// 1 <= s1长度、s2长度 <= 100
class129/Code03_CountRepetitions.java:// 1 <= a、b <= 10^6
class129/Code03_CountRepetitions.java:// 测试链接 : https://leetcode.cn/problems/count-the-repetitions/
class129/Code04_FindNear.java:// 寻找最近和次近
class129/Code04_FindNear.java:// 给定一个长度为n的数组arr，下标1 ~ n范围，数组无重复值
class129/Code04_FindNear.java:// 关于近的定义，距离的定义如下:
class129/Code04_FindNear.java:// 对i位置的数字x来说，只关注右侧的数字，和x的差值绝对值越小就越近
class129/Code04_FindNear.java:// 距离为差值绝对值，如果距离一样，数值越小的越近
class129/Code04_FindNear.java:// 数值 : 3 5 7 1
class129/Code04_FindNear.java:// 下标 : 1 2 3 4
class129/Code04_FindNear.java:// 对1位置的数字3来说，第一近是4位置的1，距离为2；第二近是2位置的5，距离为2
class129/Code04_FindNear.java:// 每个位置的数字都求第一近的位置及其距离、第二近的位置及其距离
class129/Code04_FindNear.java:// 分别用to1、dist1、to2、dist2数组表示，0表示不存在
class129/Code04_FindNear.java:// 有序表的实现 + 数组手搓双向链表的实现
class129/Code04_FindNear.java:// 对数器验证
class129/Code05_RoadTrip.java:// 开车旅行
class129/Code05_RoadTrip.java:// 给定一个长度为n的数组arr，下标1 ~ n范围，数组无重复值
class129/Code05_RoadTrip.java:// 近的定义、距离的定义，和题目4一致
class129/Code05_RoadTrip.java:// a和b同坐一辆车开始往右旅行，a先开车，b后开车，此后每到达一点都换人驾驶
class129/Code05_RoadTrip.java:// 如果a在某点驾驶，那么车去往该点右侧第二近的点，如果b在某点驾驶，那么车去往该点右侧第一近的点
class129/Code05_RoadTrip.java:// a和b从s位置出发，如果开车总距离超过x，或轮到某人时右侧无点可选，那么旅行停止
class129/Code05_RoadTrip.java:// 问题1 : 给定距离x0，返回1 ~ n-1中从哪个点出发，a行驶距离 / b行驶距离，比值最小
class129/Code05_RoadTrip.java://         如果从多个点出发时，比值都为最小，那么返回arr中的值最大的点
class129/Code05_RoadTrip.java:// 问题2 : 给定s、x，返回旅行停止时，a开了多少距离、b开了多少距离
class129/Code05_RoadTrip.java:// 问题1只调用1次
class129/Code05_RoadTrip.java:// 问题2调用m次，每组有不同的s、x
class129/Code05_RoadTrip.java:// 1 <= n、m、s <= 10^5
class129/Code05_RoadTrip.java:// -10^9 <= arr[i] <= 10^9
class129/Code05_RoadTrip.java:// 1 <= x0、x <= 10^9
class129/Code05_RoadTrip.java:// 测试链接 : https://www.luogu.com.cn/problem/P1081
class129/Code05_RoadTrip.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
算法讲解130【扩展】动态规划优化专题4-单调队列和单调栈优化
class130/Code01_JumpRight.java:// 向右跳跃获得最大得分
class130/Code01_JumpRight.java:// 给定长度为n+1的数组arr，下标编号0 ~ n，给定正数a、b
class130/Code01_JumpRight.java:// 一开始在0位置，每次可以选择[a,b]之间的一个整数，作为向右跳跃的距离
class130/Code01_JumpRight.java:// 每来到一个位置i，可以获得arr[i]作为得分，位置一旦大于n就停止
class130/Code01_JumpRight.java:// 返回能获得的最大得分
class130/Code01_JumpRight.java:// 1 <= n <= 2 * 10^5
class130/Code01_JumpRight.java:// 1 <= a <= b <= n
class130/Code01_JumpRight.java:// -1000 <= arr[i] <= +1000
class130/Code01_JumpRight.java:// 测试链接 : https://www.luogu.com.cn/problem/P1725
class130/Code01_JumpRight.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class130/Code02_CollectDown.java:// 向下收集获得最大能量
class130/Code02_CollectDown.java:// 有一个n * m的区域，行和列的编号从1开始
class130/Code02_CollectDown.java:// 每个能量点用(i, j, v)表示，i行j列上有价值为v的能量点
class130/Code02_CollectDown.java:// 一共有k个能量点，并且所有能量点一定在不同的位置
class130/Code02_CollectDown.java:// 一开始可以在第1行的任意位置，然后每一步必须向下移动
class130/Code02_CollectDown.java:// 向下去往哪个格子是一个范围，如果当前在(i, j)位置
class130/Code02_CollectDown.java:// 那么往下可以选择(i+1, j-t)...(i+1, j+t)其中的一个格子
class130/Code02_CollectDown.java:// 到达最后一行时，收集过程停止，返回能收集到的最大能量价值
class130/Code02_CollectDown.java:// 1 <= n、m、k、t <= 4000
class130/Code02_CollectDown.java:// 1 <= v <= 100
class130/Code02_CollectDown.java:// 测试链接 : https://www.luogu.com.cn/problem/P3800
class130/Code02_CollectDown.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class130/Code03_ChooseLimitMaximumSum.java:// 不超过连续k个元素的最大累加和
class130/Code03_ChooseLimitMaximumSum.java:// 给定一个长度为n的数组arr，你可以随意选择数字
class130/Code03_ChooseLimitMaximumSum.java:// 要求选择的方案中，连续选择的个数不能超过k个
class130/Code03_ChooseLimitMaximumSum.java:// 返回能得到的最大累加和
class130/Code03_ChooseLimitMaximumSum.java:// 1 <= n、k <= 10^5
class130/Code03_ChooseLimitMaximumSum.java:// 0 <= arr[i] <= 10^9
class130/Code03_ChooseLimitMaximumSum.java:// 测试链接 : https://www.luogu.com.cn/problem/P2627
class130/Code03_ChooseLimitMaximumSum.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class130/Code04_PaintingMaximumScore.java:// 粉刷木板的最大收益
class130/Code04_PaintingMaximumScore.java:// 一共有n个木板，每个木板长度为1，最多粉刷一次，也可以不刷
class130/Code04_PaintingMaximumScore.java:// 一共有m个工人，每个工人用(li, pi, si)表示：
class130/Code04_PaintingMaximumScore.java:// 该工人必须刷连续区域的木板，并且连续的长度不超过li
class130/Code04_PaintingMaximumScore.java:// 该工人每刷一块木板可以得到pi的钱
class130/Code04_PaintingMaximumScore.java:// 该工人刷的连续区域必须包含si位置的木板
class130/Code04_PaintingMaximumScore.java:// 返回所有工人最多能获得多少钱
class130/Code04_PaintingMaximumScore.java:// 1 <= n <= 16000
class130/Code04_PaintingMaximumScore.java:// 1 <= m <= 100
class130/Code04_PaintingMaximumScore.java:// 1 <= pi <= 10000
class130/Code04_PaintingMaximumScore.java:// 测试链接 : http://poj.org/problem?id=1821
class130/Code04_PaintingMaximumScore.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class130/Code05_MinimumTotalDistanceTraveled.java:// 最小移动总距离
class130/Code05_MinimumTotalDistanceTraveled.java:// 所有工厂和机器人都分布在x轴上
class130/Code05_MinimumTotalDistanceTraveled.java:// 给定长度为n的二维数组factory，factory[i][0]为i号工厂的位置，factory[i][1]为容量
class130/Code05_MinimumTotalDistanceTraveled.java:// 给定长度为m的一维数组robot，robot[j]为第j个机器人的位置
class130/Code05_MinimumTotalDistanceTraveled.java:// 每个工厂所在的位置都不同，每个机器人所在的位置都不同，机器人到工厂的距离为位置差的绝对值
class130/Code05_MinimumTotalDistanceTraveled.java:// 所有机器人都是坏的，但是机器人可以去往任何工厂进行修理，但是不能超过某个工厂的容量
class130/Code05_MinimumTotalDistanceTraveled.java:// 测试数据保证所有机器人都可以被维修，返回所有机器人移动的最小总距离
class130/Code05_MinimumTotalDistanceTraveled.java:// 1 <= n、m <= 100
class130/Code05_MinimumTotalDistanceTraveled.java:// -10^9 <= factory[i][0]、robot[j] <= +10^9
class130/Code05_MinimumTotalDistanceTraveled.java:// 0 <= factory[i][1] <= m
class130/Code05_MinimumTotalDistanceTraveled.java:// 测试链接 : https://leetcode.cn/problems/minimum-total-distance-traveled/
class130/Code06_SumOfTotalStrength.java:// 巫师力量和
class130/Code06_SumOfTotalStrength.java:// 题目可以简化为如下的描述
class130/Code06_SumOfTotalStrength.java:// 给定一个长度为n的数组arr，下标从0开始
class130/Code06_SumOfTotalStrength.java:// 任何一个子数组的指标为，子数组累加和 * 子数组中最小值
class130/Code06_SumOfTotalStrength.java:// 返回arr中所有子数组指标的累加和，答案对1000000007取余
class130/Code06_SumOfTotalStrength.java:// 1 <= n <= 10^5
class130/Code06_SumOfTotalStrength.java:// 1 <= arr[i] <= 10^9
class130/Code06_SumOfTotalStrength.java:// 测试链接 : https://leetcode.cn/problems/sum-of-total-strength-of-wizards/
class130/Code07_MaximumOrderSum.java:// 子数组最大变序和
class130/Code07_MaximumOrderSum.java:// 给定一个长度为n的数组arr，变序和定义如下
class130/Code07_MaximumOrderSum.java:// 数组中每个值都可以减小或者不变，必须把整体变成严格升序的
class130/Code07_MaximumOrderSum.java:// 所有方案中，能得到的最大累加和，叫做数组的变序和
class130/Code07_MaximumOrderSum.java:// 比如[1,100,7]，变序和14，方案为变成[1,6,7]
class130/Code07_MaximumOrderSum.java:// 比如[5,4,9]，变序和16，方案为变成[3,4,9]
class130/Code07_MaximumOrderSum.java:// 比如[1,4,2]，变序和3，方案为变成[0,1,2]
class130/Code07_MaximumOrderSum.java:// 返回arr所有子数组的变序和中，最大的那个
class130/Code07_MaximumOrderSum.java:// 1 <= n、arr[i] <= 10^6
class130/Code07_MaximumOrderSum.java:// 来自真实大厂笔试，对数器验证
class130/Code08_DeliveringBoxes.java:// 送箱子到码头的最少行程数
class130/Code08_DeliveringBoxes.java:// 一共有m个码头，编号1 ~ m， 给定长度为n的二维数组boxes
class130/Code08_DeliveringBoxes.java:// boxes[i][0]表示i号箱子要送往的码头，boxes[i][1]表示i号箱子重量
class130/Code08_DeliveringBoxes.java:// 有一辆马车，一次最多能装a个箱子并且箱子总重量不能超过b
class130/Code08_DeliveringBoxes.java:// 马车一开始在仓库，可以在0位置，马车每开动一次，认为行程+1
class130/Code08_DeliveringBoxes.java:// 箱子必须按照boxes规定的顺序被放上马车，也必须按照顺序被送往各自的码头
class130/Code08_DeliveringBoxes.java:// 马车上相邻的箱子如果去往同一个码头，那么认为共享同一趟行程
class130/Code08_DeliveringBoxes.java:// 马车可能经过多次送货，每次装货需要回到仓库，认为行程+1，送完所有的货，最终要回到仓库，行程+1
class130/Code08_DeliveringBoxes.java:// 返回至少需要几个行程能把所有的货都送完
class130/Code08_DeliveringBoxes.java:// 所有数据的范围 <= 10^5
class130/Code08_DeliveringBoxes.java:// 测试链接 : https://leetcode.cn/problems/delivering-boxes-from-storage-to-ports/
算法讲解131【扩展】动态规划优化专题5-树状数组和线段树优化
class131/Code01_CountOfRangeSum1.java:// 达标子数组的个数
class131/Code01_CountOfRangeSum1.java:// 给定一个长度为n的数组nums，给定两个整数lower和upper
class131/Code01_CountOfRangeSum1.java:// 子数组达标的条件是累加和在[lower, upper]范围上
class131/Code01_CountOfRangeSum1.java:// 返回nums中有多少个达标子数组
class131/Code01_CountOfRangeSum1.java:// 1 <= n <= 10^5
class131/Code01_CountOfRangeSum1.java:// nums[i]可能是任意整数
class131/Code01_CountOfRangeSum1.java:// -10^5 <= lower <= upper <= +10^5
class131/Code01_CountOfRangeSum1.java:// 测试链接 : https://leetcode.cn/problems/count-of-range-sum/
class131/Code01_CountOfRangeSum2.java:// 达标子数组的个数
class131/Code01_CountOfRangeSum2.java:// 给定一个长度为n的数组nums，给定两个整数lower和upper
class131/Code01_CountOfRangeSum2.java:// 子数组达标的条件是累加和在[lower, upper]范围上
class131/Code01_CountOfRangeSum2.java:// 返回nums中有多少个达标子数组
class131/Code01_CountOfRangeSum2.java:// 1 <= n <= 10^5
class131/Code01_CountOfRangeSum2.java:// nums[i]可能是任意整数
class131/Code01_CountOfRangeSum2.java:// -10^5 <= lower <= upper <= +10^5
class131/Code01_CountOfRangeSum2.java:// 测试链接 : https://leetcode.cn/problems/count-of-range-sum/
class131/Code02_MaximumBalancedSubsequence.java:// 平衡子序列的最大和
class131/Code02_MaximumBalancedSubsequence.java:// 给定一个长度为n的数组nums，下面定义平衡子序列
class131/Code02_MaximumBalancedSubsequence.java:// 如果下标i和下标j被选进了子序列，i在j的左边
class131/Code02_MaximumBalancedSubsequence.java:// 那么必须有nums[j] - nums[i] >= j - i
class131/Code02_MaximumBalancedSubsequence.java:// 如果一个子序列中任意的两个下标都满足上面的要求，那子序列就是平衡的
class131/Code02_MaximumBalancedSubsequence.java:// 返回nums所有平衡子序列里，最大的累加和是多少
class131/Code02_MaximumBalancedSubsequence.java:// 1 <= n <= 10^5
class131/Code02_MaximumBalancedSubsequence.java:// -10^9 <= nums[i] <= +10^9
class131/Code02_MaximumBalancedSubsequence.java:// 测试链接 : https://leetcode.cn/problems/maximum-balanced-subsequence-sum/
class131/Code03_CornField.java:// 方伯伯的玉米田
class131/Code03_CornField.java:// 给定一个长度为n的数组arr
class131/Code03_CornField.java:// 每次可以选择一个区间[l,r]，区间内的数字都+1，最多执行k次
class131/Code03_CornField.java:// 返回执行完成后，最长的不下降子序列长度
class131/Code03_CornField.java:// 1 <= n <= 10^4
class131/Code03_CornField.java:// 1 <= arr[i] <= 5000
class131/Code03_CornField.java:// 2 <= k <= 500
class131/Code03_CornField.java:// 测试链接 : https://www.luogu.com.cn/problem/P3287
class131/Code03_CornField.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class131/Code04_LongestIdealString.java:// 最长理想子序列
class131/Code04_LongestIdealString.java:// 给定一个长度为n，只由小写字母组成的字符串s，给定一个非负整数k
class131/Code04_LongestIdealString.java:// 字符串s可以生成很多子序列，下面给出理想子序列的定义
class131/Code04_LongestIdealString.java:// 子序列中任意相邻的两个字符，在字母表中位次的差值绝对值<=k
class131/Code04_LongestIdealString.java:// 返回最长理想子序列
class131/Code04_LongestIdealString.java:// 1 <= n <= 10^5
class131/Code04_LongestIdealString.java:// 0 <= k <= 25
class131/Code04_LongestIdealString.java:// s只由小写字母组成
class131/Code04_LongestIdealString.java:// 测试链接 : https://leetcode.cn/problems/longest-ideal-subsequence/
class131/Code05_TheBakery.java:// 划分k段的最大得分
class131/Code05_TheBakery.java:// 给定一个长度为n的数组，最多可以分成k段不重合的子数组
class131/Code05_TheBakery.java:// 每个子数组获得的分值为内部不同数字的个数
class131/Code05_TheBakery.java:// 返回能获得的最大分值
class131/Code05_TheBakery.java:// 1 <= n <= 35000
class131/Code05_TheBakery.java:// 1 <= k <= 50
class131/Code05_TheBakery.java:// k <= n
class131/Code05_TheBakery.java:// 1 <= arr[i] <= n
class131/Code05_TheBakery.java:// 测试链接 : https://www.luogu.com.cn/problem/CF833B
class131/Code05_TheBakery.java:// 测试链接 : https://codeforces.com/problemset/problem/833/B
class131/Code05_TheBakery.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
class131/Code06_StationLocation.java:// 基站选址
class131/Code06_StationLocation.java:// 一共有n个村庄排成一排，从左往右依次出现1号、2号、3号..n号村庄
class131/Code06_StationLocation.java:// dist[i]表示i号村庄到1号村庄的距离，该数组一定有序且无重复值
class131/Code06_StationLocation.java:// fix[i]表示i号村庄建立基站的安装费用
class131/Code06_StationLocation.java:// range[i]表示i号村庄的接收范围，任何基站和i号村庄的距离不超过这个数字，i号村庄就能得到服务
class131/Code06_StationLocation.java:// warranty[i]表示如果i号村庄最终没有得到任何基站的服务，需要给多少赔偿费用
class131/Code06_StationLocation.java:// 最多可以选择k个村庄安装基站，返回总花费最少是多少，总花费包括安装费用和赔偿费用
class131/Code06_StationLocation.java:// 1 <= n <= 20000
class131/Code06_StationLocation.java:// 1 <= k <= 100
class131/Code06_StationLocation.java:// k <= n
class131/Code06_StationLocation.java:// 1 <= dist[i] <= 10^9
class131/Code06_StationLocation.java:// 1 <= fix[i] <= 10^4
class131/Code06_StationLocation.java:// 1 <= range[i] <= 10^9
class131/Code06_StationLocation.java:// 1 <= warranty[i] <= 10^4
class131/Code06_StationLocation.java:// 测试链接 : https://www.luogu.com.cn/problem/P2605
class131/Code06_StationLocation.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例
算法讲解132【扩展】动态规划优化专题6-预处理数组优化
class132/Code01_MeetingRestK.java:// 休息k分钟最大会议和
class132/Code01_MeetingRestK.java:// 给定一个长度为n的数组arr，表示从早到晚发生的会议，各自召开的分钟数
class132/Code01_MeetingRestK.java:// 当选择一个会议并参加之后，必须休息k分钟
class132/Code01_MeetingRestK.java:// 返回能参加的会议时长最大累加和
class132/Code01_MeetingRestK.java:// 比如，arr = { 200, 5, 6, 14, 7, 300 }，k = 15
class132/Code01_MeetingRestK.java:// 最好的选择为，选择200分钟的会议，然后必须休息15分钟
class132/Code01_MeetingRestK.java:// 那么接下来的5分钟、6分钟、14分钟的会议注定错过
class132/Code01_MeetingRestK.java:// 然后放弃7分钟的会议，而选择参加300分钟的会议
class132/Code01_MeetingRestK.java:// 最终返回500
class132/Code01_MeetingRestK.java:// 1 <= n、arr[i]、k <= 10^6
class132/Code01_MeetingRestK.java:// 来自真实大厂笔试，对数器验证
class132/Code02_SoldierPosition1.java:// 炮兵阵地
class132/Code02_SoldierPosition1.java:// 给定一个n * m的二维数组grid，其中的1代表可以摆放炮兵，0代表不可以摆放
class132/Code02_SoldierPosition1.java:// 任何炮兵攻击范围是一个"十字型"的区域，具体是上下左右两个格子的区域
class132/Code02_SoldierPosition1.java:// 你的目的是在gird里摆尽量多的炮兵，但要保证任何两个炮兵之间无法互相攻击
class132/Code02_SoldierPosition1.java:// 返回最多能摆几个炮兵
class132/Code02_SoldierPosition1.java:// 1 <= n <= 100
class132/Code02_SoldierPosition1.java:// 1 <= m <= 10
class132/Code02_SoldierPosition1.java:// 0 <= grid[i][j] <= 1
class132/Code02_SoldierPosition1.java:// 测试链接 : https://www.luogu.com.cn/problem/P2704
class132/Code02_SoldierPosition1.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class132/Code02_SoldierPosition1.java://	// 打印num第m-1位到第0位的二进制状态
class132/Code02_SoldierPosition1.java://	public static void printBinary(int num) {
class132/Code02_SoldierPosition1.java://		for (int i = m - 1; i >= 0; i--) {
class132/Code02_SoldierPosition1.java://			System.out.print((num & (1 << i)) == 0 ? "0" : "1");
class132/Code02_SoldierPosition1.java://		}
class132/Code02_SoldierPosition1.java://		System.out.println();
class132/Code02_SoldierPosition1.java://	}
class132/Code02_SoldierPosition1.java://		m = 10;
class132/Code02_SoldierPosition1.java://		k = 0;
class132/Code02_SoldierPosition1.java://		prepare(0, 0);
class132/Code02_SoldierPosition1.java://		for (int i = 0; i < k; i++) {
class132/Code02_SoldierPosition1.java://			printBinary(sta[i]);
class132/Code02_SoldierPosition1.java://		}
class132/Code02_SoldierPosition1.java://		System.out.println("有效状态数量 : " + k);
class132/Code02_SoldierPosition2.java:// 炮兵阵地(空间压缩优化)
class132/Code02_SoldierPosition2.java:// 给定一个n * m的二维数组grid，其中的1代表可以摆放炮兵，0代表不可以摆放
class132/Code02_SoldierPosition2.java:// 任何炮兵攻击范围是一个"十字型"的区域，具体是上下左右两个格子的区域
class132/Code02_SoldierPosition2.java:// 你的目的是在gird里摆尽量多的炮兵，但要保证任何两个炮兵之间无法互相攻击
class132/Code02_SoldierPosition2.java:// 返回最多能摆几个炮兵
class132/Code02_SoldierPosition2.java:// 1 <= n <= 100
class132/Code02_SoldierPosition2.java:// 1 <= m <= 10
class132/Code02_SoldierPosition2.java:// 0 <= grid[i][j] <= 1
class132/Code02_SoldierPosition2.java:// 测试链接 : https://www.luogu.com.cn/problem/P2704
class132/Code02_SoldierPosition2.java:// 测试链接 : http://poj.org/problem?id=1185
class132/Code02_SoldierPosition2.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class132/Code03_WaysOfRevert1.java:// 还原数组的方法数(不优化枚举)
class132/Code03_WaysOfRevert1.java:// 原本有一个长度为n的数组arr，下标从1开始，数组中都是<=200的正数
class132/Code03_WaysOfRevert1.java:// 并且任意i位置的数字都满足 : arr[i] <= max(arr[i-1], arr[i+1])
class132/Code03_WaysOfRevert1.java:// 特别的，arr[1] <= arr[2]，arr[n] <= arr[n-1]
class132/Code03_WaysOfRevert1.java:// 但是输入的arr中有些数字丢失了，丢失的数字用0表示
class132/Code03_WaysOfRevert1.java:// 返回还原成不违规的arr有多少种方法，答案很大需要对998244353取余
class132/Code03_WaysOfRevert1.java:// 3 <= n <= 10^4
class132/Code03_WaysOfRevert1.java:// 测试链接 : https://www.nowcoder.com/practice/49c5284278974cbda474ec13d8bd86a9
class132/Code03_WaysOfRevert1.java:// 提交以下的code，提交时请把类名改成"Main"，无法通过所有测试用例
class132/Code03_WaysOfRevert1.java:// 需要优化枚举才能通过所有测试用例，具体看本节课Code03_WaysOfRevert2文件的实现
class132/Code03_WaysOfRevert2.java:// 还原数组的方法数(优化枚举)
class132/Code03_WaysOfRevert2.java:// 原本有一个长度为n的数组arr，下标从1开始，数组中都是<=200的正数
class132/Code03_WaysOfRevert2.java:// 并且任意i位置的数字都满足 : arr[i] <= max(arr[i-1], arr[i+1])
class132/Code03_WaysOfRevert2.java:// 特别的，arr[1] <= arr[2]，arr[n] <= arr[n-1]
class132/Code03_WaysOfRevert2.java:// 但是输入的arr中有些数字丢失了，丢失的数字用0表示
class132/Code03_WaysOfRevert2.java:// 返回还原成不违规的arr有多少种方法，答案很大需要对998244353取余
class132/Code03_WaysOfRevert2.java:// 3 <= n <= 10^4
class132/Code03_WaysOfRevert2.java:// 测试链接 : https://www.nowcoder.com/practice/49c5284278974cbda474ec13d8bd86a9
class132/Code03_WaysOfRevert2.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class132/Code04_PaintHouseIII.java:// 粉刷房子III
class132/Code04_PaintHouseIII.java:// 房子有n个，从左到右排列，编号1..n，颜色有c种，编号1..c
class132/Code04_PaintHouseIII.java:// 给定数组house，house[i]表示房子的颜色，如果house[i]为0说明房子没有涂色
class132/Code04_PaintHouseIII.java:// 你必须给每个没有涂色的房子涂上颜色，如果有颜色的房子不能改变颜色
class132/Code04_PaintHouseIII.java:// 给定二维数组cost，cost[i][v]表示如果i号房涂成v号颜色，需要花费多少钱
class132/Code04_PaintHouseIII.java:// 相邻的、拥有同一种颜色的房子为1个街区
class132/Code04_PaintHouseIII.java:// 比如如果所有房子的颜色为: {1, 1, 2, 3, 2, 2}，那么一共4个街区
class132/Code04_PaintHouseIII.java:// 最终所有的房子涂完颜色，一定要形成t个街区，返回最少的花费
class132/Code04_PaintHouseIII.java:// 1 <= t <= n <= 100
class132/Code04_PaintHouseIII.java:// 1 <= c <= 20
class132/Code04_PaintHouseIII.java:// 0 <= house[i] <= c
class132/Code04_PaintHouseIII.java:// 1 <= cost[i][v] <= 10^4
class132/Code04_PaintHouseIII.java:// 测试链接 : https://leetcode.cn/problems/paint-house-iii/
class132/Code05_DiggingBricks1.java:// 从上到下挖砖块(展示动态规划思路，不优化枚举，不进行空间压缩)
class132/Code05_DiggingBricks1.java:// 一堆组成倒三角形状的砖埋在地里，一共有n层，第1层有n块砖，每层递减，类似如下数据
class132/Code05_DiggingBricks1.java:// 4 2 9 5
class132/Code05_DiggingBricks1.java://  3 1 7
class132/Code05_DiggingBricks1.java://   2 4
class132/Code05_DiggingBricks1.java://    8
class132/Code05_DiggingBricks1.java:// 需要从第1层开始挖，每挖开一块砖都可以获得数值作为收益，第1层的砖可以随意挖
class132/Code05_DiggingBricks1.java:// 但是挖到下面的砖是有条件的，想挖i层的j号砖，你需要确保i-1层的(j、j+1)块砖已经被挖开
class132/Code05_DiggingBricks1.java:// 最多可以挖m块砖，返回最大的收益
class132/Code05_DiggingBricks1.java:// 1 <= n <= 50
class132/Code05_DiggingBricks1.java:// 1 <= m <= 1300
class132/Code05_DiggingBricks1.java:// 砖块数值 <= 100
class132/Code05_DiggingBricks1.java:// 测试链接 : https://www.luogu.com.cn/problem/P1437
class132/Code05_DiggingBricks1.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class132/Code05_DiggingBricks2.java:// 从上到下挖砖块(优化枚举+空间压缩)
class132/Code05_DiggingBricks2.java:// 一堆组成倒三角形状的砖埋在地里，一共有n层，第1层有n块砖，每层递减，类似如下数据
class132/Code05_DiggingBricks2.java:// 4 2 9 5
class132/Code05_DiggingBricks2.java://  3 1 7
class132/Code05_DiggingBricks2.java://   2 4
class132/Code05_DiggingBricks2.java://    8
class132/Code05_DiggingBricks2.java:// 需要从第1层开始挖，每挖开一块砖都可以获得数值作为收益，第1层的砖可以随意挖
class132/Code05_DiggingBricks2.java:// 但是挖到下面的砖是有条件的，想挖i层的j号砖，你需要确保i-1层的(j、j+1)块砖已经被挖开
class132/Code05_DiggingBricks2.java:// 最多可以挖m块砖，返回最大的收益
class132/Code05_DiggingBricks2.java:// 1 <= n <= 50
class132/Code05_DiggingBricks2.java:// 1 <= m <= 1300
class132/Code05_DiggingBricks2.java:// 砖块数值 <= 100
class132/Code05_DiggingBricks2.java:// 测试链接 : https://www.luogu.com.cn/problem/P1437
class132/Code05_DiggingBricks2.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
算法讲解133【扩展】高斯消元专题1-解决加法方程组
class133/Code01_GaussAdd.java:// 高斯消元解决加法方程组模版(区分是否有唯一解)
class133/Code01_GaussAdd.java:// 一共有n个变量，给定n个加法方程，构成一个加法方程组
class133/Code01_GaussAdd.java:// 如果方程组存在矛盾或者无法确定唯一解，打印"No Solution"
class133/Code01_GaussAdd.java:// 如果方程组存在唯一解，打印每个变量的值，保留小数点后两位
class133/Code01_GaussAdd.java:// 1 <= n <= 100
class133/Code01_GaussAdd.java:// 测试链接 : https://www.luogu.com.cn/problem/P3389
class133/Code01_GaussAdd.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class133/Code02_GaussAdd.java:// 高斯消元解决加法方程组模版(区分矛盾、多解、唯一解)
class133/Code02_GaussAdd.java:// 一共有n个变量，给定n个加法方程，构成一个加法方程组
class133/Code02_GaussAdd.java:// 如果方程组存在矛盾，打印-1
class133/Code02_GaussAdd.java:// 如果方程组无法确定唯一解，打印0
class133/Code02_GaussAdd.java:// 如果方程组存在唯一解，打印每个变量的值，保留小数点后两位
class133/Code02_GaussAdd.java:// 1 <= n <= 50
class133/Code02_GaussAdd.java:// 测试链接 : https://www.luogu.com.cn/problem/P2455
class133/Code02_GaussAdd.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class133/Code03_SphereCenter.java:// 球形空间的中心点
class133/Code03_SphereCenter.java:// 如果在n维空间中，那么表达一个点的位置，需要n个坐标的值
class133/Code03_SphereCenter.java:// 现在给定n+1个点，每个点都有n个坐标的值，代表在n维空间中的位置
class133/Code03_SphereCenter.java:// 假设这n+1个点都在n维空间的球面上，请返回球心的位置
class133/Code03_SphereCenter.java:// 球心的位置当然也是n个坐标的值，打印出来
class133/Code03_SphereCenter.java:// 在n维空间中，计算任意两点的距离，请用经典的欧式距离
class133/Code03_SphereCenter.java:// 1 <= n <= 10
class133/Code03_SphereCenter.java:// 坐标信息精确到小数点后6位，绝对值都不超过20000
class133/Code03_SphereCenter.java:// 测试链接 : https://www.luogu.com.cn/problem/P4035
class133/Code03_SphereCenter.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class133/Code04_FindMaxWeighing.java:// 有一次错误称重求最重物品
class133/Code04_FindMaxWeighing.java:// 一共有n个物品，编号1~n，定义合法方案如下：
class133/Code04_FindMaxWeighing.java:// 1，每个物品的重量都是确定的
class133/Code04_FindMaxWeighing.java:// 2，每个物品的重量一定都是正整数
class133/Code04_FindMaxWeighing.java:// 3，最重的物品有且仅有1个
class133/Code04_FindMaxWeighing.java:// 每次称重格式类似：3 2 5 6 10，代表本次称重涉3个物品，编号为2、5、6，总重量10
class133/Code04_FindMaxWeighing.java:// 一共有n+1条称重数据，称重数据整体有效的条件为：
class133/Code04_FindMaxWeighing.java:// 错误的称重数据有且仅有1条，只有排除这条错误称重，才能求出一种合法方案
class133/Code04_FindMaxWeighing.java:// 如果称重数据有效，打印最重三角形的编号
class133/Code04_FindMaxWeighing.java:// 如果称重数据无效，打印"illegal"
class133/Code04_FindMaxWeighing.java:// 1 <= m <= n <= 100
class133/Code04_FindMaxWeighing.java:// 测试链接 : https://www.luogu.com.cn/problem/P5027
class133/Code04_FindMaxWeighing.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class133/ShowDetails.java:// 课上讲述高斯消元解决加法方程组的例子
算法讲解134【扩展】高斯消元专题2-解决异或方程组
class134/Code01_GaussEor.java:// 高斯消元解决异或方程组模版题
class134/Code01_GaussEor.java:// 有一个长度为n的数组arr，可能有重复值，数字都是long类型的正数
class134/Code01_GaussEor.java:// 每个数拥有的质数因子一定不超过2000，每个数最多挑选一次
class134/Code01_GaussEor.java:// 在至少要选一个数的情况下，你可以随意挑选数字乘起来
class134/Code01_GaussEor.java:// 乘得的结果需要是完全平方数，请问有几种挑选数字的方法
class134/Code01_GaussEor.java:// 方法数可能很大，结果对1000000007取余
class134/Code01_GaussEor.java:// 1 <= n <= 300
class134/Code01_GaussEor.java:// 1 <= arr[i] <= 10^18
class134/Code01_GaussEor.java:// 测试链接 : https://acm.hdu.edu.cn/showproblem.php?pid=5833
class134/Code01_GaussEor.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class134/Code02_MinimumOperations.java:// 全变成1的最少操作次数
class134/Code02_MinimumOperations.java:// 一共有n个点，m条无向边，每个点的初始状态都是0
class134/Code02_MinimumOperations.java:// 可以操作任意一个点，操作后该点以及相邻点的状态都会改变
class134/Code02_MinimumOperations.java:// 最终是希望所有点都变成1状态，那么可能会若干方案都可以做到
class134/Code02_MinimumOperations.java:// 那么其中存在需要最少操作次数的方案，打印这个最少操作次数
class134/Code02_MinimumOperations.java:// 题目保证一定能做到所有点都变成1状态，并且没有重边和自环
class134/Code02_MinimumOperations.java:// 1 <= n <= 35
class134/Code02_MinimumOperations.java:// 1 <= m <= 595
class134/Code02_MinimumOperations.java:// 测试链接 : https://www.luogu.com.cn/problem/P2962
class134/Code02_MinimumOperations.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class134/Code03_AlienInsectLegs.java:// 外星千足虫
class134/Code03_AlienInsectLegs.java:// 一共有n种虫子，编号1~n，虫子腿为奇数认为是外星虫，偶数认为是地球虫
class134/Code03_AlienInsectLegs.java:// 一共有m条虫子腿的测量记录，记录编号1~m
class134/Code03_AlienInsectLegs.java:// 比如其中一条测量记录为，011 1，表示1号虫没参与，2号、3号虫参与了，总腿数为奇数
class134/Code03_AlienInsectLegs.java:// 测量记录保证不会有自相矛盾的情况，但是可能有冗余的测量结果
class134/Code03_AlienInsectLegs.java:// 也许拥有从第1号到第k号测量记录就够了，k+1~m号测量记录有或者没有都不影响测量结果
class134/Code03_AlienInsectLegs.java:// 打印这个k，并且打印每种虫子到底是外星虫还是地球虫
class134/Code03_AlienInsectLegs.java:// 如果使用所有的测量结果，依然无法确定每种虫子的属性，打印"Cannot Determine"
class134/Code03_AlienInsectLegs.java:// 1 <= n <= 1000
class134/Code03_AlienInsectLegs.java:// 1 <= m <= 2000
class134/Code03_AlienInsectLegs.java:// 测试链接 : https://www.luogu.com.cn/problem/P2447
class134/Code03_AlienInsectLegs.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class134/ShowDetails.java:// 课上讲述高斯消元解决异或方程组的例子
算法讲解135【扩展】高斯消元专题3-解决同余方程组
class135/Code01_GamblerBo.java:// 格子全变成0的操作方案
class135/Code01_GamblerBo.java:// 有一个n*m的二维网格，给定每个网格的初始值，一定是0、1、2中的一个
class135/Code01_GamblerBo.java:// 如果某个网格获得了一些数值加成，也会用%3的方式变成0、1、2中的一个
class135/Code01_GamblerBo.java:// 比如有个网格一开始值是1，获得4的加成之后，值为(1+4)%3 = 2
class135/Code01_GamblerBo.java:// 有一个神奇的刷子，一旦在某个网格处刷一下，该网格会获得2的加成
class135/Code01_GamblerBo.java:// 并且该网格上、下、左、右的格子，都会获得1的加成
class135/Code01_GamblerBo.java:// 最终目标是所有网格都变成0，题目保证一定有解，但不保证唯一解
class135/Code01_GamblerBo.java:// 得到哪一种方案都可以，打印一共需要刷几下，并且把操作方案打印出来
class135/Code01_GamblerBo.java:// 1 <= n、m <= 30
class135/Code01_GamblerBo.java:// 测试链接 : https://acm.hdu.edu.cn/showproblem.php?pid=5755
class135/Code01_GamblerBo.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class135/Code02_WidgetFactory.java:// 工具工厂
class135/Code02_WidgetFactory.java:// 一共有n种工具，编号1~n，一共有m条记录，其中一条记录格式如下：
class135/Code02_WidgetFactory.java:// 4 WED SUN 13 18 1 13
class135/Code02_WidgetFactory.java:// 表示有个工人一共加工了4件工具，从某个星期三开始工作，到某个星期天结束工作
class135/Code02_WidgetFactory.java:// 加工的工具依次为13号、18号、1号、13号
class135/Code02_WidgetFactory.java:// 每个工人在工作期间不休息，每件工具都是串行加工的，完成一件后才开始下一件
class135/Code02_WidgetFactory.java:// 每种工具制作天数是固定的，并且任何工具的制作天数最少3天、最多9天
class135/Code02_WidgetFactory.java:// 但该数据丢失了，所以现在需要根据记录，推断出每种工具的制作天数
class135/Code02_WidgetFactory.java:// 如果记录之间存在矛盾，打印"Inconsistent data."
class135/Code02_WidgetFactory.java:// 如果记录无法确定每种工具的制作天数，打印"Multiple solutions."
class135/Code02_WidgetFactory.java:// 如果记录能够确定每种工具的制作天数，打印所有结果
class135/Code02_WidgetFactory.java:// 1 <= n、m <= 300
class135/Code02_WidgetFactory.java:// 测试链接 : http://poj.org/problem?id=2947
class135/Code02_WidgetFactory.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class135/ShowDetails.java:// 课上讲述高斯消元解决同余方程组的例子
算法讲解136【扩展】线性基-上
class136/Code01_MaximumXor.java:// 最大异或和
class136/Code01_MaximumXor.java:// 给定一个长度为n的数组arr，arr中都是long类型的非负数，可能有重复值
class136/Code01_MaximumXor.java:// 在这些数中选取任意个，使得异或和最大，返回最大的异或和
class136/Code01_MaximumXor.java:// 1 <= n <= 50
class136/Code01_MaximumXor.java:// 0 <= arr[i] <= 2^50
class136/Code01_MaximumXor.java:// 测试链接 : https://www.luogu.com.cn/problem/P3812
class136/Code01_MaximumXor.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class136/Code02_KthXor.java:// 第k小的异或和
class136/Code02_KthXor.java:// 给定一个长度为n的数组arr，arr中都是long类型的非负数，可能有重复值
class136/Code02_KthXor.java:// 在这些数中选取任意个，至少要选一个数字
class136/Code02_KthXor.java:// 可以得到很多异或和，假设异或和的结果去重
class136/Code02_KthXor.java:// 返回第k小的异或和
class136/Code02_KthXor.java:// 1 <= n <= 10^5
class136/Code02_KthXor.java:// 0 <= arr[i] <= 2^50
class136/Code02_KthXor.java:// 1 <= k <= 2^50
class136/Code02_KthXor.java:// 测试链接 : https://loj.ac/p/114
class136/Code02_KthXor.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class136/Code03_Elements.java:// 元素
class136/Code03_Elements.java:// 给定n个魔法矿石，每个矿石有状态和魔力，都是整数
class136/Code03_Elements.java:// 若干矿石组成的组合能否有效，根据状态异或的结果来决定
class136/Code03_Elements.java:// 如果一个矿石组合内部会产生异或和为0的子集，那么这个组合无效
class136/Code03_Elements.java:// 返回有效的矿石组合中，最大的魔力和是多少
class136/Code03_Elements.java:// 1 <= n <= 1000
class136/Code03_Elements.java:// 1 <= 状态 <= 10^18
class136/Code03_Elements.java:// 1 <= 魔力 <= 10^4
class136/Code03_Elements.java:// 测试链接 : https://www.luogu.com.cn/problem/P4570
class136/Code03_Elements.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class136/Code04_Lanterns.java:// 彩灯
class136/Code04_Lanterns.java:// 一共有n个灯泡，开始都是不亮的状态，有m个开关
class136/Code04_Lanterns.java:// 每个开关能改变若干灯泡的状态，改变是指，亮变不亮、不亮变亮
class136/Code04_Lanterns.java:// 比如n=5，某个开关为XXOOO，表示这个开关只能改变后3个灯泡的状态
class136/Code04_Lanterns.java:// 可以随意使用开关，返回有多少种亮灯的组合，全不亮也算一种组合
class136/Code04_Lanterns.java:// 结果可能很大对2008取余
class136/Code04_Lanterns.java:// 1 <= n <= 50
class136/Code04_Lanterns.java:// 1 <= m <= 50
class136/Code04_Lanterns.java:// 测试链接 : https://www.luogu.com.cn/problem/P3857
class136/Code04_Lanterns.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class136/ShowDetails.java:// 课上讲述普通消元、高斯消元构建异或空间线性基的例子
算法讲解137【扩展】线性基-下
class137/Code01_BuyEquipment.java:// 装备购买
class137/Code01_BuyEquipment.java:// 一共有n个物品，每个物品都有m个属性值
class137/Code01_BuyEquipment.java:// 下面定义什么是不必要的物品：如果已经选择了k个物品，此时又有一件当前物品
class137/Code01_BuyEquipment.java:// 如果给已经选择的物品分配一组相乘的系数，并把属性值相加，就能得到当前物品
class137/Code01_BuyEquipment.java:// 那么就说当前物品是不必要的，比如下面的例子
class137/Code01_BuyEquipment.java:// a = { 4, 6, 2 }, b = { 2, 8, 4 }, c = { 6, 19, 9 }
class137/Code01_BuyEquipment.java:// a * 0.5 + b * 2 = c，那么c物品是不必要的
class137/Code01_BuyEquipment.java:// 每个物品都有价格，现在希望尽量多的购买物品，但不能出现不必要的物品
class137/Code01_BuyEquipment.java:// 返回最多能买几件物品和最少的花费
class137/Code01_BuyEquipment.java:// 1 <= n、m <= 500
class137/Code01_BuyEquipment.java:// 0 <= 属性值 <= 1000
class137/Code01_BuyEquipment.java:// 测试链接 : https://www.luogu.com.cn/problem/P3265
class137/Code01_BuyEquipment.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class137/Code02_BucketMaximumXor.java:// P哥的桶
class137/Code02_BucketMaximumXor.java:// 一共有n个桶，排成一排，编号1~n，每个桶可以装下任意个数字
class137/Code02_BucketMaximumXor.java:// 高效的实现如下两个操作
class137/Code02_BucketMaximumXor.java:// 操作 1 k v : 把数字v放入k号桶中
class137/Code02_BucketMaximumXor.java:// 操作 2 l r : 可以从l..r号桶中随意拿数字，返回异或和最大的结果
class137/Code02_BucketMaximumXor.java:// 1 <= n、m <= 5 * 10^4
class137/Code02_BucketMaximumXor.java:// 0 <= v <= 2^31 - 1
class137/Code02_BucketMaximumXor.java:// 测试链接 : https://www.luogu.com.cn/problem/P4839
class137/Code02_BucketMaximumXor.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class137/Code03_LuckyNumber1.java:// 幸运数字(递归版)
class137/Code03_LuckyNumber1.java:// 一共有n个点，编号1~n，由n-1条边连成一棵树，每个点上有数字
class137/Code03_LuckyNumber1.java:// 一共有q条查询，每次返回a到b的路径上，可以随意选择数字，能得到的最大异或和
class137/Code03_LuckyNumber1.java:// 1 <= n <= 2 * 10^4
class137/Code03_LuckyNumber1.java:// 1 <= q <= 2 * 10^5
class137/Code03_LuckyNumber1.java:// 0 <= 点上的数字 <= 2^60
class137/Code03_LuckyNumber1.java:// 测试链接 : https://www.luogu.com.cn/problem/P3292
class137/Code03_LuckyNumber1.java:// 提交以下的code，提交时请把类名改成"Main"
class137/Code03_LuckyNumber1.java:// C++这么写能通过，java会因为递归层数太多而爆栈
class137/Code03_LuckyNumber1.java:// java能通过的写法参考本节课Code03_LuckyNumber2文件
class137/Code03_LuckyNumber2.java:// 幸运数字(迭代版)
class137/Code03_LuckyNumber2.java:// 一共有n个点，编号1~n，由n-1条无向边连成一棵树，每个点上有数字
class137/Code03_LuckyNumber2.java:// 一共有q条查询，每次返回a到b的路径上，可以随意选择数字，能得到的最大异或和
class137/Code03_LuckyNumber2.java:// 1 <= n <= 2 * 10^4
class137/Code03_LuckyNumber2.java:// 1 <= q <= 2 * 10^5
class137/Code03_LuckyNumber2.java:// 0 <= 点上的数字 <= 2^60
class137/Code03_LuckyNumber2.java:// 测试链接 : https://www.luogu.com.cn/problem/P3292
class137/Code03_LuckyNumber2.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class137/Code04_MaximumXorOfPath1.java:// 路径最大异或和(递归版)
class137/Code04_MaximumXorOfPath1.java:// 一共有n个点，编号1~n，由m条无向边连接
class137/Code04_MaximumXorOfPath1.java:// 每条边有权值，输入保证图是联通的，可能有环
class137/Code04_MaximumXorOfPath1.java:// 找到1到n的一条路径，路径可以重复经过某些点或边
class137/Code04_MaximumXorOfPath1.java:// 当一条边在路径中出现了多次时，异或的时候也要算多次
class137/Code04_MaximumXorOfPath1.java:// 希望找到一条从1到n的路径，所有边权异或和尽量大，返回这个最大异或和
class137/Code04_MaximumXorOfPath1.java:// 1 <= n <= 50000
class137/Code04_MaximumXorOfPath1.java:// 1 <= m <= 100000
class137/Code04_MaximumXorOfPath1.java:// 0 <= 边权 <= 10^18
class137/Code04_MaximumXorOfPath1.java:// 测试链接 : https://www.luogu.com.cn/problem/P4151
class137/Code04_MaximumXorOfPath1.java:// 提交以下的code，提交时请把类名改成"Main"
class137/Code04_MaximumXorOfPath1.java:// C++这么写能通过，java会因为递归层数太多而爆栈
class137/Code04_MaximumXorOfPath1.java:// java能通过的写法参考本节课Code04_MaximumXorOfPath2文件
class137/Code04_MaximumXorOfPath2.java:// 路径最大异或和(迭代版)
class137/Code04_MaximumXorOfPath2.java:// 一共有n个点，编号1~n，由m条无向边连接
class137/Code04_MaximumXorOfPath2.java:// 每条边有权值，输入保证图是联通的，可能有环
class137/Code04_MaximumXorOfPath2.java:// 找到1到n的一条路径，路径可以重复经过某些点或边
class137/Code04_MaximumXorOfPath2.java:// 当一条边在路径中出现了多次时，异或的时候也要算多次
class137/Code04_MaximumXorOfPath2.java:// 希望找到一条从1到n的路径，所有边权异或和尽量大，返回这个最大异或和
class137/Code04_MaximumXorOfPath2.java:// 1 <= n <= 50000
class137/Code04_MaximumXorOfPath2.java:// 1 <= m <= 100000
class137/Code04_MaximumXorOfPath2.java:// 0 <= 边权 <= 10^18
class137/Code04_MaximumXorOfPath2.java:// 测试链接 : https://www.luogu.com.cn/problem/P4151
class137/Code04_MaximumXorOfPath2.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
算法讲解138【扩展】01分数规划
class138/Code01_DroppingTests.java:// 01分数规划模版题
class138/Code01_DroppingTests.java:// 给定n个数据，每个数据有(a, b)两个值，都为整数，并且都是非负的
class138/Code01_DroppingTests.java:// 请舍弃掉k个数据，希望让剩下数据做到，所有a的和 / 所有b的和，这个比值尽量大
class138/Code01_DroppingTests.java:// 如果剩下数据所有b的和为0，认为无意义
class138/Code01_DroppingTests.java:// 最后，将该比值 * 100，小数部分四舍五入的整数结果返回
class138/Code01_DroppingTests.java:// 1 <= n <= 100
class138/Code01_DroppingTests.java:// 0 <= a、b <= 10^9
class138/Code01_DroppingTests.java:// 测试链接 : https://www.luogu.com.cn/problem/P10505
class138/Code01_DroppingTests.java:// 测试链接 : http://poj.org/problem?id=2976
class138/Code01_DroppingTests.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class138/Code02_TalentShow.java:// 牛群的才艺展示
class138/Code02_TalentShow.java:// 一共有n只牛，每只牛有重量和才艺两个属性值
class138/Code02_TalentShow.java:// 要求一定要选若干只牛，使得总重量不少于w，并且选出的牛，希望让
class138/Code02_TalentShow.java:// 才艺的和 / 重量的和，这个比值尽量大
class138/Code02_TalentShow.java:// 返回该比值 * 1000的整数结果，小数部分舍弃
class138/Code02_TalentShow.java:// 1 <= n <= 250
class138/Code02_TalentShow.java:// 1 <= w <= 1000
class138/Code02_TalentShow.java:// 1 <= 牛的重量 <= 10^6
class138/Code02_TalentShow.java:// 1 <= 牛的才艺 <= 10^3
class138/Code02_TalentShow.java:// 测试链接 : https://www.luogu.com.cn/problem/P4377
class138/Code02_TalentShow.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class138/Code03_DesertKing.java:// 最优比率生成树
class138/Code03_DesertKing.java:// 一共有n个村庄，每个村庄由(x, y, z)表示
class138/Code03_DesertKing.java:// 其中(x,y)代表村庄在二维地图中的位置，z代表其海拔高度
class138/Code03_DesertKing.java:// 任意两个村庄之间的距离就是二维地图中的欧式距离
class138/Code03_DesertKing.java:// 任意两个村庄之间的修路花费就是海拔差值的绝对值
class138/Code03_DesertKing.java:// 现在想把所有村庄联通起来，希望修路的条数尽量少，同时希望让
class138/Code03_DesertKing.java:// 总花费 / 总距离，这个比值尽量小，返回最小的比值是多少，结果保留小数点后3位其余部分舍弃
class138/Code03_DesertKing.java:// 2 <= n <= 10^3
class138/Code03_DesertKing.java:// 0 <= x、y <= 10^4
class138/Code03_DesertKing.java:// 0 <= z <= 10^7
class138/Code03_DesertKing.java:// 测试链接 : http://poj.org/problem?id=2728
class138/Code03_DesertKing.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class138/Code04_MinimumAverageCircle.java:// 最小圈
class138/Code04_MinimumAverageCircle.java:// 一共有n个节点，m条有向边，每条边有权值
class138/Code04_MinimumAverageCircle.java:// 这个有向带权图中，可能有若干环，规定环的平均值为
class138/Code04_MinimumAverageCircle.java:// 环中边的权值和 / 环中边的数量
class138/Code04_MinimumAverageCircle.java:// 返回所有环的平均值中最少的平均值，结果保留小数点后8位，其余部分舍弃
class138/Code04_MinimumAverageCircle.java:// 1 <= n <= 3000
class138/Code04_MinimumAverageCircle.java:// 1 <= m <= 10000
class138/Code04_MinimumAverageCircle.java:// -10^7 <= 边权 <= 10^7
class138/Code04_MinimumAverageCircle.java:// 测试链接 : https://www.luogu.com.cn/problem/P3199
class138/Code04_MinimumAverageCircle.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class138/Code05_BestTeam.java:// 最佳团体
class138/Code05_BestTeam.java:// 给定一棵树，节点编号0~n，0号节点是整棵树的头
class138/Code05_BestTeam.java:// 编号1~n的节点，每个节点都有招募花费和战斗值，0号节点这两个值都是0
class138/Code05_BestTeam.java:// 给定每条边(a,b)，表示节点a的父节点是b，有些节点的父节点是0节点
class138/Code05_BestTeam.java:// 当招募了某个节点，那么该节点及其上方的所有祖先节点都需要招募
class138/Code05_BestTeam.java:// 除了0号节点之外，一共可以招募k个人，希望让
class138/Code05_BestTeam.java:// 战斗值之和 / 招募花费之和，这个比值尽量大，答案只需保留三位小数，更大的精度舍弃
class138/Code05_BestTeam.java:// 1 <= k <= n <= 2500
class138/Code05_BestTeam.java:// 0 <= 招募花费、战斗值 <= 10^4
class138/Code05_BestTeam.java:// 测试链接 : https://www.luogu.com.cn/problem/P4322
class138/Code05_BestTeam.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
算法讲解139【扩展】裴蜀定理和扩展欧几里得算法
class139/Code01_BezoutLemma.java:// 裴蜀定理模版题
class139/Code01_BezoutLemma.java:// 给定长度为n的一组整数值[a1, a2, a3...]，你找到一组数值[x1, x2, x3...]
class139/Code01_BezoutLemma.java:// 要让a1*x1 + a2*x2 + a3*x3...得到的结果为最小正整数
class139/Code01_BezoutLemma.java:// 返回能得到的最小正整数是多少
class139/Code01_BezoutLemma.java:// 1 <= n <= 20
class139/Code01_BezoutLemma.java:// 1 <= ai <= 10^5
class139/Code01_BezoutLemma.java:// 测试链接 : https://www.luogu.com.cn/problem/P4549
class139/Code01_BezoutLemma.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class139/Code02_Pagodas.java:// 修理宝塔
class139/Code02_Pagodas.java:// 一共有编号1~n的宝塔，其中a号和b号宝塔已经修好了
class139/Code02_Pagodas.java:// Yuwgna和Iaka两个人轮流修塔，Yuwgna先手，Iaka后手，谁先修完所有的塔谁赢
class139/Code02_Pagodas.java:// 每次可以选择j+k号或者j-k号塔进行修理，其中j和k是任意两个已经修好的塔
class139/Code02_Pagodas.java:// 也就是输入n、a、b，如果先手赢打印"Yuwgna"，后手赢打印"Iaka"
class139/Code02_Pagodas.java:// 2 <= n <= 2 * 10^4
class139/Code02_Pagodas.java:// 测试链接 : https://acm.hdu.edu.cn/showproblem.php?pid=5512
class139/Code02_Pagodas.java:// 测试链接 : https://vjudge.net/problem/HDU-5512
class139/Code02_Pagodas.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class139/Code03_UniformGenerator.java:// 均匀生成器
class139/Code03_UniformGenerator.java:// 如果有两个数字step和mod，那么可以由以下方式生成很多数字
class139/Code03_UniformGenerator.java:// seed(1) = 0，seed(i+1) = (seed(i) + step) % mod
class139/Code03_UniformGenerator.java:// 比如，step = 3、mod = 5
class139/Code03_UniformGenerator.java:// seed(1) = 0，seed(2) = 3，seed(3) = 1，seed(4) = 4，seed(5) = 2
class139/Code03_UniformGenerator.java:// 如果能产生0 ~ mod-1所有数字，step和mod的组合叫  "Good Choice"
class139/Code03_UniformGenerator.java:// 如果无法产生0 ~ mod-1所有数字，step和mod的组合叫 "Bad Choice"
class139/Code03_UniformGenerator.java:// 根据step和mod，打印结果
class139/Code03_UniformGenerator.java:// 1 <= step、mod <= 10^5
class139/Code03_UniformGenerator.java:// 测试链接 : http://poj.org/problem?id=1597
class139/Code03_UniformGenerator.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class139/Code04_CongruenceEquation.java:// 同余方程
class139/Code04_CongruenceEquation.java:// 求关于x的同余方程 ax ≡ 1(mod b) 的最小正整数解
class139/Code04_CongruenceEquation.java:// 题目保证一定有解，也就是a和b互质
class139/Code04_CongruenceEquation.java:// 2 <= a、b <= 2 * 10^9
class139/Code04_CongruenceEquation.java:// 测试链接 : https://www.luogu.com.cn/problem/P1082
class139/Code04_CongruenceEquation.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class139/Code05_ShuffleCards.java:// 洗牌
class139/Code05_ShuffleCards.java:// 一共有n张牌，n一定是偶数，每张牌的牌面从1到n，洗牌规则如下
class139/Code05_ShuffleCards.java:// 比如n = 6，牌面最初排列为1 2 3 4 5 6
class139/Code05_ShuffleCards.java:// 先分成左堆1 2 3，右堆4 5 6，然后按照右堆第i张在前，左堆第i张在后的方式依次放置
class139/Code05_ShuffleCards.java:// 所以洗一次后，得到 4 1 5 2 6 3
class139/Code05_ShuffleCards.java:// 如果再洗一次，得到 2 4 6 1 3 5
class139/Code05_ShuffleCards.java:// 如果再洗一次，得到 1 2 3 4 5 6
class139/Code05_ShuffleCards.java:// 想知道n张牌洗m次的之后，第l张牌，是什么牌面
class139/Code05_ShuffleCards.java:// 1 <= n <= 10^10，n为偶数
class139/Code05_ShuffleCards.java:// 0 <= m <= 10^10
class139/Code05_ShuffleCards.java:// 测试链接 : https://www.luogu.com.cn/problem/P2054
class139/Code05_ShuffleCards.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
算法讲解140【扩展】扩展欧几里得和二元一次不定方程
class140/Code01_DiophantineEquation1.java:// 二元一次不定方程模版
class140/Code01_DiophantineEquation1.java:// 给定a、b、c，求解方程ax + by = c
class140/Code01_DiophantineEquation1.java:// 如果方程无解打印-1
class140/Code01_DiophantineEquation1.java:// 如果方程无正整数解，但是有整数解
class140/Code01_DiophantineEquation1.java:// 打印这些整数解中，x的最小正数值，y的最小正数值
class140/Code01_DiophantineEquation1.java:// 如果方程有正整数解，打印正整数解的数量，同时打印所有正整数解中，
class140/Code01_DiophantineEquation1.java:// x的最小正数值，y的最小正数值，x的最大正数值，y的最大正数值
class140/Code01_DiophantineEquation1.java:// 1 <= a、b、c <= 10^9
class140/Code01_DiophantineEquation1.java:// 测试链接 : https://www.luogu.com.cn/problem/P5656
class140/Code01_DiophantineEquation1.java:// 如下实现是正确的，但是洛谷平台对空间卡的很严，只有使用C++能全部通过
class140/Code01_DiophantineEquation1.java:// java的版本就是无法完全通过的，空间会超过限制，主要是IO空间占用大
class140/Code01_DiophantineEquation1.java:// 这是洛谷平台没有照顾各种语言的实现所导致的
class140/Code01_DiophantineEquation1.java:// 在真正笔试、比赛时，一定是兼顾各种语言的，该实现是一定正确的
class140/Code01_DiophantineEquation1.java:// C++版本就是Code01_DiophantineEquation2文件
class140/Code01_DiophantineEquation1.java:// C++版本和java版本逻辑完全一样，但只有C++版本可以通过所有测试用例
class140/Code01_DiophantineEquation2.java:// 二元一次不定方程模版
class140/Code01_DiophantineEquation2.java:// 给定a、b、c，求解方程ax + by = c
class140/Code01_DiophantineEquation2.java:// 如果方程无解打印-1
class140/Code01_DiophantineEquation2.java:// 如果方程无正整数解，但是有整数解
class140/Code01_DiophantineEquation2.java:// 打印这些整数解中，x的最小正数值，y的最小正数值
class140/Code01_DiophantineEquation2.java:// 如果方程有正整数解，打印正整数解的数量，同时打印所有正整数解中，
class140/Code01_DiophantineEquation2.java:// x的最小正数值，y的最小正数值，x的最大正数值，y的最大正数值
class140/Code01_DiophantineEquation2.java:// 1 <= a、b、c <= 10^9
class140/Code01_DiophantineEquation2.java:// 测试链接 : https://www.luogu.com.cn/problem/P5656
class140/Code01_DiophantineEquation2.java:// 如下实现是C++的版本，C++版本和java版本逻辑完全一样
class140/Code01_DiophantineEquation2.java:// 提交如下代码，可以通过所有测试用例
class140/Code01_DiophantineEquation2.java://#include <iostream>
class140/Code01_DiophantineEquation2.java://
class140/Code01_DiophantineEquation2.java://#include <cstdio>
class140/Code01_DiophantineEquation2.java://
class140/Code01_DiophantineEquation2.java://using namespace std;
class140/Code01_DiophantineEquation2.java://
class140/Code01_DiophantineEquation2.java://long long d, x, y, px, py;
class140/Code01_DiophantineEquation2.java://
class140/Code01_DiophantineEquation2.java://void exgcd(long long a, long long b) {
class140/Code01_DiophantineEquation2.java://    if (b == 0) {
class140/Code01_DiophantineEquation2.java://        d = a;
class140/Code01_DiophantineEquation2.java://        x = 1;
class140/Code01_DiophantineEquation2.java://        y = 0;
class140/Code01_DiophantineEquation2.java://    } else {
class140/Code01_DiophantineEquation2.java://        exgcd(b, a % b);
class140/Code01_DiophantineEquation2.java://        px = x;
class140/Code01_DiophantineEquation2.java://        py = y;
class140/Code01_DiophantineEquation2.java://        x = py;
class140/Code01_DiophantineEquation2.java://        y = px - py * (a / b);
class140/Code01_DiophantineEquation2.java://    }
class140/Code01_DiophantineEquation2.java://}
class140/Code01_DiophantineEquation2.java://
class140/Code01_DiophantineEquation2.java://long long a, b, c, xd, yd, times;
class140/Code01_DiophantineEquation2.java://
class140/Code01_DiophantineEquation2.java://int main() {
class140/Code01_DiophantineEquation2.java://    int cases;
class140/Code01_DiophantineEquation2.java://    scanf("%d", &cases);
class140/Code01_DiophantineEquation2.java://    for (int t = 1; t <= cases; t++) {
class140/Code01_DiophantineEquation2.java://        scanf("%lld %lld %lld", &a, &b, &c);
class140/Code01_DiophantineEquation2.java://        exgcd(a, b);
class140/Code01_DiophantineEquation2.java://        if (c % d != 0) {
class140/Code01_DiophantineEquation2.java://            printf("-1\n");
class140/Code01_DiophantineEquation2.java://        } else {
class140/Code01_DiophantineEquation2.java://            x *= c / d;
class140/Code01_DiophantineEquation2.java://            y *= c / d;
class140/Code01_DiophantineEquation2.java://            xd = b / d;
class140/Code01_DiophantineEquation2.java://            yd = a / d;
class140/Code01_DiophantineEquation2.java://            if (x < 0) {
class140/Code01_DiophantineEquation2.java://                times = (xd - x) / xd;
class140/Code01_DiophantineEquation2.java://                x += xd * times;
class140/Code01_DiophantineEquation2.java://                y -= yd * times;
class140/Code01_DiophantineEquation2.java://            } else {
class140/Code01_DiophantineEquation2.java://                times = (x - 1) / xd;
class140/Code01_DiophantineEquation2.java://                x -= xd * times;
class140/Code01_DiophantineEquation2.java://                y += yd * times;
class140/Code01_DiophantineEquation2.java://            }
class140/Code01_DiophantineEquation2.java://            if (y <= 0) {
class140/Code01_DiophantineEquation2.java://                printf("%lld ", x);
class140/Code01_DiophantineEquation2.java://                printf("%lld\n", y + yd * ((yd - y) / yd));
class140/Code01_DiophantineEquation2.java://            } else {
class140/Code01_DiophantineEquation2.java://                printf("%lld ", ((y - 1) / yd + 1));
class140/Code01_DiophantineEquation2.java://                printf("%lld ", x);
class140/Code01_DiophantineEquation2.java://                printf("%lld ", (y - (y - 1) / yd * yd));
class140/Code01_DiophantineEquation2.java://                printf("%lld ", (x + (y - 1) / yd * xd));
class140/Code01_DiophantineEquation2.java://                printf("%lld\n", y);
class140/Code01_DiophantineEquation2.java://            }
class140/Code01_DiophantineEquation2.java://        }
class140/Code01_DiophantineEquation2.java://    }
class140/Code01_DiophantineEquation2.java://    return 0;
class140/Code01_DiophantineEquation2.java://}
class140/Code02_FrogsMeeting.java:// 青蛙的约会
class140/Code02_FrogsMeeting.java:// 有一个周长为l的环，从环的0位置开始，规定只能沿着顺时针方向不停转圈
class140/Code02_FrogsMeeting.java:// 青蛙A在环的x1位置，每秒跳m个单位，青蛙B在x2位置，每秒跳n个单位
class140/Code02_FrogsMeeting.java:// 只有在某时刻，青蛙A和青蛙B来到环的同一个位置，才算相遇
class140/Code02_FrogsMeeting.java:// 如果两只青蛙相遇不了，打印"Impossible"
class140/Code02_FrogsMeeting.java:// 如果可以相遇，打印两只青蛙至少多久才能相遇
class140/Code02_FrogsMeeting.java:// 1 <= l <= 3 * 10^9
class140/Code02_FrogsMeeting.java:// 1 <= x1、x2、m、n <= 2 * 10^9
class140/Code02_FrogsMeeting.java:// x1 != x2
class140/Code02_FrogsMeeting.java:// 测试链接 : https://www.luogu.com.cn/problem/P1516
class140/Code02_FrogsMeeting.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class140/Code03_HowManyPoints.java:// 格点连线上有几个格点
class140/Code03_HowManyPoints.java:// 二维网格中只有x和y的值都为整数的坐标，才叫格点
class140/Code03_HowManyPoints.java:// 给定两个格点，A在(x1, y1)，B在(x2, y2)
class140/Code03_HowManyPoints.java:// 返回A和B的连线上，包括A和B在内，一共有几个格点
class140/Code03_HowManyPoints.java:// -10^9 <= x1、y1、x2、y2 <= 10^9
class140/Code03_HowManyPoints.java:// 测试链接 : https://lightoj.com/problem/how-many-points
class140/Code03_HowManyPoints.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class140/Code04_Area.java:// 机器人的移动区域
class140/Code04_Area.java:// 二维网格中只有x和y的值都为整数的坐标，才叫格点
class140/Code04_Area.java:// 某个机器人从格点(0,0)出发，每次机器人都走直线到达(x + dx, y + dy)的格点
class140/Code04_Area.java:// 一共移动n次，每次的(dx, dy)都给定，途中路线不会交叉，输入保证机器人最终回到(0,0)
class140/Code04_Area.java:// 机器人走的路线所围成的区域一定是多边形，输入保证机器人一定沿着逆时针方向行动
class140/Code04_Area.java:// 返回多边形的内部一共几个格点，多边形的边上一共几个格点，多边形的面积
class140/Code04_Area.java:// 3 <= n <= 100
class140/Code04_Area.java:// -100 <= dx、dy <= 100
class140/Code04_Area.java:// 测试链接 : http://poj.org/problem?id=1265
class140/Code04_Area.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class140/Code05_LargestUnattainable.java:// 无法组成的最大值
class140/Code05_LargestUnattainable.java:// 一共有a、b两种面值的硬币，a和b一定互质，每种硬币都有无限个
class140/Code05_LargestUnattainable.java:// 返回a和b无法组成的钱数中，最大值是多少
class140/Code05_LargestUnattainable.java:// 题目的输入保证存在最大的无法组成的钱数
class140/Code05_LargestUnattainable.java:// 1 <= a、b <= 10^9
class140/Code05_LargestUnattainable.java:// 测试链接 : https://www.luogu.com.cn/problem/P3951
class140/Code05_LargestUnattainable.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
算法讲解141【扩展】中国剩余定理及其扩展
class141/Code01_CRT.java:// 中国剩余定理模版
class141/Code01_CRT.java:// 给出n个同余方程，求满足同余方程的最小正数解x
class141/Code01_CRT.java:// 一共n个同余方程，x ≡ ri(% mi)
class141/Code01_CRT.java:// 1 <= n <= 10
class141/Code01_CRT.java:// 0 <= ri、mi <= 10^5
class141/Code01_CRT.java:// 所有mi一定互质
class141/Code01_CRT.java:// 所有mi整体乘积 <= 10^18
class141/Code01_CRT.java:// 测试链接 : https://www.luogu.com.cn/problem/P1495
class141/Code01_CRT.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class141/Code02_EXCRT.java:// 扩展中国剩余定理模版
class141/Code02_EXCRT.java:// 给出n个同余方程，求满足同余方程的最小正数解x
class141/Code02_EXCRT.java:// 一共n个同余方程，x ≡ ri(% mi)
class141/Code02_EXCRT.java:// 1 <= n <= 10^5
class141/Code02_EXCRT.java:// 0 <= ri、mi <= 10^12
class141/Code02_EXCRT.java:// 所有mi不一定互质
class141/Code02_EXCRT.java:// 所有mi的最小公倍数 <= 10^18
class141/Code02_EXCRT.java:// 测试链接 : https://www.luogu.com.cn/problem/P4777
class141/Code02_EXCRT.java:// 测试链接 : https://www.luogu.com.cn/problem/P1495
class141/Code02_EXCRT.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class141/Code03_GuessNumber.java:// 猜数字
class141/Code03_GuessNumber.java:// 给定两个长度为n数组，一组为r1，r2，r3...，另一组为m1，m2，m3...
class141/Code03_GuessNumber.java:// 其中第二组数字两两互质，求最小正数解x
class141/Code03_GuessNumber.java:// 要求x满足，mi | (x - ri)，即(x - ri)是mi的整数倍
class141/Code03_GuessNumber.java:// 1 <= n <= 10
class141/Code03_GuessNumber.java:// -10^9 <= ri <= +10^9
class141/Code03_GuessNumber.java:// 1 <= mi <= 6 * 10^3
class141/Code03_GuessNumber.java:// 所有mi的乘积 <= 10^18
class141/Code03_GuessNumber.java:// 测试链接 : https://www.luogu.com.cn/problem/P3868
class141/Code03_GuessNumber.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
class141/Code04_DragonSlayer.java:// 屠龙勇士
class141/Code04_DragonSlayer.java:// 一共n只巨龙，每只巨龙都有初始血量hp[i]，每只巨龙都有恢复能力recovery[i]
class141/Code04_DragonSlayer.java:// 每只巨龙都会在攻击结束后开始恢复，初始一共m把剑，每把剑攻击力init[i]
class141/Code04_DragonSlayer.java:// 每只巨龙只有当血量恰好为0时，才能被杀死。面对某只具体的龙，只能用固定的剑来攻击，规定如下：
class141/Code04_DragonSlayer.java:// 攻击力不高于当前巨龙的血量，并且攻击力最大的一把剑，如果没有这样的剑，就选择攻击力最低的一把剑
class141/Code04_DragonSlayer.java:// 需要按1~n的顺序依次讨伐巨龙，i号巨龙被杀后，那把攻击的剑会消失，同时奖励攻击力reward[i]的剑
class141/Code04_DragonSlayer.java:// 勇士制定的策略如下，不管面对什么巨龙，攻击过程只打击ans下，让当前巨龙的血量<=0
class141/Code04_DragonSlayer.java:// 然后在当前巨龙恢复的过程中，如果血量恰好为0，那么当前巨龙被杀死，勇士继续讨伐下一只
class141/Code04_DragonSlayer.java:// 你的任务是算出最小的ans，让勇士可以在该策略下杀死所有巨龙
class141/Code04_DragonSlayer.java:// 如果在固定打击次数的策略下，就是无法杀死所有巨龙，返回-1
class141/Code04_DragonSlayer.java:// 查看数据范围可以打开测试链接 : https://www.luogu.com.cn/problem/P4774
class141/Code04_DragonSlayer.java:// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例
算法讲解142【扩展】负环和差分约束
class142/Code01_DifferenceConstraints.java:// 负环和差分约束模版题
class142/Code01_DifferenceConstraints.java:// 测试链接 : https://www.luogu.com.cn/problem/P5960
class142/Code02_KsFarm.java:// 小K的农场
class142/Code02_KsFarm.java:// 测试链接 : https://www.luogu.com.cn/problem/P1993
class142/Code03_Wormholes.java:// 虫洞
class142/Code03_Wormholes.java:// 测试链接 : https://www.luogu.com.cn/problem/P2850
class142/Code04_Balance.java:// 天平
class142/Code04_Balance.java:// 测试链接 : https://www.luogu.com.cn/problem/P2474
