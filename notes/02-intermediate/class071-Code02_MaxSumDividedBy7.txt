// 子序列累加和必须被7整除的最大累加和
// 给定一个非负数组nums，
// 可以任意选择数字组成子序列，但是子序列的累加和必须被7整除
// 返回最大累加和
// 对数器验证
	// 暴力方法
	// 为了验证
		// nums形成的所有子序列的累加和都求出来
		// 其中%7==0的那些累加和中，返回最大的
		// 就是如下f函数的功能
	// 正式方法
	// 时间复杂度O(n)
		// dp[i][j] : nums[0...i-1]
		// nums前i个数形成的子序列一定要做到，子序列累加和%7 == j
		// 这样的子序列最大累加和是多少
		// 注意 : dp[i][j] == -1代表不存在这样的子序列
				// 这里求need是核心
				// 或者如下这种写法也对
				// need = (7 + j - cur) % 7;
	// 为了测试
	// 生成随机数组
	// 为了测试
	// 对数器
