// 贿赂怪兽
// 开始时你的能力是0，你的目标是从0号怪兽开始，通过所有的n只怪兽
// 如果你当前的能力小于i号怪兽的能力，则必须付出b[i]的钱贿赂这个怪兽
// 然后怪兽就会加入你，他的能力a[i]直接累加到你的能力上
// 如果你当前的能力大于等于i号怪兽的能力，你可以选择直接通过，且能力不会下降
// 但你依然可以选择贿赂这个怪兽，然后怪兽的能力直接累加到你的能力上
// 返回通过所有的怪兽，需要花的最小钱数
// 测试链接 : https://www.nowcoder.com/practice/736e12861f9746ab8ae064d4aae2d5a9
// 请同学们务必参考如下代码中关于输入、输出的处理
// 这是输入输出处理效率很高的写法
// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
	// 讲解本题的目的不仅仅是为了通过这个题，而是进行如下的思考:
	// 假设a[i]数值的范围很大，但是b[i]数值的范围不大，该怎么做？
	// 假设a[i]数值的范围不大，但是b[i]数值的范围很大，又该怎么做？
	// 假设a[i]数值的范围很大，但是b[i]数值的范围不大
	// 时间复杂度O(n * 所有怪兽的钱数累加和)
		// dp[i][j] : 花的钱不能超过j，通过前i个怪兽，最大能力是多少
		// 如果dp[i][j] == Integer.MIN_VALUE
		// 表示花的钱不能超过j，无论如何都无法通过前i个怪兽
	// 就是方法1的空间压缩版本
	// 假设a[i]数值的范围不大，但是b[i]数值的范围很大
	// 时间复杂度O(n * 所有怪兽的能力累加和)
		// dp[i][j] : 能力正好是j，并且确保能通过前i个怪兽，需要至少花多少钱
		// 如果dp[i][j] == Integer.MAX_VALUE
		// 表示能力正好是j，无论如何都无法通过前i个怪兽
	// 就是方法3的空间压缩版本
