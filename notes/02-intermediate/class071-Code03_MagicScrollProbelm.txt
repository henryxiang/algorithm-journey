// 魔法卷轴
// 给定一个数组nums，其中可能有正、负、0
// 每个魔法卷轴可以把nums中连续的一段全变成0
// 你希望数组整体的累加和尽可能大
// 卷轴使不使用、使用多少随意，但一共只有2个魔法卷轴
// 请返回数组尽可能大的累加和
// 对数器验证
	// 暴力方法
	// 为了测试
	// 暴力方法
	// 为了测试
	// nums[l...r]范围上一定要用一次卷轴情况下的最大累加和
		// l...r范围上包含a...b范围
		// 如果a...b范围上的数字都变成0
		// 返回剩下数字的累加和
		// 所以枚举所有可能的a...b范围
		// 相当暴力，但是正确
				// l...a...b...r
	// 正式方法
	// 时间复杂度O(n)
		// 情况1 : 完全不使用卷轴
		// prefix[i] : 0~i范围上一定要用1次卷轴的情况下，0~i范围上整体最大累加和多少
		// 每一步的前缀和
		// maxPresum : 之前所有前缀和的最大值
		// 情况二 : 必须用1次卷轴
		// suffix[i] : i~n-1范围上一定要用1次卷轴的情况下，i~n-1范围上整体最大累加和多少
		// 情况二 : 必须用2次卷轴
			// 枚举所有的划分点i
			// 0~i-1 左
			// i~n-1 右
	// 为了测试
	// 为了测试
