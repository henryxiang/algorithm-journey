// 好路径的数目
// 给你一棵 n 个节点的树（连通无向无环的图）
// 节点编号从0到n-1，且恰好有n-1条边
// 给你一个长度为 n 下标从 0 开始的整数数组 vals
// 分别表示每个节点的值。同时给你一个二维整数数组 edges
// 其中 edges[i] = [ai, bi] 表示节点 ai 和 bi 之间有一条 无向 边
// 好路径需要满足以下条件：开始和结束节点的值相同、 路径中所有值都小于等于开始的值
// 请你返回不同好路径的数目
// 注意，一条路径和它反向的路径算作 同一 路径
// 比方说， 0 -> 1 与 1 -> 0 视为同一条路径。单个节点也视为一条合法路径
// 测试链接 : https://leetcode.cn/problems/number-of-good-paths/
	// 需要保证集合中，代表节点的值，一定是整个集合的最大值
	// 集合中最大值的次数，也就是 集合中代表节点的值有几个
	// 这个并查集的优化只来自扁平化
	// 核心！
	// 注意以下的写法！
	// 谁的值大，谁做代表节点
	// 同时注意 maxcnt 的更新
		// fx : x所在集团的代表节点，同时也是x所在集团的最大值下标
		// fy : y所在集团的代表节点，同时也是y所在集团的最大值下标
			// 两个集团最大值一样！
		// 课上重点讲这个核心排序！
		// 处理边的时候，依次从小节点往大节点处理
	// 课上讲解的例子1和例子2
		// 课上例子1
		//              0  1  2  3  4  5  6  7
		// 课上例子2
		//              0  1  2  3  4  5  6  7  8  9 10 11 12
