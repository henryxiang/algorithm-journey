// 扰乱字符串
// 使用下面描述的算法可以扰乱字符串 s 得到字符串 t ：
// 步骤1 : 如果字符串的长度为 1 ，算法停止
// 步骤2 : 如果字符串的长度 > 1 ，执行下述步骤：
//        在一个随机下标处将字符串分割成两个非空的子字符串
//        已知字符串s，则可以将其分成两个子字符串x和y且满足s=x+y
//        可以决定是要 交换两个子字符串 还是要 保持这两个子字符串的顺序不变
//        即s可能是 s = x + y 或者 s = y + x
//        在x和y这两个子字符串上继续从步骤1开始递归执行此算法
// 给你两个 长度相等 的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串
// 如果是，返回true ；否则，返回false
// 测试链接 : https://leetcode.cn/problems/scramble-string/
	// s1[l1....r1]
	// s2[l2....r2]
	// 保证l1....r1与l2....r2
	// 是不是扰乱串的关系
			// s1[l1..r1]
			// s2[l2..r2]
		// s1[l1..i][i+1....r1]
		// s2[l2..j][j+1....r2]
		// 不交错去讨论扰乱关系
		// 交错去讨论扰乱关系
		// s1[l1..........i][i+1...r1]
		// s2[l2...j-1][j..........r2]
	// 依然暴力尝试，只不过四个可变参数，变成了三个
		// s1[l1.......]  len
		// s2[l2.......]  len
		// 左 : k个   右: len - k 个
		// 交错！
		// dp[l1][l2][len] : int 0 -> 没展开过
		// dp[l1][l2][len] : int -1 -> 展开过，返回的结果是false
		// dp[l1][l2][len] : int 1 -> 展开过，返回的结果是true
		// 填写len=1层，所有的格子
			// 注意如下的边界条件 : l1 <= n - len l2 <= n - len
