// 最长公共子序列
// 给定两个字符串text1和text2
// 返回这两个字符串的最长 公共子序列 的长度
// 如果不存在公共子序列，返回0
// 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列
// 测试链接 : https://leetcode.cn/problems/longest-common-subsequence/
	// s1[0....i1]与s2[0....i2]最长公共子序列长度
	// 为了避免很多边界讨论
	// 很多时候往往不用下标来定义尝试，而是用长度来定义尝试
	// 因为长度最短是0，而下标越界的话讨论起来就比较麻烦
	// s1[前缀长度为len1]对应s2[前缀长度为len2]
	// 最长公共子序列长度
	// 记忆化搜索
	// 严格位置依赖的动态规划
	// 严格位置依赖的动态规划 + 空间压缩
