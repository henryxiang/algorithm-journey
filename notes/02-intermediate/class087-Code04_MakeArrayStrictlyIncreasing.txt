// 使数组严格递增的最小操作数
// 给你两个整数数组 arr1 和 arr2
// 返回使 arr1 严格递增所需要的最小操作数（可能为0）
// 每一步操作中，你可以分别从 arr1 和 arr2 中各选出一个索引
// 分别为 i 和 j，0 <= i < arr1.length 和 0 <= j < arr2.length
// 然后进行赋值运算 arr1[i] = arr2[j]
// 如果无法让 arr1 严格递增，请返回-1
// 1 <= arr1.length, arr2.length <= 2000
// 0 <= arr1[i], arr2[i] <= 10^9
// 测试链接 : https://leetcode.cn/problems/make-array-strictly-increasing/
	// arr1长度为n，arr2有效部分长度为m
	// arr2有效部分可以替换arr1中的数字
	// arr1[0..i-1]已经严格递增且arr1[i-1]一定没有替换
	// 返回让arr1整体都严格递增，arr1[i...]范围上还需要几次替换
	// 如果做不到，返回无穷大
		// ans : 遍历所有的分支，所得到的最少的操作次数
		// pre : 前一位的数字
		// find : arr2有效长度m的范围上，找到刚比pre大的位置
		// 枚举arr1[i...]范围上，第一个不需要替换的位置j
				// pre : 被arr2替换的前一位数字
	// arr2[0..size-1]范围上是严格递增的
	// 找到这个范围上>num的最左位置
	// 不存在返回-1
	// 严格位置依赖的动态规划
	// 和方法1的思路没有区别
	// 甚至填写dp表的逻辑都保持一致
