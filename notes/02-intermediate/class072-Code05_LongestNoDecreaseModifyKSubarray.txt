// 有一次修改机会的最长不下降子序列
// 给定一个长度为n的数组arr，和一个整数k
// 只有一次机会可以将其中连续的k个数全修改成任意一个值
// 这次机会你可以用也可以不用，请返回最长不下降子序列长度
// 1 <= k, n <= 10^5
// 1 <= arr[i] <= 10^6
// 测试链接 : https://www.luogu.com.cn/problem/P8776
// 请同学们务必参考如下代码中关于输入、输出的处理
// 这是输入输出处理效率很高的写法
// 提交以下的所有代码，并把主类名改成"Main"，可以直接通过
	// 生成辅助数组right
	// right[j] :
	// 一定以arr[j]做开头的情况下，arr[j...]上最长不下降子序列长度是多少
	// 关键逻辑 :
	// 一定以arr[i]做开头的情况下，arr[i...]上最长不下降子序列
	// 就是！从n-1出发来看(从右往左遍历)，以arr[i]做结尾的情况下的最长不上升子序列
	// 求最长不上升子序列长度的二分
	// ends[0...len-1]是降序的，找到<num的最左位置
	// 不存在返回-1
	// 求最长不下降子序列长度的二分
	// ends[0...len-1]是升序的，找到>num的最左位置
	// 不存在返回-1
