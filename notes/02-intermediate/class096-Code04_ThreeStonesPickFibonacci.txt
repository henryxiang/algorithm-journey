// 三堆石头拿取斐波那契数博弈
// 有三堆石头，数量分别为a、b、c
// 两个人轮流拿，每次可以选择其中一堆石头，拿取斐波那契数的石头
// 拿到最后一颗石子的人获胜，根据a、b、c返回谁赢
// 来自真实大厂笔试，每堆石子的数量在10^5以内
// 没有在线测试，对数器验证
	// 如果MAXN变大
	// 相应的要修改f数组
	// MAXN以内的斐波那契数
	// 动态规划方法彻底尝试
	// 为了验证
		// 假设当前的先手来行动
		// 注意不是全局的先手，是当前的先手来行动！
		// 当前！当前！当前！
			// 当前的先手，面对这个局面
			// 返回当前的后手赢
		String ans = "后手"; // ans : 赢的是当前的先手，还是当前的后手
					// 后续过程的赢家是后续过程的后手
					// 那就表示当前的先手，通过这个后续过程，能赢
					// 后续过程的赢家是后续过程的后手
					// 那就表示当前的先手，通过这个后续过程，能赢
					// 后续过程的赢家是后续过程的后手
					// 那就表示当前的先手，通过这个后续过程，能赢
	// sg定理
	// O(10^5 * 24 * 2)
		// 试图找到简洁规律，想通过O(1)的过程就得到sg(x)
		// 于是打印200以内的sg值，开始观察
		// 刚开始有规律，但是在sg(138)之后开始发生异常波动
		// 这道题在考的时候，数据量并没有大到需要O(1)的过程才能通过
		// 那就用build方法计算sg值，不再找寻简洁规律
		// 考试时一切根据题目数据量来决定是否继续优化
