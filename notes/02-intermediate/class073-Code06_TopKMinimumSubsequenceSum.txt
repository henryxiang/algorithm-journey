// 非负数组前k个最小的子序列累加和
// 给定一个数组nums，含有n个数字，都是非负数
// 给定一个正数k，返回所有子序列中累加和最小的前k个累加和
// 子序列是包含空集的
// 1 <= n <= 10^5
// 1 <= nums[i] <= 10^6
// 1 <= k <= 10^5
// 注意这个数据量，用01背包的解法是不行的，时间复杂度太高了
// 对数器验证
	// 暴力方法
	// 为了验证
	// 暴力方法
	// 得到所有子序列的和
	// 01背包来实现
	// 这种方法此时不是最优解
	// 因为n很大，数值也很大，那么可能的累加和就更大
	// 时间复杂度太差
		// dp[i][j]
		// 1) dp[i-1][j]
		// 2) dp[i-1][j-nums[i]
	// 正式方法
	// 用堆来做是最优解，时间复杂度O(n * log n) + O(k * log k)
		// (子序列的最右下标，子序列的累加和)
	// 为了测试
	// 为了测试
	// 为了测试
	// 对数器
