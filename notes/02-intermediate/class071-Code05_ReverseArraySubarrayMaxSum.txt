// 可以翻转1次的情况下子数组最大累加和
// 给定一个数组nums，
// 现在允许你随意选择数组连续一段进行翻转，也就是子数组逆序的调整
// 比如翻转[1,2,3,4,5,6]的[2~4]范围，得到的是[1,2,5,4,3,6]
// 返回必须随意翻转1次之后，子数组的最大累加和
// 对数器验证
	// 暴力方法
	// 为了验证
	// nums[l...r]范围上的数字进行逆序调整
	// 返回子数组最大累加和
	// 正式方法
	// 时间复杂度O(n)
		// start[i] : 所有必须以i开头的子数组中，最大累加和是多少
			// nums[i]
			// nums[i] + start[i+1]
		// end : 子数组必须以i-1结尾，其中的最大累加和
		// maxEnd :
		// 0~i-1范围上，
		// 子数组必须以0结尾，其中的最大累加和
		// 子数组必须以1结尾，其中的最大累加和
		// ...
		// 子数组必须以i-1结尾，其中的最大累加和
		// 所有情况中，最大的那个累加和就是maxEnd
			// maxend   i....
			// 枚举划分点 i...
			// 子数组必须以i结尾，其中的最大累加和
	// 为了测试
	// 生成随机数组
	// 为了测试
	// 对数器
