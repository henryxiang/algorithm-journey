// 数组中两个数的最大异或值
// 给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0<=i<=j<=n
// 1 <= nums.length <= 2 * 10^5
// 0 <= nums[i] <= 2^31 - 1
// 测试链接 : https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/
	// 前缀树的做法
	// 好想
	// 准备这么多静态空间就够了，实验出来的
	// 如果测试数据升级了规模，就改大这个值
	// 前缀树目前使用了多少空间
	// 数字只需要从哪一位开始考虑
		// 找个最大值
		// 计算数组最大值的二进制状态，有多少个前缀的0
		// 可以忽略这些前置的0，从left位开始考虑
		// 最终异或的结果(尽量大)
		// 前缀树目前来到的节点编号
			// status : num第i位的状态
			// want : num第i位希望遇到的状态
			if (tree[cur][want] == 0) { // 询问前缀树，能不能达成
				// 不能达成
			// want变成真的往下走的路
	// 用哈希表的做法
	// 难想
			// ans : 31....i+1 已经达成的目标
				// num : 31.....i 这些状态保留，剩下全成0
				// num ^ 某状态 是否能 达成better目标，就在set中找 某状态 : better ^ num
