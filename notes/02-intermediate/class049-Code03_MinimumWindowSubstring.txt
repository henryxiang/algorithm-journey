// 最小覆盖子串
// 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串
// 如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。
// 测试链接 : https://leetcode.cn/problems/minimum-window-substring/
		// 最小覆盖子串的长度
		// 从哪个位置开头，发现的这个最小覆盖子串
			// s[r] 当前字符 -> int
			// cnts[s[r]] : 当前字符欠债情况，负数就是欠债，正数就是多给的
				// r位置结尾，真的有覆盖子串！
				// 看看这个覆盖子串能不能尽量短
					// l位置的字符能拿回
				// 从while里面出来，
				// l....r就是r位置结尾的最小覆盖子串
